1. 포트폴리오 기획  
   1. 로드맵 정리  
      1. 요구사항 분석, 데이터 모델링, API 설계, UI/UX 설계(시각적인 설계는 나중에 확립 예정)  
2. 데이터 모델링  
   1. portfolio\_shopping\_mall 데이터베이스 생성  
   2. ‘users’ ‘products’ ‘categories’ ‘orders’ ‘order\_items’ ‘reviews’ 테이블 생성 & 세팅  
3. 포트폴리오 사이트 세팅  
   1. 도메인 세팅  
      1. Cloudflare 도메인 구매  
      2. AWS 라이트세일에 도메인 연결  
      3. Cloudflare에서 제공하는 HTTPS 보안 적용  
   2. 메인 hub 페이지 알파버전 연결  
      1. 기존에 올라가있던 연습용 스프링 프로젝트 연결해제하고 hub 페이지 알파버전(html, css) 올려서 연결  
4. 쇼핑몰 스프링 프로젝트 세팅  
   1. 서버의 Nginx 프록시 설정에 맞춰 application.properties에 ‘server.servlet.context-path=/gyp-shopping-mall’ 추가  
5. 서버 이슈 처리  
   1. 서버DB를 부르려는데 딜레이가 많이 생겨서 로그를 보니 CPU 사용량이 폭증한 내역 확인. 원인을 찾으려다 못찾고 아예 먹통이 되서 DB 접근이나 SSH도 안되는 이슈 발생. 서버 재부팅으로 해결하긴 했으나, 원인은 여전히 모르겠음.  
6. 쇼핑몰 스프링 프로젝트 백엔드 작업  
   1. vo를 짜야되는데, 이번엔 테이블이 여러개라 자동화가 가능한지 서치. 우여곡절 끝에 MyBatis Generator 확장기능 설치해서 자동화 적용하여 vo 자동 생성 성공.  
   2. 보안을 위해 Spring Security 관련 서치. config폴더에 SecurityConfig.java 연습삼아 만들어봄.  
   3. 알파버전 회원가입 API 세팅  
      1. 비밀번호 BCrypt 인코딩 로직을 UserService 단계에 추가  
   4. 알파버전 로그인 API 세팅  
      1. 로그인 시 이메일 존재 체크 로직, 비밀번호 BCrypt 검증 로직을 UserService 단계에 추가.  
   5. 회원가입 API 보강  
      1. 이메일 중복 체크 로직, 비밀번호 조건 검증 로직을 UserService 단계에 추가  
   6. 관리자 계정 관련 정리  
      1. 관리자 계정을 SQL 쿼리로 처음부터 추가하는 로직 추가. 비밀번호는 BCrypt 인코딩.  
      2. /admin/\*\* 경로는 관리자만 접근 가능하도록 SecurityConfig.java 세팅  
   7. 로그인 기록 로직 세팅 추가  
      1. 로그인 기록 테이블을 DB에 추가  
      2. 로그인 기록 추가 코드를 SecurityConfig.java에 세팅  
   8. 보안 관련 파일 구조 정리  
      1. SecurityConfig를 \`security/config\` 패키지로 이동  
      2. 보안 관련 파일들을 체계적으로 구조화  
   9. 루트 관리자 계정 초기화 개선  
      1. \`PasswordGenerator.java\` 삭제  
      2. \`data.sql\`에서 \`INSERT IGNORE\` 구문으로 변경하여 중복 생성 방지  
      3. 환경변수 설정 방식 체크. 차후 배포시 적용 예정.  
   10. 루트 관리자 계정 정상 생성 확인  
   11. jsp에서 한글 인코딩 로직 강화  
       1. application.properties에 인코딩 관련 설정 추가  
   12. 회원가입 API 작동 체크  
       1. 조정하면서 최종 작동 확인 완료  
   13. 로그인 API 작동 체크  
       1. 조정하면서 최종 작동 확인 완료  
   14. 로그인 기록 API 작동 체크  
       1. 작동을 안함. 체크하는 과정에서 보안 설정 중 로그인이 form 기반 로직으로 짜여진걸 확인. 차후 리액트 사용을 고려하여 REST API 기반 로직으로 재편.  
       2. 단편적으로는 작동하지 않는 원인이 찾아지지 않아, 관련 로직 흐름을 처음부터 뜯어가며 전면 검토. 스파게티 코드처럼 되어있던 상황이라 차근차근 풀어가며 정리. 로그인 기록 DB 테이블에 디바이스 타입 칼럼, 로그아웃 시간 칼럼 추가하여 보강.   
   15. 보안 설정 보강  
       1. 보안 설정에 HTTPS 강제 조건 추가  
   16. 깃허브 레포지토리 연결 테스트  
       1. 진행상황 히스토리를 위해 커서AI와 깃허브 연결하고 GUI 커밋 버튼으로 첫 커밋 시도  
       2. 8시간동안 커밋이 돌기만하고 완료가 안되서 강제 종료. 결국 터미널 명령어를 통해 커밋 및 업로드 완료  
   17. API 세팅  
       1. 알파버전 사용자 조회 API 세팅  
       2. 알파버전 사용자 일반정보 수정 API 세팅  
       3. 알파버전 사용자 비밀번호 수정 API 세팅  
       4. 알파버전 사용자 탈퇴 API 세팅  
   2. JWT 인증 구현  
      1. 인증 구조 설계(엑세스 토큰/리프레시 토큰 이원화)  
      2. 리프레시 토큰을 위한 Redis 도입(재사용을 막기위해 블랙리스트를 Redis로 관리)  
      3. gradle에 의존성 추가  
      4. JWT 인증 관련 상수 정의  
      5. JWT 생성과 검증에 관련된 클래스 구현  
      6. JWT 인증 필터 구현  
      7. Security 설정에 JWT 필터 추가  
   3. JWT 로직 추가  
      1. 로그인 API에 JWT 로직 추가  
      2. 사용자 일반정보 수정 API에 JWT 로직 추가  
      3. 사용자 비밀번호 수정 API에 JWT 로직 추가  
      4. 사용자 탈퇴 API에 JWT 로직 추가  
   4. JWT 인증 구조 개선  
      1. JWT 토큰에 role 정보 포함 구현  
      2. 액세스 토큰과 리프레시 토큰의 정보 분리  
      3. JwtAuthenticationFilter의 권한 처리 로직 보완  
      4. 토큰 만료 시 처리 로직 검토  
   5. 보안 관련 개선  
      1. SecurityConfig의 필터 체인 동작 방식 이해  
      2. JWT 인증 전/후 API 동작 흐름 정리  
      3. 사용자 권한 검증 로직 개선  
      4. 토큰 기반 인증 처리 구조 확립  
   6. 코드 구조 개선  
      1. 컨트롤러와 서비스의 역할 명확화  
      2. 비즈니스 로직 분리  
      3. 예외 처리 구조 개선  
      4. ResponseEntity를 활용한 응답 처리 표준화  
   7. API 응답 처리 개선  
      1. GET/POST 요청별 응답 형식 정리  
      2. 에러 응답 구조 표준화  
      3. HTTP 상태 코드 매핑 정리  
   8. 서비스 계층 설계  
      1. 반환 타입 기준 정립  
      2. 예외 처리 위치 결정  
      3. 트랜잭션 처리 검토  
   9. 스프링 부트 동작 체크  
      1. SecurityConfig와 JwtAuthenticationFilter에서 UserDao 직접 사용하는 걸로 순환참조 오류 해결  
      2. 토큰이 없는 요청도 permitAll 엔드포인트 접근 가능하도록 JwtSupport.extractToken()에 null 체크 추가  
      3. Tomcat SecureRandom 경고는 세션 관련으로, 개발환경에서만 발생하므로 미조치  
   10. 로그인 API 테스트  
       1. 응답 본문을 두 곳에서 작성하려고 하여 충돌 발생. 한 곳에서만 응답 본문을 작성하도록 수정.  
       2. 컨트롤러의 출력을 ResponseEntity로 통일  
       3. JWT 로직에 맞춰, DB의 로그인 기록 테이블에서 ‘로그아웃 시점’ 칼럼 삭제.  
   11. 로그아웃 API 테스트  
       1. 리프레시 토큰의 블랙리스트 체크 로직이 없어서 서비스 단계에 추가.  
       2. 비정상 조건(블랙리스트의 리프레시 토큰) 테스트에서 200 OK에 응답 body에 “1”만 출력되는 문제 발생. 로직 중간중간 로그 출력 세팅하여 확인.   
       3. 토큰 검증의 전체 흐름을 고려하여 블랙리스트 체크 로직을 서비스 단계에서 JWT 인증 필터 단계로 이동.  
       4. 비정상 조건(블랙리스트의 리프레시 토큰) 테스트 통과.  
       5. 비정상 조건(토큰 없음) 테스트에서 세팅하지 않은 403 Forbidden 응답 발생. 토큰이 없는 요청은 세팅된 예외 처리 로직까지 도달하지 못하고 Spring Security에서 먼저 차단되는 것이 원인. JWT 인증 필터 로직에서 로그아웃 API는 토큰이 없으면 보안 인증을 거치지 않도록 코드 추가.  
       6. 로그아웃 API 로직 전면 수정. 어떤 조건의 요청이 들어와도 리프레시 토큰을 블랙리스트에 추가하고, 응답 헤더에서 토큰을 제거하는 로직으로 정리. 이에 따라 JWT 인증 필터 로직에서 로그아웃 API에 대해서는 특별한 처리 없이 통과시키는 코드로 수정. 컨트롤러와 서비스도 코드 간소화.  
   12. 보안 로직 세팅  
       1. 스프링 시큐리티 차단처리 응답 세팅  
   13. API 테스트  
       1. 사용자 일반 정보 수정 API 테스트  
       2. DTO 구조 도입을 결정. DTO 폴더와 파일을 추가하고 컨트롤러 수정  
       3. DTO 도입으로 인한 Postman 요청방식과 프론트엔드 요청방식 체크  
       4. DTO 버전 로그인 API 테스트  
       5. DTO 버전 사용자 일반 정보 수정 API 테스트  
       6. DTO 버전 사용자 비밀번호 수정 API 테스트  
       7. DTO 버전 사용자 탈퇴 API 테스트  
       8. 삭제 처리된 사용자의 로그인이 가능한 문제가 발견되어 체크. 알고보니 로그인용 쿼리를 만들어놓고, 실제 로그인 로직에서는 유저검색용 쿼리만 쓰고 있었음. 유저검색용 쿼리를 보강하고 로그인용 쿼리 삭제.  
       9. DB와 매퍼의 칼럼명이 조금 다른데 정상작동하여 체크해보니, SQL은 snake\_case가 관례고 java는 camelCase가 관례인데 MyBatis에서는 기본적으로 이 차이를 자동으로 보정해주는 세팅이 되어있다고 함. 자동보정된다는 전제하에 코드 정리.  
       10. JWT 인증 로직 체크. 만료된 엑세스 토큰+정상 리프레시 토큰으로 사용자 정보 수정 API 요청 테스트. 200 OK 응답에 body “1”이 찍힘. 문제가 있음. JWT 필터 로직에 토큰 재발행해도 작업이 이어지도록 로직 수정.  
       11. 가볍게 로그인 API 테스트 중 갑자기 400 응답이 뜨는 문제 발생. 분석해보니 지난 작업에서 DB와 매퍼의 칼럼명 연결했던걸 지웠던게 원인이었음. 자동보정 세팅이어도 칼럼명에 따라 안먹힐수도 있어서, 다시 일일히 연결해주고 문제 해결.  
       12. JWT 인증 로직 체크. 정상 엑세스 토큰만 들어간 헤더로 사용자 정보 수정 API 요청 테스트. 정상 처리되는걸 확인. 정상 사용자라면 엑세스 토큰과 리프레시 토큰 모두 가지고 있어야하므로, 현재 작동 방식은 보안에 문제가 있을 수 있음. JWT 필터 로직에 리프레시 토큰이 없는 경우 접근을 차단하는 코드 추가. 이후 테스트에서 차단되는걸 확인.  
       13. 리프레시 토큰이 만료된 경우의 처리가 정해지지 않은 상태인걸 인지. JWT 필터 로직에 리프레시 토큰이 만료된 경우에는 접근을 차단하는 코드 추가. 이후 테스트에서 차단되는걸 확인.  
       14. 이전 작업 중에 ‘JWT 인증 필터 로직에서 로그아웃 API는 토큰이 없으면 보안 인증을 거치지 않도록 코드 추가’ 한 부분이 눈에 걸려서, 추가한 코드를 주석처리하고 로그아웃 API 테스트. 문제없었음. 아마 그 후에 로그아웃 API를 단순 일괄처리하는 로직으로 수정하면서 해결된 걸로 보임. 필요없어진 코드로 판별되어 삭제 처리.  
   14. 상품 관련 API 세팅  
       1. 상품 추가 API 제작. Mapper, VO, DAO, Service, DTO, Controller 세팅.  
       2. 상품 추가 API의 접근 권한을 관리자로 한정하고 싶어서 알아보니, 컨트롤러의 메서드 별로 권한 설정이 가능한걸 확인. 그런데 기존에 users 테이블 관련한 API들의 접근 권한을 설정할때는 보안 설정에서 url 기준으로 했던게 기억남. 더 확인해보니 기능적으로 차이가 있는건 아니고, 상황에 맞춰 취사 선택한다고 함. 기본적으로 모든 접근을 열어두고, 권한이 필요한 API에만 메서드 권한 설정을 하는 방식으로 최종 결정. 따라서 SecurityConfig에서 API를 url로 권한 설정한 코드를 삭제하고, 컨트롤러에서 메서드 별로 권한 재설정.  
       3. 보안 설정 변경 후 API 작동 테스트를 해보니, 로그아웃 API에서 인증기간 만료된 엑세스토큰+블랙리스트 리프레시토큰 첨부했을 경우에, 401응답 \+ {"error": "JWT Error",    "message": "권한이 없습니다."} 이 나오는걸 확인. JWT 필터에서 토큰 검증이 먼저 일어나서 발생하는 문제라서 예외처리 코드가 필요한데, 이건 이전 작업 중 필요없다고 생각해서 삭제한 코드임. 필요성이 다시 확인됐으니 다시 추가함.  
       4. 상품 정보 수정 API 제작. VO, DAO, Service, DTO, Controller 세팅.  
       5. 상품 등록 API 테스트를 하려다보니, 연동되어있는 카테고리 테이블을 먼저 정리해야하는 필요성이 발견됨. 카테고리 관련 API 먼저 구현하기로 함.  
       6. 카테고리 관련 API를 만드려다보니, 카테고리 전용 API 루트까지 만들어야하는지에 대한 고민이 됨. 현재 계획상으로는 카테고리 테이블은 상품 테이블의 단순 지원에 가까우므로, 상품 관련 API에 포함시키는걸로 결정.  
       7. 카테고리 입력 API 제작. product 루트에 VO, DAO, Service, DTO, Controller 세팅.  
       8. 카테고리 수정 API 제작. product 루트에 VO, DAO, Service, DTO, Controller 세팅.  
       9. 카테고리 테이블에 등록날짜와 수정날짜를 받는게 의미가 있는지 고민. 나중에 관리자 활동 로그 추적을 위해서는 있는게 맞겠다는 결론이 나와서 유지하기로 결정.  
       10. 카테고리 입력 API 요청 단계에서, 부모 카테고리 ID가 필요없는 경우가 존재한다는걸 인지. DTO 로직에서 특정 항목을 비워도 문제없을 방안을 체크. DTO 항목 기본 값을 Null로 지정하면 되는걸로 확인되어 그렇게 처리.  
       11. 카테고리 입력 API 요청 단계에서, 부모 카테고리 ID를 넣어야하는 경우에는 관리자가 외우고 다니지 않는이상 DB를 열어봐야하는 이슈를 인지. 따라서 카테고리 이름으로 다른 정보들을 불러오는 로직을 서비스 단계까지 만들어놓고, 카테고리 입력 API 요청 단계에서 부모 카테고리 이름을 넣으면 부모 카테고리 ID를 찾아서 넣어주는 방식으로 구현.  
       12. 관리자 계정으로 최상위 카테고리 입력 API 테스트. 404 오류가 나와서 검토해보니 컨트롤러에 ‘@RestController’가 아니라 ‘@Controller’가 붙어있어서 그런거였음. 수정하니 해결됨. 대신 카테고리 정상 추가가 되어야하는 요청인데 실패했다고 하여 확인해보니, 매퍼의 insert 쿼리에 칼럼을 맞추기위해 as를 써서 오류가 난 것. as 부분을 삭제하여 해결.  
       13. 일반 사용자 계정으로 최상위 카테고리 입력 API 테스트. 403 기본응답이 나오는데, 권한이 없다는 명확한 응답이 필요함. SecurityConfig에 accessDeniedHandler코드를 추가하여 해결.  
       14. 관리자 계정으로 하위 카테고리 입력 API 테스트. 지정한 부모 카테고리가 연결되지 않은채로 DB에 들어가는 문제 발생. 분석해보니 매퍼에서 전체값을 가져오기위해 SELECT \*을 썼는데, 여기서 칼럼명과 필드명의 불일치가 발생했던 것. \* 대신 명시적 지정 방식으로 바꾼 후 문제 해결.  
       15. 카테고리 관련 API 테스트를 하다보니 테이블 칼럼이 id, name, parent\_category\_id 이렇게 3개만 있어서는 name의 중복 이슈(ex. 남성\>상의 & 여성\>상의)가 발생할 것임을 인지. 개선을 위해 code 칼럼 추가 결정.  
       16. 만료된 엑세스 토큰 \+ 정상 리프레시 토큰의 관리자 계정으로 카테고리 등록 API를 테스트 했을때 토큰 세트를 재발급하고 정상 처리되어야하는데, 실제로는 토큰 세트를 재발급하고 실패 처리되는 문제 발생. 인증 로직 쪽의 문제인가 싶어서 한참을 파보고 다듬고 해봤는데 디버그 모드로 추적해보니 인증 로직쪽 문제는 아닌걸로 확인됨. API 로직 쪽 문제인걸로 보여서 파보니, 테이블에 code를 추가한 후 서비스 단계에서 code를 카테고리 클래스에 안담고 있었음. 코드 수정 후 정상 작동 확인.  
       17. code를 추가한 이유가 고유한 속성을 담을 수 있는 칼럼이 필요한 것이었으니, 부모 카테고리 ID를 검색하는 키워드를 code로 수정해야 함을 인지. 기존에 name으로 세팅했던 키워드를 code로 수정.  
       18. 정상 관리자 계정으로 카테고리 등록 API 테스트. 최상위 카테고리 정상 추가 확인. 하위 카테고리 정상 추가됨 확인. 상위 카테고리를 잘못 지정한 경우에 전용 에러 메세지가 나와야하는데 안나옴. 컨트롤러 로직에 허점이 있는게 원인이라 수정 후 정상적으로 전용 에러 메세지가 나오는걸 확인.  
       19. 만들었던 카테고리 수정 API를, 현재까지의 로직 변경 내용에 맞춰 수정.  
       20. 카테고리 수정 API 테스트. 정상 요청, 수정할 code가 제대로 지정되지 않았을 경우, 수정할 부모 카테고리 코드가 제대로 지정되지 않았을 경우 모두 문제없도록 조정 완료.  
   15. 상품 관련 API 세팅  
       1. DTO를 도입한 것에 맞춰 상품 등록 API와 상품 수정 API 코드 수정  
       2. products와 categories의 테이블 칼럼 세팅이 최선인지 점검. 특히 카테고리 테이블에 code 칼럼이 추가되면서 카테고리ID의 존재의미가 있는지 고민. 일단 연산 처리 측면, 실질적인 데이터 관리는 관리자 전용 페이지에서 하는 측면 등등에서 의미가 있다는 판단하에 카테고리ID 유지 결정. code도 url라우팅이나 문자기반 로직처리 등에 의미가 있으므로 유지 결정.  
       3. 카테고리ID와 code의 존재의의를 정리했기 때문에, 기존에 API에서 조회할때 code 기준으로 세팅했던걸 카테고리ID로 수정.  
       4. 상품 등록 API 테스트. 정상 조건에서 정상 등록 확인. 존재하지 않는 카테고리ID 조건에서 세팅된 오류 출력 확인. 일반 사용자 계정은 접근 불가 출력 확인.  
       5. 상품 수정 API에 활성화 칼럼과 삭제 칼럼 항목이 빠져있는걸 확인하여 추가함.  
       6. 상품 수정 API 테스트. DTO에 안들어간 정보는 기존 정보에서 채우는 로직을 세팅했었는데, 어차피 프론트엔드에서 채워서 보내는 상황일거라 불필요한 로직이라는 결론. 로직 수정. 정상 조건에서 정상 처리 확인. 예외 조건에서 예외 처리 확인.  
       7. 상품 조회 API 세팅. DTO가 포함된 구성에서는 GET으로 받을때 DTO 형태로 JSON 포장해서 받는게 자연스럽다는걸 알게됨.  
   16. 사용자 관련 API 세팅  
       1. 상품 관련 API 세팅을 하면서 DTO는 값이 없는 항목에 null을 만들지 않는다는걸 알게되어, 중복되는 DTO는 가장 크게 포괄하는 하나의 DTO로 만들면 된다는걸 깨달음. 따라서 이전에 가입용DTO, 로그인용DTO 등등 여러가지로 쪼개져있던걸 합치는 작업 진행. 다만 비밀번호 변경은 현재 비밀번호와 바꿀 비밀번호를 둘 다 받아야하니, 그것만 놔둠.  
       2. 배웠던대로 컨트롤러에서 User 클래스 포장하는 로직이었는데, DTO를 도입하면서 그럴 필요가 없어진걸 깨달음. 어차피 비즈니스 로직에 가까워서 불편했는데 컨트롤러로 옮김.  
   17. 상품 관련 API 세팅  
       1. 기존 상품 조회 API는 단일 상품 조회 기능인데, 프론트엔드에서 카테고리 기준으로 불러와서 늘어놓으려면 여러 상품을 페이지네이션으로 불러오는 API도 있어야하는걸 인지. 기존 상품 조회 API는 단일 상품 조회 API로 재명명하고 카테고리별 상품 조회 API 제작 결정.  
       2. 카테고리별 상품 조회 API 제작. 카테고리ID 기준으로 가져와서 페이지네이션 적용(배웠던 거랑 다르지만 LIMIT OFFSET 세팅). 전용 DTO 세팅.  
       3. 단일 상품 조회 API 테스트. GET으로 받을때는 ResponseEntity로 body 출력을 해야한다는걸 깜박한걸 확인. 수정 후 받아지긴하는데 isActice와 isDeleted 항목에 null이 들어오는 문제 확인. 알고보니 매퍼에서 받는 코드를 안넣은거라 추가하는걸로 문제 해결.  
   18. 주문 관련 API 세팅  
       1. 주문 접수 API 제작. Mapper, VO, DAO, Service, DTO, Controller 세팅.  
       2. orders 테이블을 다시 검토해보니, 부족한 부분이 보임. 수령자 정보가 다를 수 있으니 별도로 담아야하고, 주문 취소 사유, 배송 출발/도착 날짜, 운송장 번호, 배송비 유무 등의 칼럼 추가가 필요한 걸로 사료됨. 이에따라 DB에 칼럼 대거 보강.  
       3. orders 테이블에 칼럼이 대거 추가됨에 따라, VO와 DTO 정리.  
       4. orders 테이블 칼럼에 enums가 두 항목 있어서 관련 파일을 추가하려고보니, 기존에 관련 로직이 constant 명명을 기준으로 폴더와 파일을 정리되어 있었는데 부적절하게 느껴짐. enums 명명을 기준으로 재정리.  
   21. 주문 관련 API 세팅  
       1. 주문 접수 API를 만드려다보니, orders 테이블과 order\_items 테이블을 하나의 API에 연동시켜야한다는 걸 깨달음. 어떻게 해야 되는건지 찾아보고 정리. 주문 상품 DTO를 리스트로 포함하는 주문 접수 DTO를 만들고, 컨트롤러에서 유효한지 검토 후 orders 테이블에 먼저 저장하여 order\_id를 받아오고, 받아온 order\_id를 토대로 주문 상품 정보를 테이블에 저장하고 주문량만큼 재고감소처리하는 방식으로 구현. SQL에서 INSERT 결과로 특정 값을 반환받을 수 있다는걸 처음 알게됨.   
       2. ENUM 세팅에 대해 체크. DB에서 대소문자를 구별하는지에 대해 궁금한 점이 있었는데, 구별을 해야하며 상수의 경우 관례상 대문자로 쓰는게 정석이라고 함. 기존에 소문자로 세팅되어 있던 ENUM 내용을 대문자로 변경.  
       3. 주문 접수 API 테스트. HeidiSQL에서 orders 테이블의 status 칼럼 기본값을 PENDING으로 하고 API 요청에 status를 비우는 방식이었는데, 실제로는 NULL이 들어가는 문제 확인. 매퍼에서 status를 받도록 세팅한게 문제였는데, 이런 로직은 백엔드에서 코드로 확인할 수 있게 만드는게 정석이라고 하여 백엔드에 값을 지정하는 방식으로 변경. 문제 해결.  
       4. 주문 접수 API 테스트. 주문 총합 가격에 배송비값이 반영되지 않는 문제 발견. 해당 로직 추가하여 문제 해결.  
       5. 주문 접수 API 테스트. 없는 유저id로 예외처리 확인해보니 SQL 오류가 본문에 붙어나옴. 서비스 단계에서 유저 id로 체크하는 로직에 문제가 있었던거라 수정하는데, DB에서 유저 정보를 불러올때 이메일을 기준으로 API를 짰었어서 주문접수DTO의 유저id 정보만으로는 제대로 수정이 안되는 상황. 이전 API들을 세팅할때 유저 이메일을 기준으로 했던 이유가 토큰에 담은 정보를 활용할 수 있기 때문인걸 기억하고, 주문접수DTO의 유저id를 삭제하고 서비스 단계에서 토큰의 이메일 정보를 뽑아와서 유저 정보를 조회하는 로직으로 변경. 이것으로, 없는 유저id로 예외처리 정상 출력 클리어.  
       6. 앞선 수정에서 컨트롤러에서 서비스로 토큰 정보를 넘기지 않고, 서비스에서 바로 토큰 정보를 추출하는 방안을 적용한 뒤에 가만히 생각해보니… User 관련 API 세팅할 때 서비스에서 토큰 정보를 활용하기 위해 컨트롤러에서 response와 request를 서비스로 넘겨줬던게 기억남. 그렇다면 전에 잘 모르는 상태에서 짠 아이디어가 비효율적이거나 잘못된 방법일 가능성이 있겠다는 생각이 들어서, User API들을 전면 재검토 함. 역시 내 생각대로 서비스 단계에서 response와 request를 받는건 좋은 설계가 아니었음. HTTP 요청/응답 처리는 컨트롤러에서 처리하는게 맞는 설계이기 때문에, 만일 서비스에서 필요한 response나 request 정보가 있다면 아예 컨트롤러에서 변수 같은걸로 담아서 정리해 넘기는게 더 적절한 설계라고 함. 이에 맞춰 로그인 API와 로그아웃 API를 전면 수정하고, 관련된 다른 파일의 코드들을 추적하여 정리. 로그인과 로그아웃 테스트를 진행해서 정상 작동 확인.  
       7. 회원 주문 내역 조회 API 세팅. 처음에는 생각없이 orders 테이블의 내역을 불러오는 로직을 기계적으로 짜다가, order\_items 테이블의 내역도 같이 끌어와야한다는걸 깨달음. 따라서 해당 조회로 받아올 DTO 구조를 새로 짜고, 매퍼에서 3개의 테이블(orders, order\_items, products)을 JOIN하여 DTO에 채울 정보들을 받아오는 로직을 짬. 문제는 최종적으로 프론트엔드에서 받게되는 DTO가 복합 DTO 구조다보니, 매퍼에서 resultType이 아닌 resultMap을 반환해야하는데 이건 배운적 없는 내용임. 일단 resultMap을 추가 선언해주기만 하면 되긴해서 설계하는건 문제없었는데, resultMap의 Type을 넣는데서 골치아픈 문제가 생김. 왜냐하면 나는 같은 카테고리의 DTO들을 하나의 파일로 관리하고 싶어서 하나의 DTO에 여러개의 내부 클래스를 만들어놨는데, 매퍼의 MyBatis가 내부 클래스를 구분하지 못해서 추가 설정(Type Aliases)을 해야한다고 함. 그래서 관련된 MyBatis 설정 파일을 추가한다던가 application.properties 코드를 추가한다던가하면서 이리저리 만져봤는데, DTO 내부 클래스를 인식하지 못해서 스프링부트도 먹통이되거나 기존에 잘되던 User매퍼 기능이 마비되는 등 쉽게 해결이 안됐음. 결국 MyBatis 설정을 건드리지 않고 type에 DTO의 전체 경로를 넣는 방식(type="com.my.gyp\_portfolio\_shoppingmall.dto.OrderDto$UserOrderHistory")으로 간신히 해결.  
   22. 상품 관련 API 세팅  
       1. 앞선 작업에서 products 테이블을 다시 검토하게 됐는데, 제품 사이즈라던지 뭔가 들어있어야할 정보가 좀 누락된 느낌이 있었음. 추가해야할 칼럼이 있는지 재검토 후 discount\_rate, size, color, view\_count, sales\_count 칼럼 추가. 그리고 price가 int로 세팅되어있어서 decimal로 변경. 칼럼 변경으로 인한 연관된 코드들을 수정.  
   23. 주문 관련 API 세팅  
       1. 단일 주문 내역 조회 API 세팅. 직전에 만든 회원 주문 내역 리스트 API가 OrderDto.UserOrderHistory 리스트를 반환하니까, 단일 OrderDto.UserOrderHistory를 받아오게 하면 된다고 생각했지만… 문제는 회원 주문 내역 리스트 API의 요청값은 userId이고 단일 주문 내역 조회 API의 요청값은 orderId라서 코드 재활용이 안됨. 해결법을 찾아보니 공통으로 쓰이는 sql 코드만 따로 포장이 가능해서, 포장된 코드를 끌어와서 검색 기준만 다르게 잡는 방법이 존재. 해당 방법으로 매퍼를 정리하고, 나머지 로직 세팅.  
       2. 관리자용 전체 주문 목록 조회 API 세팅. 필터링, 정렬, 페이징이 적용되어야 해서 공부가 필요했음. 매퍼에 조건식을 거는게 가능해서 조회 키워드가 되는 값이 뭔지 확인해서 검색하게하고, 정렬조건이 확인되면 적용하고, 지정된 페이지만큼 가져오도록 로직을 짬. 요청에 필요한 값들이 정리되었으므로, 요청용 DTO 제작. 요청용 DTO가 API에 넘겨지면 반환용 DTO가 받아지도록 세팅.  
       3. 로직 수정한 부분에 대한 작동 체크와 후속 API 테스트를 위한 주문 테이블을 채워해야서, 주문 접수 API 테스트 진행. 매퍼 에러가 출력됐는데 원인은 order\_items 테이블에 칼럼이 추가된게 NewOrderItemDTO에 반영이 안되서였음. 관련 내용 수정 후 정상 작동 확인.  
       4. 회원 주문 내역 리스트 조회 API 테스트. 매퍼 에러가 출력됐는데 원인은 매퍼에 커스텀 Map이 추가됐지만 그걸 담는 DTO가 최신화 안되었기 때문. 관련 내용 수정 후 정상 작동 확인.  
       5. 회원 단일 주문 내역 조회 API 테스트. 다른 회원의 주문조회도 가능한 문제가 발견되어, 주문한 회원과 조회하는 회원의 정보가 일치하는지 검사하는 로직 추가. 정상 작동 확인.  
       6. 관리자용 전체 주문 목록 조회 API 테스트. limit로 불러오려는 주문 수 보다 적게 불러와지는 문제 발생. 분석해보니 order \+ orderItem이 같이 불려와지면서 order가 카운트 기준이 되는게 아니라 orderItem이 카운트 기준이 되어버리기 때문이었음. 어떻게 해야 깔끔하게 해결할수 있을지 이런저런 시도를 하다가, 로직 흐름상 orderItem이 불려오기 전에 order를 먼저 선정한 후 그 다음에 연결되는 orderItem을 불러오면 된다는 아이디어에 도달. 따라서 orderHistorySelect SQL 세트에서 JOIN에 해당하는 부분만 따로 분리하여 2개의 SQL 세트로 쪼개고, order 테이블만을 가지고 필터 로직을 수행한 후 JOIN 코드를 적용시키는 흐름으로 변경. orderHistorySelect SQL 세트를 쪼갰으니 연관된 다른 코드들도 수정. 관리자용 전체 주문 목록 조회 API가 정상 작동하는걸 확인했고, 연관된 코드들이 수정되면서 회원 주문 목록 조회 API와 회원 단일 주문 내역 조회 API도 다시 테스트하여 정상 작동 확인.  
       7. 관리자용 주문 정보 업데이트 API 세팅. 관리자가 변경할 여지가 있는 칼럼들을 수정하는 로직. 테스트로 정상 작동 확인.  
       8. 이런저런 테스트를 하다보니까 DB 세팅에 몇가지 문제가 발견됨. invoice\_number 같은 경우 숫자가 들어갈거라 생각해서 INT 형으로 설정했는데, 직접 숫자를 넣어보니 천의 자리에 ,가 들어가면서 이상해짐. 전화번호와 마찬가지로 VARCHAR 형 설정으로 변경. 그리고 INT 형의 ‘길이/설정’ 값은 실제 자리수와는 전혀 관계없다는걸 이번에 처음 알게됨. 0으로 채워지는 공간을 명시하는 느낌인데, 그냥 기본값(11)로 두면 된다고 함.  
       9. 시간 관련 DB 데이터형을 DATE로 할지 DATETIME으로 할지에 대해 고민. 날짜까지만 기록하는 것보다 시분초까지 기록하는 DATETIME으로 기록하는게 일반적이라고 하여 DATETIME으로 수정.  
       10. 주문 취소 요청 API 세팅을 하려고보니, 주문 테이블에만 상태 칼럼이 있어서 주문 상품별로는 취소나 환불 요청을 할 수 있는 구조가 아닌걸 인지. 일반적으로 주문 개별 상품의 취소나 환불 요청이 있는걸 감안하면 칼럼의 추가와 변경이 필요한 상황. 어떻게 수정할지 디자인 후, order\_items 테이블에 status 칼럼 추가하고 enum 세팅하고 orders 테이블의 status 칼럼의 enum 세팅 수정.  
       11. 이제부터 본격적으로 orderItems 테이블에 직결되는 로직의 API를 만들어야하는데, orders 테이블과 orderItems 테이블이 부모-자식 관계구조를 가지고 있다보니 API 흐름을 어떻게 정리하는게 좋을지 재검토. 최종적으로는 VO, mapper까지는 분리하고 이후 단계는 하나로 통합하는 안으로 결정. 여기에 맞춰 기존 코드 수정.  
       12. 회원 주문 상품 취소/반품/교환 API 세팅. 원래는 취소, 반품, 교환을 각각 만들어야하나 싶었는데 로직을 짜다보니 합쳐도 문제없을거 같다는 결론이 나와서 합침. 주문자가 원하는 요청이 들어오면 ‘주문자 일치여부 확인\>처리 상태에 따른 필터링\>요청 업데이트\>해당 주문 상태 업데이트’가 되는 로직. orderItemId로 orderItem 정보 불러오는 로직이 자꾸 실패해서 곤란했는데, 알고보니 매퍼에서 ‘SELECT \*’ 대신에 전부 명시해주는걸로 해결. 전에도 비슷한 문제가 있었는데 까먹고 다시 고생함. 테스트로 예외처리와 정상작동 확인.  
       13. 회원 주문 상품 취소/반품/교환 API 초안을 만들어놓고 일부만 취소/반품/교환하는 시뮬레이션을 하다보니, 같은 상품 2개를 주문했다가 1개만 취소/반품/교환 하는 경우에 어떤 시리얼의 상품을 처리하는지에 대한 정보를 반영할 수 없다는 점을 깨달음. 시리얼 정보를 보관하는 로직이 추가되어야하고, 이에 따라 상품 입출입 기록도 존재해야한다는걸 인지. 더 완성도 있는 로직을 위해서는 테이블 2개(개별 상품 테이블, 재고 이력 테이블)가 필요한걸로 보이는데, 어떻게 하는게 좋을지 깊게 고민.  
       14. 일단 더 높은 완성도를 위해 테이블 2개(개별 상품 테이블, 재고 이력 테이블) 추가 결정. 개별 상품 정보를 담는 product\_items 테이블과 재고 이력 정보를 담는 inventory\_history 테이블을 디자인하고 추가.  
   24. 상품 관련 API 세팅  
       1. product 계열의 테이블이 두 개 추가되면서, product 계열 API의 대폭 수정이 필요한 상황. 새로운 테이블들의 VO, 매퍼를 만들고 API 로직 수정 작업 돌입.  
       2. 기존 상품 추가 API는 상품 마스터 등록 API로 변경. 등록시 재고가 0으로 고정입력되게 수정.  
       3. 개별 상품 입고 API 세팅. productItemDTO를 받으면 ‘해당 상품 마스터 존재 체크 \> 바코드 중복 체크 \> 시리얼 번호 생성 \> 개별 상품 정보 등록 \> 상품 마스터 재고 1 증가 \> 재고 변동 이력 등록’ 흐름의 로직 처리.  
       4. 대량 상품 입고 API 세팅. productId와 바코드 리스트를 받아서 개별 상품 입고 API 루프를 돌리는 로직을 통해 하나의 상품의 대량 입고가 가능.  
       5. productItems 테이블의 칼럼 중 시뮬레이션 해봤을때 애매한 칼럼들 정리. 일단 createdAt 칼럼과 의미가 중복되는 insertedDate 칼럼 제거. 반품된 경우 혼동을 주는 soldDate 칼럼 제거. status 칼럼의 ENUM 세팅이 ‘IN\_STOCK’,’SOLD’,’DEFECTIVE’,’RETURNED’,’IN\_TRANSIT’ 이거였는데 관리하기에 번잡하다는 생각이 들어, 'IN\_STOCK','RESERVED','OUT\_OF\_STOCK','DEFECTIVE' 이걸로 변경. 이에따라 inventory\_histories 테이블의 관련 ENUM도 같이 변경.  
       6. product\_items 테이블이 추가되면서, 기존의 order\_items 테이블의 직관성이 떨어진다고 느끼게 됨. 실제로는 ‘주문된 product의 정보’를 담고있지만, 직관적으로는 ‘주문된 product item의 정보’를 담는다고 오해하기 쉬워짐. 따라서 order\_items 테이블명을 order\_products로 바꾸고, 연관된 모든 코드들을 수정.  
       7. productItems 테이블이 생기면서, 주문 관련 API의 로직을 다시 뜯어고쳐야하는 상황. 일단 주문 접수 API의 서비스 단계에서 주문한 상품 마스터 정보 저장할 때, ‘주문하는 상품 마스터의 개수만큼 productItemId 앞번호부터 상태를 예약으로 변경\>재고 변동 이력 저장’ 로직을 추가. 테스트는 못해봄.   
   25. 주문 관련 API 세팅  
       1. 관리자용 결제 완료 업데이트 API 세팅. 로직은 ‘orderId 받음\>주문 존재 여부 확인\>현재 주문 상태가 PAYMENT\_PENDING인 경우에만 통과\>주문 내역 상태를 PREPARING으로 업데이트\>주문 내역 개별 상품 내역을 PREPARING으로 업데이트’로 정리.  
       2. 관리자용 배송중 업데이트 API 세팅. 로직은 ‘orderId 받음\>주문 존재여부 확인\>현재 주문 상태가 PREPARING인 경우에만 통과\>주문 내역 상태를 SHIPPING으로 업데이트\>주문 내역 개별 상품 내역을 SHIPPING으로 업데이트\>개별 상품 재고 변동이력 저장’으로 정리.  
       3. 관리자용 배송완료 업데이트 API 세팅. 로직은 ‘orderId 받음\>주문 존재여부 확인\>현재 주문 상태가 SHIPPING인 경우에만 통과\>주문 내역 상태를 DELIVERED으로 업데이트\>주문 내역 개별 상품 내역을 DELIVERED으로 업데이트\>개별 상품 재고 변동이력 저장’으로 정리.  
       4. 배송중 업데이트 API에 송장번호 정보 등을 등록하는 로직이 빠져있어서 넣으려고보니 문제를 발견. 처음 테이블 디자인할때 주문 단위로 배송한다고 가정했었어서 orders 테이블에만 송장번호 칼럼을 만들었는데, 이후에 부분 배송 등을 고려하여 orderProducts 테이블을 만들고나서 이에 따른 최신화가 안된 상황. 송장번호 칼럼과 배송시작/완료 시간 칼럼을 orders 테이블에서 orderProducts 테이블로 옮기고, 관련 코드 수정.  
       5. 직전에 만든 업데이트용 API에 송장번호와 배송시작/완료 날짜 등록 로직을 추가…. 하려고 보니 실수로 로직을 다루는 기본단위가 주문 개별 상품이 아니라 주문 마스터를 기준으로 만들어버렸다는걸 인지. 관리자 업데이트용 API가 order 정보가 아니라 orderProduct 정보를 리스트로 받아 처리하는 로직으로 변경.  
       6. 앞선 작업 이후, 원래 목표인 업데이트용 API에 송장번호와 배송시작/완료 날짜 등록 로직을 추가. 배송중&배송완료 업데이트 API가 받는 DTO를 새로 만듦. 이 DTO에는 ‘주문 상품 리스트와 송장번호, 배송시작/완료 날짜’가 들어감.  
       7. 관리자 업데이트용 API를 검토하다보니 문득 orders 테이블에 status가 필요없어진게 아닐까 생각이 듦. 왜냐하면 이제 orderProducts 테이블에서 개별 주문 상품에 대한 status를 저장하는걸로 바뀌었으니, 기능적으로도 중복이 된 상태고 갱신을 위한 백엔드 로직이 과하게 복잡해지기 때문. 따라서 orders 테이블의 status 칼럼은 삭제하고, 관련 코드 일괄 수정. 만일 관리자가 주문 전체 상태를 확인해야할때는 프론트엔드의 관리자 페이지에서 정리해서 띄울 예정.  
       8. 주문 관련 정보 조회 API들 만들어놨던걸 다시 보니, orderProducts 테이블이 생기면서 다 뜯어고쳐야하는 상황. 특히 회원 본인 주문 내역 조회 API의 경우, 기존에는 ‘특정 order 정보 \+ 해당 order의 product 정보’가 담긴 DTO를 반환했는데 이제는 그럴 필요가 없어졌음. 어떻게 뜯어 고칠지 디자인.  
       9. 회원 본인 주문 내역 리스트 조회 API 수정. 로직은 ‘토큰 정보로 회원 존재 여부 확인\>해당 회원의 주문 내역 조회해서 불러옴\>프론트엔드에서 필요할 것으로 예상되는 정보만 추린 전용 DTO에 포장\>프론트엔드로 DTO 보냄’으로 정리.  
       10. 단일 주문 마스터 조회 API 수정. 로직은 ‘관리자&주문 회원 여부 확인\>주문 상품 조회해서 불러옴\>주문 상품 존재 여부 확인\>DTO로 포장해서 프론트엔드로 보냄’으로 정리.  
       11. API 수정 작업 하다보니, 프론트엔드와 백엔드끼리 정보를 주고 받을 때는 DTO로 통일하는게 정석이면서 여러 이점이 있다는걸 확인. 주문 관련 API에서 VO 클래스로 받던게 있으면 DTO로 전부 수정.  
       12. 관리자 전체 주문 상품 리스트 조회(검색조건 포함) API 수정. 로직은 ‘검색 조건을 담을 수 있는 DTO를 받음\>조건에 해당하는 orderProduct 리스트가 조회됨\>주문 상품의 정보를 담는 DTO에 포장해서 프론트엔드로 보냄’으로 정리.  
       13. 관리자용 주문 정보 업데이트 API를 마스터 배송 정보 업데이트 API로 수정. orders 테이블 칼럼이 정리됨에따라 배송정보(이름/주소/전화번호) 변경 요청이 들어왔을때만 처리하는 API가 됨.  
       14. 대거 수정이 있다보니, orderDao와 orderMapper를 전면 검토하여 적절히 수정하거나 안쓰는 코드를 삭제하는 작업 진행.  
       15. 관리자용 주문 취소 요청 승인 API 세팅. 로직은 ‘orderProductInfoDTO 받음\>주문 상품 존재여부 확인\>주문 상품 상태 확인\>주문 상품 상태를 취소로 변경\>개별 상품 업데이트(상태를 재고로 변경\>해당 상품 마스터 재고 증가\>재고 변동 이력 등록)’으로 정리.  
       16. 직전 작업하면서 Product 계열 코드 이상한 부분 대거 수정.  
       17. 교환 쪽 API를 짜다보니, 현재 구조의 한계가 명확하게 느껴짐. 특히 주문을 받으면 주문 상품 수량만큼 입고 빠른순으로 ‘예약’상태를 걸어놓는 로직이 너무 경직된 방식이라 특정 회원이 여러번 교체하는 상황을 시뮬레이션 했을때 문제가 안생기게 하려면 골치가 아파짐. 그냥 products 테이블에 ‘예약 수량’ 칼럼을 추가해서 주문 수량만큼 예약을 걸어놓고, 관리자가 배송할때는 자유롭게 상품을 골라서 보내고 ‘재고 수량’ \- ‘예약 수량’으로 처리하는게 나을거 같음.  
       18. 지난 작업에서 정리된 내용대로 DB 칼럼 정리하고, 관련 API 전부 수정.  
   26. 상품 관련 API 세팅  
       1. API들을 검토하다보니, 현재 상품 DB 쪽에 문제가 있는걸 알아챔. products 테이블은 상품 마스터, product\_items 테이블은 개발 상품에 대한 정보를 담는 구조인데, products 테이블의 칼럼에는 size와 color가 있으니까 하나의 상품에 상품 마스터의 id는 여러개가 있게 될 것임. 나중에 프론트엔드에 상품 페이지를 만들게되면 해당 url에는 하나의 상품 마스터만 연결되는게 자연스러운데, 지금 구조로는 그게 불가능함. 게다가 특정 상품 페이지에 접근하는 통계를 저장하기위한 view\_count칼럼도 products 테이블에 있는데, 하나의 상품 마스터가 하나의 url과 매칭되지 않는다면 view\_count 관련 로직도 연결할 수 없음. 해결 방안은 결국 테이블을 하나 추가하면서 구조를 다시 정리해야하는 방법 밖에 없음.  
       2. product\_inventories 테이블을 추가하여, products 테이블은 상품 마스터 정보를, product\_items 테이블은 상품 품목 정보를, product\_inventories 테이블은 상품 품목 재고 정보를 담당하는 구조로 재편.  
       3. 위의 테이블 추가 및 조정으로 인해 관련 API 전면 수정이 불가피하게 되었음. 작업량이 많긴한데, 전면 검토하면서 다 뜯어고침. 원래라면 어디를 어떻게 고쳤는지 기록했어야 하는데… 수정 분량이 너무 많아서 일일히 기록이 불가능해 포기.  
   27. 주문 관련 API 세팅  
       1. 직전에 테이블 구조 변경으로 인해 다 뜯어고치는 작업에서 주문 관련 API도 연결되어 있었음. 역시 수정 분량이 너무 많아서 기록 포기.  
   28. 리뷰 관련 API 세팅  
       1. 리뷰 등록 API 세팅. 회원의 주문 내역이 존재하는 상품인지 확인하는 로직이 필요한데, DB 테이블 4개를 엮어야해서 막혔었음. 방법을 알아낸 다음 완료. ‘로큰에서 유저 정보 조회\>해당 유저 존재여부 확인\>회원의 주문 내역이 존재하는 상품인지 확인\>리뷰 등록’ 순서로 정리.  
       2. 리뷰 수정 API 세팅. ‘토큰에서 유저 정보 조회\>리뷰 존재여부 확인\>리뷰 작성자 본인여부 확인\>리뷰 수정’ 순서로 정리.  
       3. 리뷰 리스트 조회 API 세팅. ‘검색 조건 HashMap으로 정리\>리뷰 리스트 조회’ 순서로 정리.  
       4. 리뷰 삭제 API 세팅. ‘토큰에서 유저 정보 조회\>리뷰 존재 여부 확인\>리뷰 작성자 본인 여부 확인\>리뷰 삭제’ 순서로 정리.  
   29. 유저 관련 API 검토  
       1. 가장 처음 만든 API 세팅인 유저 관련 API들에 문제점이나 비효율적인 부분이 없는지 확인.  
       2. DTO를 본격적으로 쓰기 전이라, DTO가 필요해보이는 부분에 추가.  
       3. 로그인 API의 컨트롤러 단계에서 서비스 코드 2개를 조건에 따라 불러오는 로직이 마음에 안듦. 로그인 자체 로직과 로그인 기록을 DB에 저장하는 로직을 서비스 단계에서 따로 만들었기 때문에, 미숙했던 예전에는 그냥 아무 생각없이 컨트롤러 단계에서 서비스 코드 2개를 불러온거. 테스트했었을때 문제없이 작동할만큼은 구현하기도 했었고. 분석해보니 크게 수정 안하더라도 뒤에 따라오는 로직을 private로 바꿔서 이어붙이는게 가능한 상황이라, 그렇게 수정해 봄.  
       4. 서비스 단계의 로그인 기록 저장 로직에서, 모종의 이유로 비동기 저장이 실패했을 경우 DB에 아무 기록도 저장 안되고 넘어갈 수 있는 허점을 발견. 어떻게할지 고민하다가 서버 내부에 로그파일로 저장하는 방안이 제일 무난하다고 판단하여, 그렇게 구현해 봄. 문제는 이런 특이상황을 어떻게 테스트하느냐인데, @MockBean을 통해서 가능하다고는 함.   
       5. 비밀번호를 잃어버린 회원의 비밀번호 재설정 로직이 있으면 더 완성도 높아 지겠다고 생각함. 겪어본 웹 서비스에 비춰보면 이메일로 재설정 링크를 보내주는 방법이 떠오르는데, 구현 가능한지 검토. 메일을 보내는 로직의 컴포넌트(@Componant) 파일을 만들고, application.properties에 Gmail SMTP 설정을 하면 되는걸로 확인되어 일단 구현 시도 시작. javaMailSender 기능을 불러와야하는데 이전 코딩에서 javax 관련 임포트가 안되던게 떠올라서 우회방법을 찾다가, 결국 할줄 알아야되긴 하는 부분이라 도전. 민감한 정보는 환경설정으로 세팅하면서 일단 코딩은 완성. 비밀번호 재설정 API 세팅 완료.  
       6. 로그인 API 수정한거랑 비밀번호 재설정 API 세팅한걸 테스트해야해서 프로젝트 디버그 모드 실행 시도. 하지만 매퍼에 잘못된 코드가 많아서 프로젝트 실행이 안되어, 오류 로그 하나하나 찾아보며 수정.   
       7. 매퍼쪽 수정이 끝났지만 우려했던대로 javax.mail 임포트를 인식못해서 프로젝트 실행이 안되는 문제 발생. 빌드그래들에서 의존성 주입 이슈인걸로 보여서 의존성 주입 코드를 이리저리 만져봤는데, 여전히 해결이 안됨. 그래서 그래들 의존성 트리 출력해서 확인해서 충돌이나 이상한 점이 있는지까지 체크. 스프링부트메일 의존성만 넣으면 jakarta.mail이 들어가는걸 확인해서, jakarta는 빼고 javax를 명시하는 의존성 코드까지 세팅했으나 여전히 해결이 안됨. 해결이 무조건 되는게 맞는 상황인데도 인식을 못해서 이클립스도 다시 켜보고 갖은 난리를 치다가, 이것저것 만져보면서 커서AI 껏다켰다를 엄청 하는 와중에 특별한 코드 변경없이 불현듯 해결됨. 아마 캐시문제였던거 같기도 한데 정확한 원인은 모른채 해결된 상태.  
       8. 코드 수정한 로그인 API 테스트. JWT 발행은 문제없는데 로그인 실패시 로그인 기록 테이블에 2개씩(하나는 직접 지정한 예외, 다른 하나는 미지정 예외) 들어가는걸 확인. 분석해보니 서비스 단계에서 예외상황에 throw 시키면 컨트롤러에서 예외상황이 상위 클래스인 Exception에 다시 잡히면서 두번 기록되던 것. 서비스 단계에서 특정 예외일때 컨트롤러에서 하나로 인식하도록 catch로 명시해서 던지게 수정. 정상 작동 확인.  
   30. API 작동 테스트  
       1. API 세팅이 기본적으로 정리되어, 미뤄놨던 테스트를 진행.  
   31. User 관련 API 테스트  
       1. 회원가입 API 테스트 진행. 오류나면 찾아서 수정하고, 최종 정상작동 확인.  
       2. 로그인 API 테스트 진행. 오류나면 찾아서 수정하고, 최종 정상작동 확인.  
       3. 회원정보조회 API 테스트 진행. 관리자or사용자 일치여부 확인하는 로직 넣고 코드 다듬음. 최종 정상작동 확인.  
       4. 나머지는 코드 손 안대고 예전에 확인했던 것들이라 테스트 패스. 비밀번호 재설정 API는 지난 작업 중에 테스트 했던거라 패스.  
   32. Product 관련 API 테스트  
       1. 카테고리 관련 API들은 코드 손 안대고 예전에 확인했던 것들이라 테스트 패스.  
       2. 상품 마스터 등록 API 테스트. 정상입력인데 예외처리되는 문제 발생. 보안 인증 쪽은 문제가 없었고, 지정한 예외처리를 의도적으로 만들면 잘 처리되는걸로 봐서는 로직 중간에 문제가 있을 확률이 높은데… 코드를 아무리 봐도 이상한 점이 없음. 결국 컨트롤러에 예외처리되는 내용을 로그에 출력되도록해서 확인해보니, redis 쪽 문제였음. 간만에 API 테스트 하는거라 redis 서버를 안켰다는걸 깨닫고 서버를 켜서 작동시켜보니 정상작동함.  
       3. 상품 마스터 수정 API 테스트. DTO에 들어오는 정보만 최신화하는 로직이 매퍼쪽에 있었던걸 서비스쪽으로 옮김. 오류나면 찾아서 수정하고, 최종 정상작동 확인.  
       4. 상품 품목 등록 API 테스트. 테이블 구성이 변경되면서 수정해야할 부분 수정하고, 최종 정상작동 확인.  
       5. 상품 품목 수정 API 테스트. DTO에 들어오는 정보만 최신화하는 로직이 매퍼쪽에 있었던걸 서비스쪽으로 옮김. 오류나면 찾아서 수정하고, 최종 정상작동 확인.  
       6. 상품 품목 입고 API 테스트. 매퍼쪽과 VO쪽 코드가 이상한 부분들 있어서 수정하고, 최종 정상작동 확인.  
       7. 실제로 안쓰더라도 원활한 테스트를 위해 대량입고 API가 필요함을 느낌. 상품 대량 입고 API 세팅. 정상 작동은 확인했는데… 입력된 테이블들을 확인하면서 inventory\_histories 칼럼에 product\_item\_id가 있는 것에 위화감을 느낌. 예전에 재고 정보를 product\_items 테이블에 맞췄을때 세팅한건데, 이후에 재고 정보를 product\_inventories 테이블로 이동하고 수정을 안했던 것. product\_item\_id를 product\_inventory\_id로 수정하고, 이에따라 변경되어야하는 코드 수정. 오류나면 찾아서 수정하고, 최종 정상작동 확인.  
       8. 카테고리별 상품 마스터 목록 조회 API 테스트. 정상작동 확인.  
   33. order 관련 API 테스트.  
       1. 주문 접수 API 테스트. 재고용 테이블을 추가한 후 최신화가 안되있어서 최신화. 주문 수량에 맞춰 product\_items 테이블의 재고수량과 예약수량이 변경되어야하는데, 일괄적으로 1개만 바뀌게 적용되는 오류 발견하여 로직 추가하여 수정. 정상처리를 포함한 예외처리 작동 확인.  
       2. 관리자용 주문 상품 상태 업데이트(결제 대기 \-\> 준비중) API 테스트. 일반회원이 요청할때 통상 500 에러가 나오는게 마음에 안듦. 전에 미권한 접근에 대한 오류 지정을 해준 기억이 있는데 왜 작동안하는지도 궁금. 확인해보니 전에 세팅한건 API에 접근하기 전에 토큰으로 권한을 체크하는 로직이었고, 지금 상황은 그 체크를 통과한 다음 API 컨트롤러의 @PreAuthorize에서 걸리는거라 따로 세팅을 해줘야하는 것이었음. 해당 예외 전용 핸들러 .java를 추가한 다음, SecurityConfig.java에 핸들러 설정 코드를 추가하고, application.properties에 스프링 시큐리티 필터 타입 코드를 추가하여 세팅. 이제는 지정한 오류가 출력되는걸 확인. 예외조건과 정상조건일때 정상 작동 확인.  
       3. 관리자용 주문 상품 상태 업데이트(준비중 \-\> 배송중) API 테스트. DeliveryInfoDTO에 private List\<String\> barcodes;가 들어가 있는데, 로직상 바코드 리스트가 들어가는게 맞아서 private List\<String\> barcodes;로 수정. 관련 코드들도 수정. orderProduct의 quantity와 배송 정보에 있는 바코드 개수가 일치하는지 확인하는 로직 추가. 해당 바코드 재고의 productItemId와 주문 상품의 productItemId가 일치하는지 확인하는 로직 추가. 예외조건과 정상조건 작동 확인.  
       4. 관리자용 주문 내역 업데이트(배송중 \-\> 배송완료) API 테스트. 주문 존재 여부 확인하는 로직 일부에 순서상 허점이 있어서 수정. 현재 주문 상품 status가 DELIVERING 또는 EXCHANGE\_DELIVERING인 경우에만 통과시키는 로직에 문제가 있어서 수정. 예외조건과 정상조건 작동 확인.  
       5. 검토하다보니 ‘반품된 상품 수량만큼 상품 품목 재고 증가 & 예약 수량 감소’ 로직과 ‘구매 확정으로 인한 예약 수량 감소 & 판매 수량 증가’ 로직이 있는게 좋을거 같아서 로직 추가 후 관련 코드 수정. 예외조건과 정상조건 작동 확인.  
       6. 주문 내역 업데이트(배송완료 \-\> 구매확정) API 테스트. 주문 존재 여부 확인하는 로직 일부에 순서상 허점이 있어서 수정. 구매확정 시간이 DB에 기록이 안되서 확인해보니 매퍼 코드에 문제가 있어서 수정. 예외조건과 정상조건 작동 확인.  
       7. 자동 구매 확정 처리 API는 일단 postman으로 당장 테스트가 곤란해서 보류.  
       8. 회원 본인 주문 내역 리스트 조회 API 테스트. 매퍼의 resultMap이 UserOrderHistoryDTO에 제대로 안담기는 오류가 발생. resultMap의 column명을 바꾸는걸로 해결. 예외조건과 정상조건 작동 확인.  
       9. 단일 주문 상세 조회 API 테스트. 주문 상품 정보 조회 DAO 로직에 문제가 있어서 수정. 예외조건과 정상조건 작동 확인.  
       10. 관리자용 전체 주문 상품 리스트 조회 API 테스트. 매퍼쪽 코드에 문제가 있어서 수정. 예외조건과 정상조건 작동 확인.  
       11. 회원 주문 상품 취소/반품/교환 요청 API 테스트. 서비스 단계에서 예외 처리 지정이 잘못되어 있어서 수정. 예외조건과 정상조건 작동 확인.  
       12. 관리자의 주문 취소 요청 승인(배송 이전) API 테스트. 주문 상품 상태가 취소요청인 경우에만 통과하는 로직에 문제가 있어서 수정. 예외조건과 정상조건 작동 확인.  
       13. 반품 관련 API 코드와 DB를 검토하면서, 현재 구조에서는 특정 상품을 여러개 주문하고 일부를 반품하는 것이 불가능하며 그걸 구현할 경우 과거 기록과 변동 기록을 전부 남길수 없다는걸 깨달음(특히 수량). 이를 개선하기 위해서는 order\_products의 변동사항을 기록하는 전용 테이블을 추가해야한다는 결론이 나옴. 이제와서 테이블을 또 추가하고 관련 코드 수정하는게 얼마나 복잡할지 감도 안잡히지만, 어차피 선택지가 없다고 생각해서 테이블 추가 작업 결정.  
   34. API 로직 보강  
       1. order\_product\_histories 테이블 생성하고 VO와 매퍼 세팅. 관련된 API 들에 코드를 추가하면서 시뮬레이션하다보니, 특정 품목을 5개 주문하고 2개만 반품하거나 교환할 경우 어차피 현재 order\_products 테이블 구조 자체의 한계가 있어서 order\_product\_histories 테이블 추가하는걸로 해결이 안된다는걸 인지. order\_products 테이블의 quantity 칼럼을 original\_quantity 칼럼과 current\_quantity 칼럼으로 쪼개고, orders 테이블의 total\_price 칼럼을 original\_total\_price 칼럼과 current\_total\_price 칼럼으로 쪼개는 것으로 초기 주문 정보와 변경 주문 정보를 저장할 수 있게 수정.   
       2. 테이블 추가 및 칼럼 변경으로 인해 수정이 필요한 관련 코드들 전부 수정.  
       3. 관련 코드 수정 완료 후, 문제가 있거나 보강해야할 부분이 있는지 검토. 트랜젝션 격리 수준과 동시성 제어를 위한 잠금 세팅이 추가되는게 권장되는걸 확인.  
       4. order 서비스 단계에 REPEATABLE\_READ 격리 세팅  
          1. 주문 접수 API  
          2. 관리자용 주문 상품 상태 업데이트(결제 대기 \-\> 준비중) API  
          3. 관리자용 주문 상품 상태 업데이트(준비중 \-\> 배송중) API  
          4. 관리자용 주문 내역 업데이트(배송중 \-\> 배송완료 / 교환 배송중 \-\> 교환 배송완료) API  
          5. 주문 내역 업데이트(배송완료 \-\> 구매확정 / 회원 본인 & 관리자 접근 가능) API  
          6. 자동 구매 확정 처리(배송완료/교환 배송완료 7일 후) API  
          7. 회원의 주문 상품 취소/반품/교환 요청 API  
          8. 관리자의 주문 취소 요청 승인(배송 이전) API  
          9. 관리자의 주문 반품 요청 승인(반품 요청 \-\> 반품 중) API  
          10. 관리자의 주문 반품 완료 처리(반품 중 \-\> 반품 완료) API  
          11. 관리자의 주문 교환 요청 승인(교환 요청 \-\> 교환 반품 중) API  
          12. 관리자의 주문 교환 준비 처리(교환 반품 중 \-\> 교환 준비 중) API  
          13. 관리자의 주문 교환 배송 처리(교환 준비 중 \-\> 교환 배송 중) API  
       5. product API에 비관적 락 세팅(매퍼에서 SQL 쿼리에 FOR UPDATE 추가)  
          1. ProductItemMapper의 getProductItemForUpdate   
          2. ProductInventoryMapper의 getProductInventoryForUpdate  
       6. 낙관적 락 세팅을 위해 AOP를 세팅. OptimisticLock.java와 OptimisticLockAspect.java를 만들어서 충돌 발생 체크 로직 코드 추가. 여기서 큰 문제가 발생하는데, 빌드그래들에 적절한 의존성 주입을 했는데도 org.aspectj가 import 인식이 안됨. 전에도 비슷한 문제가 있었는데 재실행하다가 자연스럽게 해결됐었어서 재실행을 엄청 해봤는데 해결이 안됨. 결국 해결법을 다시 찾아다니면서 적용해봤는데, 자바 확장 기능이 사용하는 캐시를 초기화하는걸로 해결되는걸 겨우 찾아냄. 이거때문에 하루종일 작업이 멈춰있었는데, 추후에는 이 이슈로 더이상 고생하지 않을 수 있을 듯.  
       7. order API에 낙관적 락 세팅(DB 테이블에 version 칼럼 추가, 서비스 단계에서 AOP를 활용하여 충돌 발생 체크 로직 추가)  
          1. OrderProductMapper의 updateOrderProductStatus / 해당 로직을 쓰는 서비스의 API  
   35. API 로직 보강  
       1. product 서비스 단계에 REPEATABLE\_READ 격리 세팅  
          1. 상품 품목 정보 수정 API  
          2. 상품 품목 입고(단일 품목) API  
          3. 상품 품목 입고(대량 입고) API  
       2. product API에 낙관적 락 세팅(DB 테이블에 version 칼럼 추가, 서비스 단계에서 AOP를 활용하여 충돌 발생 체크 로직 추가)  
          1. ProductItemMapper의 updateProductItem / 해당 로직을 쓰는 서비스의 API  
       3. 낙관적 잠금을 처음 만들때 order 로직에서 만들다보니 예외메시지가 order 전용으로 세팅되어있었는데, product 로직에도 같은 AOP를 쓰게되면서 문제가 발생. 예외메시지를 공통 양식으로 수정 후 적용.  
       4. user 서비스 단계에 REPEATABLE\_READ 격리 세팅  
          1. 회원 가입 API  
          2. 로그인 API  
          3. 로그인 기록 저장 API  
          4. 이메일로 사용자 정보 조회 API  
          5. 사용자 일반 정보 수정 API  
          6. 사용자 비밀번호 수정 API  
          7. 사용자 탈퇴 API  
          8. 비밀번호 재설정 토큰 생성 및 이메일 발송 API  
          9. 비밀번호 재설정 API  
       5. user API에 비관적 락 세팅(매퍼에서 SQL 쿼리에 FOR UPDATE 추가)  
          1. UserMapper의 findByEmail  
       6. user API에 낙관적 락 세팅(DB 테이블에 version 칼럼 추가, 서비스 단계에서 AOP를 활용하여 충돌 발생 체크 로직 추가)  
          1. UserMapper의 updateUser / 해당 로직을 쓰는 서비스의 API  
          2. UserMapper의 updateResetToken / 해당 로직을 쓰는 서비스의 API  
       7. review API에 낙관적 락 세팅(DB 테이블에 version 칼럼 추가, 서비스 단계에서 AOP를 활용하여 충돌 발생 체크 로직 추가)  
          1. ReviewMapper의 updateReview / 해당 로직을 쓰는 서비스의 API  
   36. 결제 서비스 세팅  
       1. 포트폴리오 웹서비스다보니 실제 결제를 구현하는건 적합하지 않다고 생각해서 작업을 미뤄놨는데, 이제 이것만 남은거 같아서 작업 결정. 일단 어떻게 구현하는게 가장 좋을지 고민해봤는데, 결제서비스를 테스트 모드로 구현할 수 있다고 하여 그걸로 해보기로 함.  
       2. 가장 효율적이면서 실무에 가깝게 구현하는 방식을 알아보니 ‘포트원’이라는 결제 통합관리 서비스가 가장 적절할거 같다는 결론. 가입해서 결제연동 정보를 보니 테스트용 토스페이먼츠 하나로 내 세팅이 커버 가능해서, 토스페이먼츠의 키들을 발급받음. V1과 V2 중 선택해야하는데 포트원 가이드에서는 V2를 추천하기에 V2로 잠정 결정.  
       3. 빌드그래들에 webflux, json, configuration-processor 의존성 주입.  
       4. application.propertie에 포트원 필요 변수를 환경변수로 세팅. env에 API 시크릿, 스토어 아이디, 시크릿 키, 클라이언트 키, 베이스 URL 환경변수 세팅.  
       5. 설정 폴더에 PortOneProperties.java 만들어서 포트원 설정 코드 세팅.  
       6. 포트원 API와의 통신을 담당하는 서비스 클래스인 PortOneApiService.java 파일 세팅. 포트원API 규격에서 토큰 헤더가 "Authorization"인데, 이건 기존에 내가 JWT로그인 엑세스토큰 세팅해놓은것과 동일해서 충돌하게 됨. 고민하다가 JWT로그인 토큰쪽 헤더명을 변경하는걸로 정리. 토큰 만료시간 계산 로직 보완하고, 전용 예외 클래스 파일을 세팅하고, 엑세스 토큰 조회에서 동시성 문제가 생길수 있어 AtomicReference 적용하고, 사용자 경험을 위해 토큰 만료 전에 미리 갱신하는 여유시간을 적용.  
       7. 결제 처리를 위한 PaymentService.java 세팅. 외부 API랑 연동하는 로직은 처음이라 공부하면서 하나하나 만듦. 시행착오를 많이 겪긴했는데 어떻게든 완성.  
       8. PaymentController.java 세팅. 서비스를 기반으로 제작.  
       9. 웹훅이 필요하다고 하여, 웹훅에 대해 공부.  
       10. PaymentService.java에 웹훅 로직 세팅. 처음 시도해보는 로직이라 하나하나 이해하기 위해 노력하면서 진행. 웹훅이 호출되면 검증단계를 거친 후 받는 결제 상태에 따라 결제 완료/결제 실패/결제 취소 메서드에 연결되는 구조.  
       11. 결제 내역을 DB에 저장하는 로직이 필요하다고 생각되어, DB에 테이블 추가하고 VO, 매퍼, DAO 세팅. 서비스 단계에 결제 내역 저장 로직을 추가…하는데 포트원에서 넘어오는 정보의 내역을 정확히 몰라서 DB 테이블 칼럼이나 DTO를 어떻게 세팅해야할지 문제가 됨. 일단 포트원 OpenAPI JSON을 토대로 세팅함. 나중에 직접 테스트해보면서 조정해야 함.  
       12. 결제 내역 조회하는 로직 추가.  
   37. API 로직 보강  
       1. 자동 이메일 발송 로직을 세팅했는데, 비밀번호 분실시 재설정에만 쓰이는게 아까움. 회원가입 완료와 결제 완료시에도 이메일을 발송하도록 로직을 수정/추가.  
       2. PaymentController에 try-catch 세팅이 안된 부분들이 있어 보강.  
2. 쇼핑몰 리액트 프론트엔드 작업  
   1. 스프링 프로젝트 안에 프론트엔드를 넣을지, 별도 폴더에 프론트엔드를 만들지 고민. 장단점을 따져보고 별도 폴더에 만들기로 결정.  
   2. 리액트 프로젝트 생성.  
   3. 디자인 기획은 안되있는 상태라서, 메인 페이지를 만들면서 디자인을 잡아가는 방향 선택.  
   4. 리액트 기초 강의만 들은 후 직접 만들어보는건 처음이다보니, 개념적인 부분에서 구멍이 안생기도록 기초적인 부분들에 대해 복습 및 서치.  
   5. JWT 인증 로직 세팅  
      1. 일단 로그인에 관련된 JWT 인증 쪽 세팅을 하는게 먼저인 것 같아 작업 결정.  
      2. 인증 로직을 담을 컨텍스트인 AuthContext.js를 만듦.  
      3. 인증 로직을 짜려다보니, 백엔드에서 넘어오는 JWT 토큰을 클라이언트에서 어떻게 처리할지를 정해야된다는 사실을 깨달음. 로컬스토리지 저장방식, 세션스토리지 저장방식, 쿠키 저장방식, 메모리 저장방식 등등 중에서 선택해야하는 상황. 각각의 장단점들을 따져보고 현재 구축중인 웹서비스의 특성을 고려했을때, 엑세스 토큰은 응답헤더로 넘겨받아 세션스토리지에 저장하고 리프레시 토큰은 쿠키에 저장하는게 가장 적절하다는 판단을 내림.  
3. 쇼핑몰 스프링 프로젝트 백엔드 작업  
   1. JWT 관련 로직 수정  
      1. 기존 세팅은 엑세스 토큰과 리프레시 토큰 모두 응답 헤더에 단순하게 넣는 방식이었으나, 리프레시 토큰을 쿠키에 저장하기로 결정했으므로 리프레시 토큰에 대한 로직을 수정해야하는 상황.  
      2. 리프레시 토큰을 쿠키에 넣도록 관련 로직들을 수정.  
4. 쇼핑몰 리액트 프론트엔드 작업  
   1. JWT 인증 로직 세팅  
      1. AuthContext.js에 로그인시 백엔드에서 넘겨받은 엑세스 토큰을 세션스토리지에 저장하고, API 요청시에 세션스토리지의 엑세스 토큰을 꺼내 헤더에 붙이고, 로그아웃시 세션스토리지를 비우는 로직 세팅.  
      2. index.js의 root에 인증 컨텍스트 세팅.  
   2. homepage 세팅  
      1. 기본적인 틀을 잡아놓고 디자인에대해 고민하기 위해 기초적인 레이아웃과 메인페이지를 구현… 하는 도중, 세세한 디자인을 하나하나 설정하려면 한도끝도 없다는걸 새삼 깨달음. 안그래도 처음에 기획할때 그 부분을 고려하여 막연하게 부트스트랩 프레임워크를 쓰면 되지 않을까 생각했던게 떠오름. 하지만 그때는 프론트엔드 프레임워크 종류에 대해 깊이 알아보지 않고 그냥 알고있다는 이유만으로 정했던거라, 이제 본격적으로 고민해야되는 시점이 됨.  
      2. 프론트엔드 프레임워크 종류에 대해 서치. 여러종류가 있다는걸 알게됐는데, 장단점을 놓고 고민하다 결국 Ant Design으로 결정.  
      3. Ant Design을 설치하고, 느낌을 보기위해 기초적인 레이아웃과 메인페이지를 짜서 확인. 충분히 사용할만하다고 느껴서 Ant Design을 계속 써보기로 함.  
      4. 본격적인 작업 전에 디자인 컬러를 잡아놓고 들어가야 할거 같아서 고민해봤는데, 내가 디자이너가 아니니 어설프게 디자인 컬러를 골랐다가 이도저도 안될거 같다는 생각이 들었음. 그래서 다소 전통적이긴 하지만 ‘블랙&화이트+포인트 컬러 1\~2종류’ 정도로 결정.  
      5. 일단 헤더 먼저 작업해보기로 함. 포트폴리오 프로젝트 명 전체(GYP portfolio shoppingmall)를 쇼핑몰 이름으로 해보니 텍스트 길이가 너무길어서 보기도 안좋고 구성하기에도 애매한 부분이 많아서, 그냥 shoppingmall로 축소를 결정.  
      6. 헤더에 넣고 싶은게 쇼핑몰명, 회원기능 버튼들(로그인, 회원가입, 장바구니, 마이페이지 등등), 검색창, 카테고리 등이고 특히 모바일환경에서는 가로길이가 짧은 특성을 고려하면 한 줄로는 구성하기 애매하다는 결론에 도달. 그렇다고 헤더 줄 수를 많이 늘리면 사용자경험 상 나쁘기 때문에, 두 줄이 가장 적당할거 같다고 생각함.  
      7. 헤더를 두 줄로 하기로하고 구상에 대해 고민을 좀 해봤는데, 두번째 줄에 카테고리 정보를 담고, 나머지는 첫번째 줄에 담는게 깔끔할거 같다는 결론 도달.  
      8. 헤더 첫번째 줄 작업. 왼쪽에 쇼핑몰 명(홈버튼도 겸함) 놓고, 오른쪽에 검색아이콘과 회원기능버튼을 놓음. 원래는 검색창이 노출되어있는게 일감이긴 한데, 모바일 환경을 고려하면 공간부족 이슈가 생김. 따라서 검색아이콘만 놓고 클릭하면 검색창이 확장되는 식으로 구상함.  
      9. 그래서 접혔다 펴지는 검색창을 구현해봤는데… 직접 구현하고보니 문제가 발생함. 모바일 환경에서는 검색창이 펴졌을때 결국 공간이 부족한 이슈 자체가 해결된건 아니라, 이걸 어떻게 해결하는지가 관건이 됨. 이런저런 고민을 하다가 최종적으로 데스크탑 환경에서는 공간부족 이슈가 없으니 기존 안대로 가고, 모바일 환경에서는 검색아이콘을 누르면 첫번째 줄 아래로 추가 줄이 생기면서 검색창이 되는 안으로 결정. 추가로 줄이 생기는 애니메이션이 어색하는 등 이슈들이 발생하긴 했는데, 수정을 반복하면서 최종버전에서는 만족할만한 결과가 나옴.  
   3. 헤더 두번째 줄 작업.   
      1. 카테고리를 넣을 계획인데, 개인적으로 드롭다운 구조는 모바일 환경에 적합하지도 않고 콘텐츠를 필연적으로 가리게 되어 마음에 안들어서 피하고 싶음. 가장 무난한 방안은 왼쪽에서 콘텐츠 영역이 나오게 한다던지 해서 카테고리를 전개하는건데… 최대한 깔끔하게 만들어보고 싶어서 별도의 영역전개 없이 헤더 줄 하나 안에서 해결해볼 생각.  
      2. 일단 처음엔 최상위 카테고리 리스트를 전개하고, 원하는 카테고리를 누를때마다 하위 카테고리가 전개되는 방식이 떠오름. 로직을 짜서 초안을 구현해봤는데 두가지 문제가 발견됨. 일단 한단계라도 들어가면 최상위 카테고리로 돌아갈 방법이 없어지고, 카테고리 선택 전후의 배열이 어수선함.  
      3. 개선을 위해 맨 좌측에 최상위 카테고리로 돌아가는 ≡ 버튼을 고정위치시키고, 카테고리 선택 전후에 배열될 기준선을 세팅. 이걸로 ‘≡ 남성 \> 상의’ 형태의 기본틀이 잡힘.  
      4. 테스트를 하다보니 순환루프가 작동하여 ‘남성 \> 상의 \> 남성 \> 상의 \> …’ 이런식으로 depth가 증식하는 문제를 발견. 카테고리 경로를 체크하고 중복을 허용하지 않는 로직을 구현하여 문제 해결.  
      5. 순환루프 문제는 해결했으나, 카테고리를 클릭시 로직이 출력에 그대로 노출되어 어색한 애니메이션이 되는 문제 발견. 예를들어 ‘남성 \> 상의’ 상태에서 ‘상의’를 다시 누르면 순간적으로 ‘남성 \> 상의 \> 상의’가 되었다가 ‘남성 \> 상의’로 돌아가는게 적나라하게 보임. 로직이 완료된 후 출력이 되도록 코드 수정하는걸로 문제 해결. 그리고 겸사겸사 카테고리 레벨 3까지 로직에 명시하여 이상하게 작동할 여지를 막는 조치도 추가.  
      6. 최상위 카테고리로 돌아가는 버튼 아이콘으로 ≡ 은 계속 보다보니 어색함. 보통은 메뉴를 여는 버튼의 아이콘으로 쓰여서, 현재 기능과 스테레오타입이 불일치함. 쓸수 있는 아이콘 리스트를 쭉보니 앱스토어 아이콘이 가장 잘 맞을거 같아서, 그걸로 수정하고 커서올리면 툴팁 나오게 변경.  
      7. 헤더 둘째줄에 카테고리 로직만 렌더링 효율성을 위해 메모이제이션 적용.   
      8. 헤더 둘째줄에 카테고리 로직만 사용자 경험을 위해 로딩중 표시 로직 적용.  
      9. 전반적으로 스크린 리더 사용자, 키보드 사용자를 위한 ARIA 속성 추가.  
      10. 헤더 둘째줄에 한번이라도 클릭된 카테고리는 계속 하이라이트 효과가 들어가는 중이라, 마지막으로 클릭된 카테고리가 뭔지 알수가 없는 문제 발생. 하이라이트 효과가 마지막으로 클릭된 카테고리에만 적용되도록 로직 수정.  
   4. 관리자 페이지 작업  
      1. 레이아웃 작업하다보니, 결국 프론트엔드 기능 테스트를 위해서 이미 구축한 백엔드와 빨리 연동시키는게 제일 좋겠다는 생각이 들었음. 관리자 페이지 작업의 우선순위를 끌어올림.  
      2. 관리자 페이지 레이아웃, 대시보드, 관리자 로그인 페이지 초안 작성. 관리자 로그인 로직이 잘 안맞아서, 여러 수정 끝에 성공.  
      3. 관리자 페이지 레이아웃 수정 작업. 사이드바 타이틀 위치 어긋나는 부분 수정. 사이드 메뉴 아이템 텍스트 색 일치하도록 수정. 사이드바 접히면 타이틀 텍스트가 찌부러지는 이슈가 있어서, 접히거나 펴질때 적용되는 텍스트를 다르게 세팅하고 변환 모션이 부자연스러워서 싱크 조절. 모바일 환경에서 사이드바가 펴져있으면 거의 화면의 반을 가리고, 접혀있어도 공간을 꽤 차지하는게 마음에 안듦. 어떻게 할까 고민하다가 모바일 환경에서는 드로어 방식으로 아예 완전히 수납되도록 수정. 헤더 타이틀과 사이드바 타이틀을 데스크톱 환경과 모바일 환경 각각에 적합하도록 수정.  
      4. 관리자 대시보드 메인 페이지 수정 작업. 미리 구성해놓은 백엔드의 API와 연동하여 정보를 출력하도록 시도. 연동이 잘 안되서 보니 내가 GET API 세팅할때 보안이슈가 걱정되어 @RequestBody로 받게 세팅했던게 API 표준과 맞지 않아서 문제가 되던 것이었음. 공부해보니 GET API의 경우 @RequestParam으로 받는게 기본이고, DTO 연동구조라면 @ModelAttribute로 받는게 가능하다고 나옴. 나는 DTO를 다 짜서 RequestBody로 세팅해놨던거라, ModelAttribute로 수정하는게 쉽고 간편한 듯하여 그렇게 수정.  
      5. ModelAttribute로 수정 후에도 메인페이지 데이터가 안불러와져서 원인을 찾아 순차적으로 수정. payment\_histories 테이블 칼럼명 수정, payment\_histories 테이블 관련 DTO 수정, 프론트엔드 요청값을 DTO 항목과 일치시키는 작업 등 진행.  
      6. 관리자 인증에 관련된 문제가 생겨서 분석해보니 백엔드로부터 받은 토큰이 프론트엔드에서 제대로 처리안되는 이슈로 밝혀짐. 관련 로직 검토하다가 로그인 로직에 비효율적인 부분도 발견되어 그걸 먼저 수정. 일단 이슈의 핵심 원인은 백엔드에서 토큰헤더 상수를 대문자로 설정한걸 따라서 프론트엔드에서 똑같은 상수를 가져다 썼는데, 헤더가 네트워크 전송될때 기술적으로 대소문자를 구분하지 않기 때문에 프론트로 넘어오면서 소문자로 바뀌어 로직이 꼬인것. 프론트엔드 헤더 관련 상수를 소문자로 변경하여 해결.  
      7. 로그인 쪽 문제를 해결했지만, 여전히 대시보드 메인페이지는 백엔드에서 데이터를 못가져오는 중. 일단 메인페이지에 하나라도 로딩이 안되면 전체가 먹통이 되는 상황이라, 로딩이 안되는게 있더라도 기본 폼은 출력되도록 수정. 하나씩 순차적으로 고치는 전략 채택.  
      8. 일단 총 회원 수를 불러오는 API 검토. 분석해보니 백엔드에서 숫자형으로 가져와지는 값을 object형을 다루는 로직을 썼던게 문제였음. 해당 로직 수정하여 정상 출력 확인.  
      9. 총 주문 수를 불러오는 API 검토. 분석해보니 매퍼쪽 코드가 이상한 부분들이 있었고, DTO쪽에 최신화가 안되어있던게 문제였음. 해당부분들 전부 수정하여 정상 출력 확인.  
      10. 최근 주문 내역 불러오는 API 검토. 주문 내역은 백엔드에서 받고 있고, 프론트엔드에 출력할 요소를 맞게 지정하면 되는 상황이라 작업 진행. 맞게 출력되는지 확인 완료.  
      11. 총 매출액을 불러오는 API 검토. 출력 테스트를 위해 임시데이터를 DB에 입력 후, 정상 출력 확인. 그러나 현실에서 총 매출액을 보기 보다는 해당 월 매출액을 확인하는게 자연스러워서, 총 매출액을 해당 월 매출액으로 변경하는 작업 진행. 백엔드에서 오류가 나와서 확인해보니 필터 조건으로 날짜를 프론트에서 넘길때 string으로 넘어가는데, 백엔드 DTO는 LocalDateTime을 받는걸로 되어있어서 오류가 나고 있었음. DTO 해당 항목에 @DateTimeFormat을 추가하고 프론트엔드에서 양식에 맞게 편집하는 로직을 추가하는걸로 백엔드 오류는 해결. 하지만 프론트엔드에서 받아지는 정보가 없는 문제가 있어 확인해보니, 필터 조건 중 limit가 비어있으면 백엔드에서 0으로 처리하는 바람에 0개를 조회하는 로직이 되기 때문이었음. 매퍼에 limit가 0이면 LIMIT을 걸지 않도록 로직을 수정하여 해결.  
      12. ‘총 주문 수’도 더 적합하게 ‘해당 월 주문 수’로 수정하는게 좋겠다는 생각이 듦. 총 매출액을 수정했던걸 토대로 로직 수정.  
      13. 모바일 환경에서 보니, ‘최근 주문 내역’의 표가 영역 밖으로 삐져나가는걸 확인. 기본형태가 가로로 길게 맞춰져있다보니 좌우로 줄어드는데 한계가 있는 상황. 어떻게할지 고민하다가 모바일 환경에서는 표가 반응형 카드로 바뀌는 형태로 결정. 코드 수정하는김에 주문 상태를 나타내는 부분을 Tag로 변경. 정상 출력 확인.  
      14. 사이드 메뉴를 DB 테이블에 맞춰 정리.  
      15. 상품 목록 페이지 초안 제작. DB 테이블 구조가 ‘상품 마스터\>상품 품목’의 상하관계를 가지고 있는데, 이걸 어떤식으로 접근시키는게 최선일지 고민. 일단 상품 마스터 목록이 있고 특정 상품 마스터를 선택하면 모달/드로어 방식으로 확장되어 상품 품목으로 접근할 수 있는 구성을 선택. 모달/드로어 동작만 구현하고 내용은 일단 비워둠.  
      16. 카테고리를 넣을 계획인데, 개인적으로 드롭다운 구조는 모바일 환경에 적합하지도 않  
      17. 상품 목록의 표에 아무것도 출력되고 있지 않은데, 일단 처음 페이지에 접속했을때는 전체 상품 목록을 불러오는게 좋을 듯. 전에 만들었던 ‘카테고리id를 조건으로 상품 마스터 조회 API’에 카테고리id가 요청에 들어가지 않을경우 전체 상품 마스터 조회하는 로직을 추가. 그리고 프론트엔드에 조회결과를 연결. 조회 내용이 연결되어 표에 출력되는 것을 확인.  
      18. 표의 내용이 출력되기 시작하니, 표가 기본 영역을 벗어나거나 셀 너비가 부자연스러운 등 수정이 필요한 부분이 많이 보이는 상황. 표가 기본 영역을 안벗어나게 수정하고, 뷰포트에 스크롤 안생기고 표 영역에만 스크롤 생기도록 수정하고, antd의 페이지네이션 옵션 적용하고, 스크롤 시 고정 행/열 세팅하고, 셀 너비 안망가지게 세팅하고, 구성요소 사이즈나 위치 조정하고, ‘카테고리’ 칼럼 삭제. 일단 초안은 정리 완료.  
      19. ‘카테고리 선택’ 드롭다운에 아무것도 조회되고 있지 않음. 백엔드와 연동하도록 수정하고 조회결과를 봤는데, 부모/자식 카테고리 구조인데 최종단계 카테고리만 목록에 나와서 카테고리 구조를 제대로 반영하지 못하는 문제가 발생. antd의 Cascader를 사용하여 종속단계를 반영할 수 있는 드롭다운으로 수정. 출력 상태 확인해서 수정할 부분 다듬어서 정리.  
      20. 이제 카테고리를 선택하면 목록 표에 해당 카테고리 상품 마스터가 출력되는 로직을 추가할 차례. 임시로 세팅해놨던 로직이 작동하지 않아서 확인해보니, 백엔드에서 받아야하는 URL 형식에서 어긋나있는게 확인되어 수정. 정상 작동 확인.  
      21. 카테고리 선택 드롭다운에서 선택된 카테고리의 하이라이트 효과가 시인성이 떨어져서 수정.  
      22. 카테고리 선택 조회 기능이 작동하면서부터, 전체 조회가 먹통이 된걸 확인. categoryId로 조회하는 로직이 추가되면서 전체 조회를 위해 categoryId를 비워서 넘기면 null이 잡혀서 int가 아니라고 백엔드 오류가 나는게 원인. categoryId가 없을때는 아예 url에서 빼는 분기를 추가하여 해결.  
      23. 상품명 검색 기능을 구현할 차례. 일단 백엔드의 상품 마스터 조회 API 로직에 categoryId와 keyword를 받도록 수정하고, categoryId와 keyword 중 어떤 값이라도 받으면 해당 조건으로 조회하고 아무것도 안받으면 전체 조회하는 로직으로 개편. 그리고 프론트엔드에서 검색 버튼을 누르면 키워드를 백엔드로 전달해서 조회하도록 로직 구현. 하지만 전체 조회와 조건 조회 모두 제대로 작동하지 않는 문제 발생. 원인을 명확하게 찾아내는데 좀 고생했지만, 매퍼 쿼리 코드 중 인젝션 위험있는 부분 보강하고 프론트엔드에서 비어있는 값을 백엔드로 넘길때 ‘null’이 아닌 ‘’로 넘기도록 수정하고 프론트엔드에서 전체 조회와 조건 조회에 따른 분기 로직을 다듬는걸로 결국 문제 해결. 조건별로 정상 조회되는걸 확인.  
      24. ‘카테고리 선택’ 드롭다운 항목에 전체조회 항목이 없어서, 한번이라도 카테고리를 선택하게되면 전체조회를 못하는 문제가 있음을 인지. 드롭다운 항목 첫번째에 고정으로 ‘전체’ 항목을 세팅하여 언제든 전체조회가 가능하게 수정.  
      25. ‘카테고리 선택’ 드롭다운에서 상위 카테고리에 마우스오버해서 전개되는 하위 카테고리가 마우스 오버된 높이에서부터 시작하는게아니라 전체 첫번째 줄부터 시작하는게 마음에 안듦. 수정하고 싶어서 antd cascader를 파봤는데 내가 원하는 수정옵션이 없는걸 확인하고 포기.  
      26. 상품 목록 표의 칼럼 위치를 보기좋게 재배치하고, ‘상품명’은 가로 스크롤에 영향받지 않도록 고정 처리.  
      27. ‘카테고리 선택’ 드롭다운에서 상위 카테고리를 선택하면 조회결과가 없는 문제 인지. 이건 상품 마스터 테이블에 가장 하위 카테고리 정보만 들어있는 구조적 이슈때문이라, 매퍼 쿼리에 재귀 쿼리 로직을 추가하여 해결.  
      28. ‘카테고리 선택’ 드롭다운에서 상위 카테고리에 마우스오버를 해야 하위 카테고리가 전개되는데, 모바일 환경에서는 마우스가 없이 터치로는 하위 카테고리에 접근하는게 귀찮은 상황이 되는걸 확인. 전개트리거를 ‘hover’에서 ‘click’으로 바꾸는걸로 해결.  
      29. 우상단 ‘상품 추가’ 버튼과 표 내부의 ‘수정/품목 관리/삭제’ 버튼의 기능 구현 시작. 일단 ‘상품 추가’ 버튼과 ‘수정’ 버튼에 연결할 모달 코드를 세팅. 팝업된 모달 디자인이 엉망이라 조정.  
      30. 우상단 ‘상품 추가’ 버튼에 실제 API를 연결하여 기능 구현 시작.   
      31. 백엔드에 짜놓은 API에 맞춰 ‘상품 추가’ 모달 코드 수정. 수정하다보니 imageUrl 칼럼에 대해 미뤄뒀던 고민이 다시 떠오름. imageUrl 칼럼이 현재 테이블에 있는게 맞는지, 여러 이미지url을 하나의 칼럼값에 저장하는게 가능한지, 그리고 나중에 더미 상품 이미지 넣을게 엄청 많을텐데 어떻게 수급을 할지를 따져보면서 고심. 일단 칼럼은 유지하기로 하고, 여러 url을 JSON형태로 넣는게 가능할테니 그 방안을 잠정적으로 채택하고, 데미 상품 이미지는 기성 웹서비스에서 url을 따오되 readme 등에 출처를 명확하게 명시하는걸로 정리. DB에 JSON형태로 저장할 것에 맞춰 프론트엔드에서 파싱하는 로직 추가.   
      32. 상품 추가/수정 모달과 상품 목록 표에 ‘상품 설명’ 항목이 빠져있어서 추가. 상품 목록 표에 긴 텍스트가 들어가면 문제가 생기기 때문에, 일정 이상 길이는 팝오버 방식으로 확인할 수 있게 세팅.  
      33. 상품 마스터 추가 시에 ‘상품 상태’는 DB 기본값으로 처리되어 API로 넘길 필요가 없음. 상품 추가 모달에서는 ‘상품 상태’ 입력창 나오지 않도록 수정.  
      34. 상품 추가 모달과 API가 연동되는지 테스트해봤는데 연동이 안됨. 확인해보니 API 요청할때 @ModelAttribute 방식으로 넘기는게 문제였음. post API에 @RequestBody로 세팅되어 있는 부분에 맞춰 수정 후 정상작동 확인.  
      35. 상품 추가/수정 모달의 ‘기본 가격’과 ‘할인율’에 단위가 표시되도록 수정.  
      36. 이미지url을 여러개 저장하는 형태가 될거라서, 이미지url을 원하는만큼 넣을 수 있도록 입력필드를 추가 생성하거나 삭제할 수 있는 로직으로 수정. 디자인이 어색하거나 이상한 부분들 깔끔하게 정리. antd 기능의 css를 어떤식으로 수정해야 제대로 적용되는지 파악하는데 많이 애를 먹긴했지만, 일단 원하는 디자인에 가깝게 수정 완료.  
      37. 현재까지 구현한 상품 추가 모달로 상품 마스터 추가 기능 테스트. 정상 작동 확인.  
      38. 상품 수정 모달 작업 시작.  
      39. ‘판매 상태’ 항목이 정상 출력되지 않는 오류 수정. 백엔드 상품 마스터 수정 API 엔드포인트와 연동되도록 로직 수정. ‘이미지 URL’ 항목에서 입력창을 1개 이하로 줄일 수 없는 이슈와 0개가 되면 항목 타이틀이 사라지는 이슈 수정. 브라우저에 메시지창이 제대로 출력되지 않는 이슈 해결.  
      40. 상품 수정 모달을 통해 상품 마스터 수정 API가 제대로 작동하는걸 확인. 하지만 상품 추가나 상품 수정을 한 이후에 페이지의 상품 목록 표가 갱신되지 않는 문제 발생. fetchProducts를 호출하는 순서를 바꾸고 상품 수정 후 전체 조회 조건에 맞추도록 수정하여 해결. 정상 작동 확인.  
      41. 상품 마스터 삭제 버튼 기능 작업 시작.  
      42. 소프트 딜리트 방식을 적용하고 있으므로, 상품 마스터 수정 API를 통해 DB값을 업데이트하는 로직 세팅. 프론트엔드에서는 정상 삭제 되었다는 메시지가 나오는데 정작 DB값은 변하지 않는 문제가 발생. 원인은 백엔드 API에 필요한 정보를 프론트엔드가 넘기지 못하는걸로 확인되어, 백엔드 API 로직을 확실히 비교하며 프론트엔드 코드 수정. DB값이 정상적으로 반영되는걸 확인. 하지만 전체 조회가 새로고침되어도 삭제된 정보가 불러와지는 문제 발생. 매퍼 코드에 삭제여부로 필터링하는 로직이 없기 때문인걸 확인하고 수정. 그리고 컨트롤러에서 예외처리 로직에 구멍이있는게 발견되어 겸사겸사 수정. 이제 상품 마스터 삭제 버튼이 정상 작동하는걸 확인.  
      43. 상품 목록 페이지의 표에서 ‘이미지’ 칼럼의 이미지가 제대로 표시되지 않는게 거슬려서 로직 체크. 원인은 \<Image\>태그에는 url로 이미지를 로딩하는게 안되기 때문이었는데, 원래 계획대로 url로 이미지를 로딩하려면 \<Iframe\> 태그를 써야하는데 요즘엔 보안이슈로 막기도 해서… 아무래도 계획을 근본적으로 바꿔야할듯. 어떻게 할까 고민하다가, 어차피 포트폴리오 작업이니 서버에 이미지를 저장하고 불러오는 클래식한 방안이 최선이라는 결론에 도달. 이미지 불러오는 로직 수정하고, 테스트와 오류 피드백 과정을 거쳐  정상작동 확인.  
      44. 이미지를 url로딩이 아니라 파일 저장 방식으로 전환하기로 했으니, ‘상품 추가/수정’ 모달의 이미지 관련 로직을 변경해야 함. 프론트엔드 로직 수정하면서 이미지 저장 API가 필요하다는걸 알게 됨. 백엔드 ProductController.java에 이미지 업로드 API 추가하고 application.properties에 설정 코드 추가하고 WebConfig.java 파일을 새로만들어 설정 코드 추가. 이미지 저장 폴더 루트를 리액트 프로젝트 기본 폴더를 상정했었으나, 백엔드 프로젝트를 통해 저장하게 될거라 이미지 저장 폴더 루트를 백엔드 프로젝트 기본 폴더에 맞게 수정.  
      45. 이전 수정 작업 후, 정상 작동하는지 테스트 돌입. 일단 상품 수정 모달의 이미지 업로드 항목에 이미지 파일을 넣고 동작을 시켜봤더니 이미지 파일이 들어가는 fileList 변수가 배열이 아니라고 오류가 나옴. 이미지 파일이 fileList 변수에 배열로 들어가게 코드를 짰는데 뭔소린가 싶어 분석해보니, 로직 처리 순서상 배열 요소를 넣기도 전에 초기 렌더링 시점에 배열이 아니면 오류 판정을 내는거였음. 따라서 fileList가 초기상태이거나 비어있을때 빈 배열이 되도록 명시하는 코드 추가. 이렇게 수정했는데도 같은 오류가 나와서, 컴포넌트끼리의 상호작용 문제가 의심되어 Upload 컴포넌트의 onChange 이벤트 핸들러를 인라인으로 구현하는 방식으로 수정. 이제 더이상 모달에 이미지 파일을 넣을때 오류가 발생하지 않음.  
      46. 모달에 이미지 파일을 넣는건 문제없어졌으니, 이미지 파일을 백엔드에 저장하는 API가 작동하는지 테스트 돌입. API 호출시 500에러가 발생. 분석해보니 프론트엔드에서 API를 처리하는 함수를 만들때 이런 기능을 추가할지 몰라서 헤더 옵션을 지원하지 않는 기본형에 가깝게 선언했던게 문제였음. useCallback이 받는 매개변수로 options를 추가하면서 로직 정리. 이제 이미지 파일을 백엔드에 저장하는 API가 정상 작동하는걸 확인.  
      47. 그런데 백엔드 폴더에 저장된 이미지 파일 뿐만아니라, 초반에 리액트 프로젝트 폴더에 저장했던 이미지 파일까지 문제없이 출력되는 상황. 이미지 파일은 백엔드 폴더에만 저장하고 불러오는 세팅이라, 다른 루트의 이미지 파일이 불러와지면 나중에 문제가 생길 수 있음. 일단 원인은 리액트 개발 서버와 스프링 백엔드 서버가 같은 경로 패턴을 사용하고 있기 때문이고, 그걸 명확히 구분하지 않는 헐거운 로직으로 되어있어서인걸로 파악. 따라서 이미지 파일을 불러올때 전용 API로 불러오도록 백엔드에 API 로직을 추가하고, 프론트엔드에서 해당 API를 요청하여 이미지 파일을 불러오도록 수정. 이걸로 백엔드의 특정 루트에서만 이미지 파일이 불러와지는걸 확인.  
      48. 상품 목록 페이지의 표에서 ‘품목 관리’ 버튼 기능 구현 시작. 상품 품목만 조회하는 API가 없었어서, productId로 productItems 테이블의 상품 품목을 조회하는 API 세팅하고, 프론트엔드의 ‘품목 관리’ 버튼에 모달 등 관련 로직 구현. ‘품목 관리’ 버튼 정상 작동 확인.  
      49. 품목 관리 모달의 디자인 수정. 닫기 버튼 추가, 타이틀 상단 중앙 위치, 해당 상품 품목 정보 텍스트 정리.  
      50. 상품 품목 관리 모달의 ‘품목 추가’ 버튼 기능 구현 시작. 품목 추가 API는 세팅된게 있어서, 프론트엔드에 관련 코드 추가. 품목 추가 모달에서 닫기 버튼으로도 안나가지고 모달 영역 외 클릭에도 안나가지는 문제가 있어서 수정. 품목 추가 자체는 문제가 없으나, 품목 추가 후 모달이 자동으로 안닫히는 문제가 있어서 수정.  
      51. 품목 추가 모달로 품목 추가 후 데이터를 검토하는데, 비활성으로 추가했지만 활성으로 DB에 저장된 문제를 확인. API 처리시 백엔드에도 오류가 없었고 프론트엔드에도 오류가 없었던걸 보면, 뭔가 누락이 있는 듯. 검토해보니 실제로 상태에 해당하는 isActive관련 코드가 프론트엔드와 백엔드에 빠져있어서 추가. 정상 작동 확인.  
      52. 상품 품목 관리 표에서 ‘삭제’버튼이 작동하지 않는 문제 확인. 검토해보니 상품 품목을 조회하는 API에서 version 칼럼을 불러오는걸 누락한게 확인 됨. 수정 후 정상 작동 확인.  
      53. 상품 품목 관리 모달의 ‘수정’ 버튼 기능 구현 시작. 품목 수정 API는 세팅된게 있어서, 프론트엔드에 관련 코드 추가. 정상 작동 확인.  
      54. 상품 품목 관리 표의 디자인에 수정할 요소가 많아서 수정 진행. 상태 칼럼의 태그 정렬이 이상한거 수정. 모바일 환경에서 칼럼들 폭이 이상한 부분 수정. 가로 스크롤시 첫 3열 고정되도록 수정.  
      55. 상품 목록 표의 ‘상품 ID’ 칼럼의 기본 정렬기능이 작동하지 않는 문제 확인. 숫자 값 정렬 코드를 써야하는데 문자 값 정렬 코드를 썼던거라 수정 후 정상 작동 확인.  
      56. ‘카테고리 관리’ 페이지 구현 시작. 페이지 초안 코드를 만들고, 백엔드에 API 만들어놓은게 있어서 프론트엔드에 연결. 카테고리는 antd의 tree를 사용. DB의 카테고리가 정상 출력되는걸 확인  
      57. 카테고리 트리 디자인이 엉성해서 수정 시작. 전체적인 정렬을 깔끔하게 하고, 최대 폭 길이를 제한해서 빈 공간을 최소화하고, 카테고리 클릭시 아무 기능없이 하이라이트만 되는걸 하이라이트 효과 빼고 클릭했을때 하위 카테고리가 전개되도록 수정.  
      58. 카테고리 수정 버튼 기능 체크. 정상 작동 확인.  
      59. 카테고리 추가 모달 기능 체크. 작동이 안되는걸 확인. 원인을 검토하다보니, 백엔드 작업 초기에 세팅한 API들의 컨트롤러 단계에서 ResponseEntity\<?\>가 적용이 제대로 안된 것들을 발견. API 코드 전수 검토 후  카테고리 추가 API, 카테고리 수정 API, 상품 마스터 등록 API, 상품 마스터 수정 API, 상품 품목 등록 API, 상품 품목 수정 API, 상품 품목 단일 입고 API, 상품 품목 대량 입고 API, 회원 가입 API, 회원 일반 정보 수정 API, 회원 비밀번호 수정 API, 회원 탈퇴 API, 비밀번호 분실 이메일 발송 API, 비밀번호 분실후 재설정 API 수정.  
      60. 상황이 카테고리 추가 기능보다 기초적인 부분에 부족한건 없는지 체크하는게 더 급해보여서, 전반적으로 재검토. DB의 카테고리 테이블의 ‘code’칼럼이 프론트엔드에서 다뤄지지 않아서, 관련 코드 추가. 그리고 카테고리 추가/수정 모달에서 ‘상위 카테고리 선택’ 항목을 ‘카테고리 코드’ 항목보다 먼저 위에 오도록 교체. depth가 있는 카테고리 구조상 \<select\>로는 표시의 한계가 있어, \<cascade\>로 전면 수정. 그리고 ‘상위 카테고리 선택’항목에서 특정 카테고리를 선택하면 상위카테고리 코드가 자동으로 ‘카테고리 코드’ 항목에 출력되도록 적용.  
      61. 이제 카테고리 추가 기능 문제를 검토. API 서비스 단계에서 DAO로 넘기는 변수를 정리하는 로직에 문제가 있어서 수정. 카테고리 추가 기능 정상 작동 확인.  
      62. 카테고리 삭제 버튼 기능 체크. 삭제 기능에 삭제 API를 새로 만들지, 아니면 기존의 수정 API를 활용하여 소프트 딜리트를 적용할지 고민. 소프트 딜리트를 적용하기로 결정하고 DB 테이블, VO, 매퍼, DTO 등 수정. 카테고리 삭제 기능 정상 작동 확인.  
      63. 이번에 AdminCategories.js 세팅을하면서 프론트엔드가 API 결과로 백엔드의 메시지를 받도록 만드는게 맞는거 같아서 그렇게 작업함. 이 방향성에 맞게 기존의 AdminProducts.js도 수정.  
      64. 사이드 메뉴의 다음 순서인 ‘재고 관리’ 관련 페이지 제작. 제작하면서 가만히 생각해보니 뭘 기준으로 조회할지가 문제라고 생각됨. 재고는 상품 품목을 상위 단계로 가지는데, 특정 상품 품목의 재고 정보를 조회하기 위해서는 결국 특정 상품 품목을 선택하는 과정을 가져야함. 그런데 선택을 위해 검색을 통하면 관리자 입장에서 검색어가 굉장히 애매해지고, 그렇다고 특정 상품 마스터\>상품 품목 depth를 통해 선택하게하려면 이미 만들어놨던 ‘상품 목록’ 페이지의 기능과 겹쳐서 비효율적임. 고민하다가 ‘상품 목록’ 페이지의 ‘품목 관리’ 모달에 재고 관련 모달 접근 버튼을 추가하는 방향으로 정리.  
      65. 상품 품목 관리 모달의 품목 표 ‘작업’ 칼럼에 ‘재고 관리’ 버튼 추가하고, 버튼에 모달 구현하여 연결. product\_inventories 테이블 조회하는 API와 연동하여 재고 목록 표 출력 로직 세팅. 정상 출력 확인. 모달 상단 디자인이 어수선해서 깔끔하게 정리. 재고 목록 표 정렬이 마음에 안들어서 ‘바코드’ 칼럼을 기준으로 내림차순 정렬되도록 수정.  
      66. 재고 관리 모달의 ‘입고 처리’ 버튼 기능 구현 시작. 모달 만들어서 바코드만 입력하면 DB에 추가되도록 API 연결. 줄바꿈을 기준으로 여러 바코드도 한번에 입고되도록 세팅. 입고 처리 기능은 정상작동하는데, 정상 완료 후에 모달창이 자동으로 안닫긴다던지 재고 목록이 새로고침 안된다던지 추가 입고 처리를 위해 모달에 재접근하면 전에 입력했던 내용이 입력창에 그대로 남아있다던지 하는 이런저런 문제 발생. 전부 제대로 작동되도록 수정. 단일 입고 및 대량 입고 처리 정상 작동 확인.  
      67. 재고 관리 모달에서 부족한 부분 보강. 처음 모달 띄울때 DB에서 조회하는동안 로딩화면이 출력안되는 부분을 수정, DB 해당 테이블의 status에 ENUM에 맞춰 표의 ‘상태’ 칼럼 출력 코드를 수정, 특정 상태만 골라서 볼 수 있게 ‘상태’ 칼럼에 필터 기능 추가, 조회된 재고 목록에서 상태별로 몇개씩 존재하는지 나타내는 요약 태그 세트 추가, 모바일 환경에서 타이틀 텍스트가 너무 크고 타이틀 영역의 패딩이 너무 두꺼워져서 타이틀 텍스트는 화면 크기에 따라서 폰트 크기가 자동조절되도록 수정하고 타이틀 영역은 모바일 환경에서 패딩과 마진이 축소되도록 수정, 모달이 세로로 길어지면 뷰포트를 넘어가면서 뷰포트 스크롤이 생겨버려서 모달 세로 길이 상한을 뷰포트 안넘어가게 설정하고 모달 자체 스크롤이 생기도록 수정,   
      68. 이전 수정 중 모달 세로 길이 상한 및 스크롤 세팅한걸 모든 모달에 적용되도록 수정.   
      69. 입고 처리 모달의 바코드 입력창의 기본 높이가 낮다고 생각해서 수정. 그리고 사용자가 줄바꿈 외에 쉼표나 마침표 같은걸 섞을 가능성이 있다고 생각해서, 입력 규칙을 세팅.  
      70. ‘이력 조회’ 버튼을 임시로 상품 품목 관리 모달에 달아놨었는데, 기능 구현을 하기 전에 고민해보니 재고 관리 모달에 들어가는게 자연스럽겠다는 결론에 도달. 버튼 위치 이동하고 재고 이력 테이블 조회 API 새로 만들어서 연동하여 로직 구현. 이력 조회 버튼 기능 정상 작동 확인. 이력 조회 버튼을 옮기면서 \<Table.Summary\> 출력 결과의 오른쪽 끝 정렬이 틀어져서 수정.   
      71. 재고 관리 모달에서 ${selectedProductItem?.size} / ${selectedProductItem?.color} 텍스트가 정상 출력되지 않아 로직 보강.  
      72. AdminProducts.js와 AdminCategories.js에 ESLint 경고가 있는 useEffect에 콜백 세팅으로 경고 해결하고 간단하게 코드 정리.  
      73. 관리자 페이지 사이드 메뉴 초안과 현재 구성이 달라져서, 사이드 메뉴 재구성 고민. 재고 관리 쪽 기능이 상품 목록 페이지로 통합되어 삭제되어야하는데, 그렇게되면 ‘상품 관리 \> 상품 목록 / 카테고리 관리’ 이렇게 되는게 애매함. 어차피 ‘상품 목록’ 페이지명이 콘텐츠를 제대로 반영하고 있지 못하다고 느끼던 중이었어서, ‘상품 목록’ 페이지를 ‘상품 관리’ 페이지로 바꾸로 ‘카테고리 관리’ 페이지를 ‘상품 관리’ 페이지에 모달로 편입시키는게 낫다는 결론에 도달.  
      74. 일단 사이드 메뉴 구성을 정리된대로 수정. ‘재고 관리’ 메뉴 삭제하고 상품 관리에 하위 메뉴를 없애고 기존 ‘상품 목록’ 페이지를 연결.  
      75. 기존 ‘카테고리 관리’ 페이지의 코드를 ‘상품 관리’ 페이지에 모달로서 적절히 변환하여 삽입. 로직이 꼬이는 부분 찾아서 수정.  
      76. 카테고리 관리 모달의 ‘카테고리 추가’ 모달과 ‘카테고리 수정’ 모달의 API 요청이 500 오류가 나는 상황. 추적해보니 매퍼쪽 SQL 코드에 문제가 있어서 수정. 추가로 이것저것 API 테스트하다보니, 전에 카테고리 테이블에 소프트딜리트 방식을 적용한게 문제가 될 여지를 발견. 그래서 정통적인 삭제 로직 API를 추가하고, 그에 맞춰 기존 API 로직 수정. 최종적으로 카테고리 추가/수정/삭제 기능 정상작동 확인.  
      77. 상품 관리 페이지와 모달의 디자인 정리 작업. 상품 관리 페이지 상단의 ‘타이틀 텍스트, 카테고리 관리 버튼, 상품 추가 버튼’ 순서를 ‘카테고리 관리 버튼, 타이틀 텍스트, 상품 추가 버튼’ 순서로 보기좋게 조정. 순서 조정 후 모바일 환경에서 상대적으로 버튼이 차지하는 영역이 많아서, 모바일 환경일때 버튼 크기와 버튼 텍스트 크기가 축소되도록 수정. 카테고리 관리 모달의 헤더 영역이 엉성해서 재배치로 정돈. 모바일 환경에서 카테고리 관리 모달의 카테고리 추가 버튼이 너무 커서 작아지게 수정. 모바일 환경에서 카테고리 관리 모달의 트리 영역이 너무 커서 모달 영역 밖으로 나가는 문제를 수정. 카테고리 추가/수정 모달에서 카테고리 선택 항목의 안내 경고문을 적절한 위치로 이동.  
      78. AdminProducts.js에서 ‘추가/수정’ 조건에 따라 API 요청이 달라지는 로직 들의 코드를 삼항 연산자로 대폭 줄일 수 있어서, 관련 로직 코드 수정.  
      79. 주문 관리 페이지 제작 시작. 이미 만들어놓은 백엔드 API와 연동하여 조회 및 검색 기능 구현. 초안으로 만든 검색 영역이 뷰포트에서 배치가 마음에 안들어서 한 줄로 깔끔하게 배치되도록 수정.  
      80. 주문 검색 조건을 구현하다보니, 백엔드 주문 검색 조회 API를 만들때 프론트엔드에서 필터링이 안될거라 생각하고 만들었었는데… 프론트엔드에서 필터링이 되는 프레임워크를 쓰면서 백엔드 코드를 보니 비효율적으로 느껴짐. 프론트엔드에서 가능한 기능은 백엔드 로직에서 빼서 코드 효율성을 높이고 싶어서, 코드 수정 작업 시작. 수정 후 생긴 문제들은 추적 후 해결. 정상 작동 확인.  
      81. 주문 조회 API의 결과 항목 중 ‘회원 아이디’를 조회하도록 실수한 것을 ‘회원 이메일’을 조회하도록 수정. 검색창에 검색어를 입력하면 실시간으로 갱신되는 문제가 있어서, 검색버튼을 눌렀을때 갱신하도록 수정.  
      82. 주문 관리 표의 칼럼 구성과 내용 구성 최적화에 대해 고민. 특히 주문 마스터 하나에 여러 주문 상품이 있는 구조이고 ‘주문상태’항목이 주문 상품과 묶여있다보니, 표 하나에 깔끔하게 출력하기에 굉장히 애매한 상황. 다행히 atnd의 표는 셀 병합이 가능해서, 주문 마스터의 항목들을 셀 병합하여 디자인 정리가 됨. 주문 마스터의 항목들을 왼쪽으로 몰고 주문 상품들을 묶을때 셀 병합으로 표현하고, 주문 상품의 항목들을 오른쪽으로 몰아넣는 코드 구현. 주문일자 칼럼 내용이 DB값을 그대로 가져오면 애매해서, 년월일까지 정리해서 출력하도록 수정. 주문상품 칼럼 내용에 상품명이 안나와서 백엔드 API 로직을 수정하여 가능하도록 수정.  
      83. 주문 관리 표를 만지다보니 현재 atnd 표 자체의 칼럼 정렬기능에 구멍이 있음을 발견. 경량화한 DB SQL 로직에서는 한번 조회할때 페이지 단위로만 데이터를 읽어오는데, 그 상태에서 프론트엔드 칼럼 정렬 기능을 쓰면 전체 데이터에서 정렬되는게 아니라 한 페이지 분량 데이터에서 정렬되는 문제가 있는 것. 따라서 프론트엔드 칼럼 정렬 조건을 DB로 넘기면, DB에서 그걸 받아서 전체 데이터에서 정렬조건을 맞춘다음 페이지 단위로 끊어서 응답하는 로직으로 보강.  
      84. orderMapper에서 반복해서 쓰이는 코드들을 압축함.  
      85. 주문 마스터 정보에서 주문번호를 DB의 단순 자동증가인 order\_id값으로 넣다보니 굉장히 어색함. 쇼핑몰 이용해본 경험을 떠올려봤을때는 별도의 주문번호 값을 만드는게 아닐까 생각함. 그래서 order\_number 칼럼을 추가하고, 년월일+랜덤값을 부여하는 로직 추가. 이에 영향을 받는 로직들을 전부 수정 및 추가.  
      86. 검색 테스트를 해보니, 검색창이 비어있을때 검색 버튼을 누르면 아무것도 조회되지 않는 문제 발견. 매퍼의 로직에 구멍이 있던거라 수정. 정상 작동 확인.  
      87. 주문 상세 정보 모달 구현. 지금까지 통일한 모달 디자인과 동일하게 맞춤. ‘상세보기’ 버튼이 주문 마스터 기준으로 달리도록 셀 병합 로직 세팅. 정상 출력 확인.  
      88. 주문 관리 표에서 주문 번호와 주문 이메일 텍스트를 클릭하면 자동 검색 가능하도록 로직 수정. 기능은 작동하지만 시각적 피드백이 부족해서, 하이라이트 효과가 들어가도록 보강. 정상 작동 확인.  
      89. 주문 상세 정보 모달의 표 디자인이 애매함. 셀 내용이 한줄로 표시되도록 하여 높이를 줄이고, 굳이 표마다 타이틀이 들어갈 필요가 없어보여서 타이틀 삭제하여 압축.  
      90. 주문 상세 정보 모달의 주문 상품 표를 최적화. ‘상품명’ 칼럼 추가, ‘상태’ 칼럼 추가, ‘상태’ 칼럼에는 주문 변동 이력 테이블에서 가져온 데이터로 상태 변동이력을 모두 출력하는 로직 추가.  
      91. 주문 상세 정보 모달의 주문정보 Descriptions에서 ‘수령인’, ‘연락처’, ‘배송지’, ‘배송 요청사항’이 출력안되는 상태. 모달의 랜더링 코드의 문제인걸 발견하고 수정. 정상 출력 확인.  
      92. 주문 상세 정보 모달의 주문정보 Descriptions이 내용에 따라 모양이 망가지는 문제 발생. 코드 정리하고, 현재 한 줄에 3개 이상의 항목이 나열될 수 있는 부분을 최대 2개 항목까지만 나열되도록 수정.  
      93. 백엔드 로직들을 검토하다보니 이번에 orders 테이블에 추가한 orderNumber 칼럼이 기존의 merchantUid 칼럼과 겹치는 역할을 하고 있다는걸 깨달음. orderNumber와 관련된 코드를 전부 merchantUid로 전환하고, orderNumber 칼럼 삭제. 대신 생성 로직은 orderNumber가 더 최적이라서 merchantUid 생성 로직에 덮어씌움.  
      94. 이번에 수정한 주문 상세 정보 모달의 주문 상품 표 ‘상태’ 칼럼 코드가 제대로 작동하는지 확인하기 위해, 새로운 주문 생성 필요. postman으로 시도하는데 그동안 수정하거나 추가한 로직 중에 문제가 있어서 오류 발생. 하나씩 추적해서 차근차근 해결하고, 주문 생성 API 정상 작동 확인. ‘상태’ 칼럼 코드 정상 작동 확인.  
      95. 프론트엔드 로직 검토하면서 DB를 계속 보다보니, order\_product\_histories 테이블이 생기기전에 만들었던 order\_products 테이블의 DeliveryConfirmDate 칼럼이 전혀 필요없어짐을 깨달음. DeliveryConfirmDate 칼럼과 연관된 코드를 삭제.  
      96. 주문 상세 정보 모달에서 배송비 정보를 포함하도록 로직 보강.  
      97. 주문 상품 상태에 따라 처리해야할 작업의 버튼 로직을 구현하려고 DB를 검토하다보니, 주문 상품 상태에 ‘결제 완료’가 누락된걸 확인. 주문 상품 테이블 상태 칼럼 ENUM에 ‘결제 완료’ 추가하고, 관련 로직들 전면 수정. 수정하는 김에 포트원 결제를 통해 결제완료 처리되는 기존 로직 이외에 예외상황을 대비한 관리자 전용 결제완료 처리 API 로직 추가.  
      98. 주문 상세 정보 모달에서 주문 상품 별로 현재 상태에 따른 작업 버튼 자동 연결 로직을 구현하려고 코드들을 검토하고 시뮬레이션해봤는데, 아무리 생각해도 관리자가 주문 업무를 처리하기 위해 일일히 주문 상세 정보 모달을 열어야하는건 비효율적으로 느껴짐. 만약 수백건의 작업을 처리해야한다면 주문 상세 정보 모달을 수백번 열어야한다는 뜻이니까. 따라서 작업 버튼은 주문 상세 정보 모달이 아니라 주문 관리 메인 페이지에 있어야 맞겠다는 결론이 남.  
      99. 앞서 정리된 내용에 따라, 주문 관리 메인 페이지에 주문 상품 별로 현재 상태에 따른 작업 버튼 자동 연결 로직 세팅 시작. 상태에 따라 연결되어야하는 API들은 이미 만들어놨기 때문에, 거기에 맞춰 필요한 코드 세팅. 작업 버튼을 어떤 식으로 디자인에 녹여내서 출력시키는게 좋을지 고민을 많이 했는데, 일단 주문 상태 태그에 오른쪽 화살표와 함께 작업 버튼을 출력하는 방안으로 잠정 결정. 표에 자연스럽게 녹아들 수 있게 디자인 정리하고 시각적으로 클릭이 가능하다는걸 강조하기 위한 하이라이트 효과 적용.  
      100. 주문 관리 페이지에서 ‘주문 상태’ 필터링 시 선택한 상태와 같은 주문 마스터로 묶여있는 다른 상태의 주문 상품도 출력되는 중. 다른 상태의 주문 상품이 출력되지 않도록 로직 수정.   
      101. 주문 관리 페이지에서 주문 상태에 따른 관리자 작업 버튼 로직에서, 배송 정보를 입력해야하는 작업인 경우 배송 정보 입력 모달이 나오도록 모달 제작 및 코드 작성. 배송 정보 입력 모달에서 입력한 값으로 작업이 진행되도록 로직 생성. 현재 DB 테이블이 유기적으로 연결되는 로직이라서 더미데이터 몇개로 대충 확인이 가능한 상황은 아니라, 나중에 기능들이 대부분 구현되고 나면 제대로 테스트 예정.  
      102. 주문 상세 정보 모달에서 주문 상품에 따른 관리자 작업 기능이 옮겨진 상태라, ‘작업’ 칼럼 삭제. 대신 배송정보가 출력되어야하는데, 추가 모달이나 접이식 요소는 가독성을 해친다고 생각하여 칼럼에 출력하는 방식을 선택. orderProductId로 배송이력 테이블을 조회하는 API를 만들고, 프론트엔드에서 연동하여 타임라인 양식으로 ‘배송 정보’ 칼럼에 출력되도록 코드 작성. 더미데이터 넣어서 출력 테스트하여 일단 통과.  
      103. 주문 관리 페이지가 어느정도 정리되어, 코드 검토하여 다듬거나 압축할 부분 수정/보완.  
      104. 주문 관리 페이지 코딩을 하면서 주문 내역 조회 API 로직을 바꿨으니, 대시보드 페이지에 해당 로직이 꼬였을거라 추측. 확인해보니 역시 오류 발생 중. 작동하도록 수정하다가 주문 관리 페이지 쪽까지 꼬이는 해프닝이 있었지만, 백엔드 API 로직 중 엉성한 부분을 이번에 발견하게 되어 확실하게 수정하면서 결과적으로 정상작동 확인. 그리고 대시보드 페이지 최근 주문 내역 표의 상태 칼럼 최신화.  
      105. 상품 관리 페이지의 상품명 검색창 배치 수정. 상품명 검색이 안되는걸 확인하고, 원인을 찾아 수정. ‘상태’ 칼럼의 필터링시 선택 하이라이트 가독성이 엉망이라 수정.  
      106. 주문 관리 페이지의 ‘주문번호 검색’창과 ‘회원이메일 검색’창에 입력값을 한번에 지우는 버튼 추가.  
      107. 대시보드 페이지에서 정돈되지 않은 디자인이 많아서 수정. header, footer 영역 최적화. 불필요한 높이로 비효율적이었던 부분들의 코드 수정. 모바일 환경에서 최근 주문 내역이 뷰포트를 뚫고 내려가는데 스크롤도 안되는 문제가 있어서, footer를 가리지 않으면서 스크롤이 되도록 수정. ‘주문번호’가 orderId가 아니라 merchantUid에서 가져오도록 수정.  
      108. 대시보드 페이지의 최근 주문 내역을 불러오는 코드에서 조회수를 지정하는 size 값을 이것저것 넣어보면서 테스트하는 도중 알게됐는데, size 값이 ‘주문 마스터 수’를 기준으로 작동하는게 아니라 ‘주문 품목 수’를 기준으로 작동하고 있었음. 이러면 문제가 되는게 내 세팅에서 통상의 ‘주문 수’와 개념이 일치하는건 ‘주문 마스터 수’이기 때문. 따라서 매퍼 코드를 수정하여 size가 ‘주문 마스터 수’와 일치하도록 조정. 주문 관리 페이지에도 쓰이는 API라서 수정 후 작동에 문제가 있는지 테스트해봤을때는 일단 문제없었음.  
      109. 레이아웃에서 데스크탑 환경과 모바일 환경 모두 사이드 메뉴 폭을 줄여서 최적화. ‘관리자 페이지’ 타이틀 정렬 틀어진거 조정.  
      110. 대시보드 페이지 최근 주문 내역 표에서 ‘상세보기’ 칼럼을 임시로 만들어놨던걸 어떻게 할까 고민해보고 삭제하기로 결정. 어차피 주문 관련 조회나 업무는 주문 관리 페이지에서 할 수 있게 세팅되었으므로, 대시보드 페이지에 관련 기능이 있는건 의미가 없다는 결론. 삭제 완료.  
      111. 회원 관리 페이지 제작 시작. 회원 조회 API 로직을 백엔드에 만들고, 이와 연동하는 프론트엔드 표 제작. 조회 출력이 이상해서 원인 검토 후, 다소 고생했지만 해결. 표 칼럼에 뭘 넣고 뺄지 정리하고, 상세정보 모달 제작. 상세정보 모달에 ‘주문 내역 보기’ 버튼을 추가하고, 누르면 주문 관리 페이지로 넘어가 해당 이메일로 자동검색하는 로직 적용. 테스트하여 문제생기는 부분 수정하고, 최종 정상 작동 확인.  
      112. 주문 관리 페이지의 검색창 라인의 정렬이 애매한걸 확인. 좌우 폭에 유동적으로 반응하여 골고루 정렬되도록 수정. 검색 창 순서도 더 자연스럽게 조정.  
      113. 미뤄뒀던 대시보드 페이지의 ‘총 리뷰 수’ API 오류 수정 작업. 총 리뷰 수를 조회하는 API 로직을 백엔드에 새로 만들어서 연결. 테스트하면서 보니 프론트엔드 코드가 좀 꼬여있어서 수정. 정상출력 확인.  
      114. 상품 관리 페이지의 ‘onFilterDropdownOpenChange’관련 오류 해결.  
      115. 회원 관리 페이지의 상세 정보 모달 항목들이 단순 텍스트로 출력되고 있는데, antd의 Description를 사용하여 깔끔하게 출력되도록 수정.  
      116. 회원 관리 페이지의 상세 정보 모달 ‘상태’ 항목의 현재 상태에 따라 ‘활성화/비활성화’ 중 자동으로 적절한 버튼이 출력되는 로직을 구현. 백엔드에 회원 상태만 변경하는 API로직을 구현하여 버튼에 연동. 버튼의 디자인을 어떻게 해야 적절할지 이런저런 테스트 후 결정. 버튼 기능 정상 작동 확인.  
      117. 회원 관리 페이지의 상세 정보 모달에 로그인 기록을 포함시키는게 좋겠다는 생각이 듦. 회원정보 세트와 주문내역보기 버튼 사이에 표로 출력하는 방식으로 결정. 백엔드에 로그인 기록 조회 API 로직 구현하고, 상세 정보 모달에 만든 표와 연동. 정상 작동 확인. 추가로 IP 주소 마스킹 로직 만들어서 적용.  
      118. 주문 관리 페이지의 상세 정보 모달에 ‘주문 이메일’ 정보가 누락된걸 확인. Description 세트에 ‘주문 이메일’ 항목 추가.  
      119. 리뷰 관리 페이지 제작. 페이지 구성에 맞춰 코딩하고, 백엔드의 리뷰 조회 API와 연동. 발생하는 문제들 해결하고 정상 출력 확인.  
      120. 리뷰 관리 페이지 표 정리. ‘회원 ID’ 칼럼을 ‘회원 이메일’ 칼럼으로 변경하고 로직 수정. 리뷰 조회 API에서 회원 이메일과 상품명을 불러오도록 로직 수정.’ 작성일’ 칼럼에 시간은 표시 안되도록 수정. 칼럼 폭이 유동적으로 조절되도록 고정값 해제. 평점 칼럼의 \<Rate\> 출력 사이즈 축소.  
      121. 리뷰 관리 페이지 상세보기 모달 검토. 우상단 X버튼이 스크롤에 가리는 문제 있음. 스크롤 위치를 내려서 해결.  ‘리뷰 삭제’ 버튼 작동 안되는 문제 있음. 작동되도록 수정. 상품 ID와 같이 상품명도 출력되도록 수정. ‘상품 보기’ 버튼을 클릭했을때 상품 관리 페이지로 넘어가서 해당 상품이 자동 검색되는 로직 추가. 상품 관리 페이지로 넘어가서 자동 검색되는 로직이 꼬여서 좀 고생했지만 최종적으로 정상 작동 확인.  
      122. 리뷰 관리 페이지 검색창 검토. 검색창 폭이 너무 넓어서 최대/최소값 세팅. 입력창에 키워드를 입력하면 실시간으로 조회되는 문제가 있어서, 검색 버튼을 눌러야만 조회하도록 수정. 입력창 왼쪽에 드롭다운 버튼으로 ‘상품 ID’와 ‘회원 이메일’ 중 선택해서 검색할 수 있게 로직 수정. 표의 상품 ID 칼럼값이나 회원 이메일 칼럼값을 클릭하면 바로 검색하는 로직 적용.  
      123. 주문 관리 페이지에 ‘주문 번호’ 검색창과 ‘주문 이메일’ 검색창이 따로 있는데, 리뷰 관리 페이지처럼 드롭다운으로 선택할수 있게 수정. 이후 표에서 값을 선택해서 자동 검색하는 로직이 꼬여서 해결.  
      124. 리뷰 관리 페이지 날짜검색창 검토. 날짜를 입력해도 작동을 안해서 정상작동하는 주문 관리 페이지의 로직으로 수정했으나, 여전히 작동을 안하는 문제 발생. 원인이 안찾아져서 고생을 많이 했는데, 결과적으로 매퍼쪽 코드를 수정하는걸로 해결.  
      125. 주문 관리 페이지와 리뷰 관리 페이지의 날짜검색창 효과가 검은색과 짙은 회색이라 시각적으로 안좋음. 지금까지의 하이라이트 효과 세팅과 일치감이 있도록 수정. 주문 관리 페이지의 검색키워드 조건 선택창에도 하이라이트 설정 적용.  
      126. 결제 관리 페이지의 검색조건을 입력하면 검색버튼을 누르기 전에 실시간으로 조회되는 문제가 있음. 검색버튼을 눌러야 작동하도록 수정. 이후 결제번호값이나 주문번호값을 클릭하여 자동검색하는 로직에 영향이가서 자동검색이 안되는 문제 발생. 코드 수정하여 해결.  
      127. 결제 관리 페이지의 상세모달을 기존에 만들었던 모달들의 설정과 동일하도록 맞춤. 내부 요소 디자인을 적절하게 수정. ‘해당 주문 바로가기’ 버튼을 만들고, 클릭하면 주문 관리 페이지로 넘어가서 자동검색하는 로직 세팅.  
      128. 결제 내역 테이블 조회 API를 수정했던 여파로 대시보드 페이지에 오류가 생겨서, 정상출력되도록 수정.  
      129. 관리자 페이지 로그아웃 시 로그인이 필요하다는 메시지가 두 번 출력되는 문제가 있어 원인 추적. 알고보니 AdminLayout.js와 AdminDashboard.js 에 중복된 로직이 있기 때문이어서, AdminDashboard.js의 로직은 삭제. 정상작동 확인.  
   5. 메인 홈페이지 작업  
      1. 페이지 내용이 뷰포트 아래로 넘어가는데 스크롤이 안생기는 문제 있음. 헤더영역은 고정하고, 나머지 영역이 스크롤 가능하게 끔 수정.  
      2. 캐러셀을 사용한 배너 영역이 데스크톱 환경과 모바일 환경에서 크기가 크게 달라져서, 만약에 이미지만으로 배너를 세팅하는 경우 심각한 문제가 있어보임. 모바일 환경에서는 1x1 사이즈를 세팅하기 적절하니, 거기에 착안하여 모바일 환경에서는 1x1 사이즈 1개를 출력하고  데스크톱 환경에서 1x1 사이즈 3개를 동시에 출력하면 문제가 해결될거라고 생각. antd의 캐러셀은 마침 그런 기능을 구현할 수 있는 항목이라, 구상한대로 수정해 봄. 구상한대로 작동은 하지만, 배너가 2개 이하일때는 데스크톱 환경에서 배너 영역에 여백이 많이 생기는 문제가 발생. 캐러셀 스타일을 손보면서 디자인을 손보려해봤는데, 생각보다 쉽게 해결되지 않아서 곤란해짐. 일단 배너 3개를 고정으로 세팅하고 데스크톱 환경에서는 1x1 img 컴포넌트 3개를 동시에 출력하고 모바일 환경에서는 캐러셀 컴포넌트로 순환되게 하는 세팅으로 잠정 정리.  
      3. ‘쇼핑 카테고리’ 영역은 딱히 의미가 없는거 같아서 삭제. 대신 ‘새로운 상품’ 영역을 추가하여 ‘배너-새로운 상품-인기 상품’ 순서로 출력되는 구조로 수정.  
      4. ‘새로운 상품’과 ‘인기 상품’의 내용이 불러와지기 위해, 백엔드에 전용 API들을 세팅하고 연동. 텍스트 출력은 문제없었지만 이미지 출력이 안됐는데, 파싱 로직 구현해서 정상 출력 확인. 상품 이미지를 무신사에서 땡겨올 예정인데, 무신사 이미지는 분석해보니 가로세로 1:1.2 비율인걸 확인. 따라서 ProductGrid 컴포넌트의 이미지 출력 부분을 가로세로 1:1.2 고정되도록 수정. 사진 아래에 출력되는 상품 마스터 정보 중 ‘상세보기’ 버튼과 ‘장바구니’ 버튼 삭제하고, 누락된 원래가격과 할인율 정보가 출력되도록 수정.  
      5. 홈페이지 접속 시 콘솔 로그에 찍히는 오류들 수정 작업. prop이 DOM 요소로 전달되어 생기는 오류는 prop 이름 앞에 $ 기호를 붙여 transient props로 변경하여 해결. antd의 Menu 컴포넌트에서 children 대신 items prop을 사용하라는 경고는 Menu.Item을 직접 사용하는 대신 items prop을 사용하여 해결. Spin 컴포넌트의 tip 속성 오류는 tip 속성을 제거하고 다른 코드를 넣는걸로 해결.  
   6. 로그인 페이지 작업  
      1. 로그인 페이지 초안 제작. 이미 정상작동하도록 만든 관리자 로그인 페이지의 코드를 참고하여 로그인 로직 구현. 정상 작동 확인. UI 디자인이 더 자연스럽도록 다듬음. 다른 페이지에 연결되는 링크 텍스트를 파란색으로 수정, 비밀번호 찾기 링크 세팅, 검색창 최대폭 하향, 홈페이지로 가는 버튼 좌상단에 추가, 웹서비스명을 ‘로그인’ 텍스트 윗줄에 추가하고 푸터 영역 추가. 로그인 API 실패시 메시지를 백엔드에 세팅한걸 받도록 수정하고, 관리자 로그인 페이지도 이에 맞춰 수정.  
   7. 홈페이지 작업  
      1. 로그인 시 변하는 헤더 우상단의 구성이 '검색버튼-장바구니 뱃지-UserOutlined 버튼(마이페이지,로그아웃 드롭다운)-이메일명'으로 자연스럽지 않음. '검색버튼-장바구니(버튼이 아니라 텍스트 링크)-마이페이지(텍스트 링크)-로그아웃(텍스트 링크)'로 수정하여 개선.  
      2. 테스트 중 이전에 세팅한 ‘헤더 영영을 제외한 메인 콘텐츠 영역의 스크롤 설정’이 모바일 환경에서 검색창이 튀어나왔을때가 반영되지 않음을 발견. 해당 조건에서 가변적으로 메인 콘텐츠 영역이 적용되도록 수정.  
   8. 비밀번호 재설정 요청 페이지 작업  
      1. 로그인 페이지의 ‘비밀번호 재설정’ 링크 기능을 구현하기 위해 비밀번호 재설정 페이지 제작. 가입 메일 입력창과 백엔드에 이미 만들어놓은 API를 연동. 정상작동 확인.   
   9. 비밀번호 재설정 페이지 작업  
      1. 재설정 메일의 링크를 통해 접속할 수 있는 비밀번호 재설정 페이지 제작. 하지만 새 비밀번호를 입력하여 변경하려고하니 오류가 발생. 원인을 쉽게 찾아지지 않았지만 최종적으로 매퍼에서 version 칼럼이 추가된 이후 최신화가 되지 않은 코드가 있기 때문인걸로 확인. 수정 후 정상 작동 확인.  
   10. 회원가입 페이지 작업  
       1. 회원가입 페이지 제작. 백엔드에 만들어놓은 회원가입 API에 맞춰 입력창 세팅. 주소는 ‘우편번호’, ‘기본주소’, ‘상세주소’ 입력창을 만들고 다음맵 API와 연동. 주소 검색창 팝업은 정상작동하는데 주소 선택시 자동 입력이 일부 안되는 문제 발생. 확인해보니 로직에는 문제가 없었으나 \<Form.Item\>에 특정 입력창 외에 다른 요소가 들어가면 고장난다는걸 확인하고, 수정하여 해결.   
       2. 전반적으로 디자인이 자연스럽도록 다듬음(홈페이지 버튼 추가, 타이틀 수정, 입력창 간격 정리, placeholder 텍스트 정리 등). 콘텐츠 영역이 세로로 길어 뷰포트를 넘어가는데도 스크롤이 안생기는 문제있음. 콘텐츠를 감싸는 가장 외곽 요소에 스크롤이 생기도록 수정.   
       3. 회원가입 기능 테스트. 예외처리를 포함하여 정상작동 확인.  
   11. 카테고리 페이지 작업  
       1. 카테고리 페이지 제작. 레이아웃 헤더의 카테고리 항목을 누르면, 해당 카테고리의 상품 마스터가 조회되어 카드로 출력되도록 로직 세팅. 카테고리 조건의 상품 마스터 조회는 만들어둔 ‘/product/getProductList’ API와 연동. 기본적인 작동은 하는걸 확인했는데, 레이아웃 작업 먼저 할게 보여서 세부조정은 이후에 할 예정.  
   12. 레이아웃 작업  
       1. 헤더 카테고리 선택 영역 맨 왼쪽 항목에 ‘전체 카테고리’ 버튼을 임시로 세팅해놨었는데, 사용자 입장에서 곰곰히 생각해보니 별로 사용할 상황이 안나오는 버튼이라는 결론에 도달.따라서  ‘전체 카테고리’ 버튼을 ‘홈’ 버튼으로 바꾸고, 누르면 홈페이지로 가는 로직 세팅. 홈 버튼 기능은 작동하는데 카테고리 선택 초기화가 안되는 문제가 있어서 해결.  
       2. 헤더 카테고리 선택 영역의 하이라이트 효과를 제대로 세팅. 선택된 항목은 배경과 내용의 색반전 하이라이트를 주어 시각적으로 명료하게 하고, 호버된 항목은 선택 하이라이트보다 색반전을 덜 주는 하이라이트로 구분되도록 세팅. 카테고리 항목 배경이 홈 버튼과 통일감이 있도록 테두리를 둥글게 수정하고, 항목끼리 과하게 떨어져있어보여 간격 축소하고, 헤더 상단부 ShoppingMall 텍스트 클릭으로 홈페이지로 넘어갔을때 카테고리 항목 선택 초기화가 안되는 문제 해결.  
       3. 헤더 상단부 우측 섹션 수정. 로그인 시 해당 부분의 항목이 ‘장바구니-마이페이지-로그아웃’인데, 호버했을때 클릭할 수 있는 버튼이라는 하이라이트가 부족한 문제가 있음. 따라서 해당 영역의 배경 테두리를 둥글게 깎고, 호버했을때 배경이 회색이 되도록 하이라이트 세팅. 그리고 모바일 환경에서 폭이 좁아지니 ‘장바구니-마이페이지-로그아웃’ 텍스트가 두줄로 뭉개지는 문제 발견. 각 항목에 적절한 아이콘을 앞에 붙이고, 모바일 환경일때는 아이콘만 출력되도록 세팅. 장바구니 영역 오른쪽의 장바구니 저장숫자 출력 디자인이 애매해서 자연스럽게 수정.  
   13. 상품 마스터 카드 작업  
       1. 현재 상품 마스터 카드에 ‘상품 이미지/상품 마스터명/원가/할인율/최종가’ 정보가 담겨있는데, 상품 품목의 색상 정보가 포함되는게 더 낫겠다는 아이디어가 떠오름. 하지만 어떤 방식으로 출력하는게 좋을지 고민해봤는데, 생각보다 현실적인 한계가 너무 큰 느낌이 듦. 일단 색상 원형 아이콘 방식의 경우 출력 관점에서는 아주 적합하지만, 세팅하려면 크게 두가지 방식이 될텐데 각기 한계점이 명확함. 하나는 출력을 규격화하기 위해 color 칼럼을 enum으로하여 색상들을 고정하는 방식일텐데, 이렇게되면 등록되지 않은 색의 품목을 추가할때 코드를 손대야하거나 색상 enum을 관리하는 관리자 기능을 새로 만들어야해서 일이 너무 커지고 심지어 복합색상의 바리에이션을 고려하면 관리해야하는 enum의 개수가 어마어마해짐. 다른 하나는 출력을 규격화하지 않고 color를 rgb값으로 저장하는 방식일텐데, 수백 수천 품목의 rgb를 따로 찍어보는 품이 너무 많이들고 복합색상의 경우 저장/출력이 애매해짐. 툴팁 방식의 경우 커서가 없는 모바일 환경에서 접근이 안되거나 접근이 가능하다고해도 필연적으로 depth가 늘어나게되어 기능이 없는거나 마찬가지가 되어버림. 최종적으로 내가 원하는 수준의 출력이 불가능해보여서 색상 출력은 기각. 대신에 현재 상품의 첫번째 이미지만 가져오는 방식인 것을, 모든 이미지를 가져와서 자동 순환되게 하면서 이미지 수만큼 dot을 출력하여 사용자가 선택해서 볼 수 있게끔 하는 방식으로 수정하면 충분히 대체된다고 결론 지음.  
       2. 상품 마스터 카드를 수정하기 전에, 상품 마스터 카드가 홈페이지와 카테고리 페이지에 공통으로 쓰이고 있다는 점에 착안하여 별도의 컴포넌트 파일로 분리하는게 더 낫겠다는 생각이 듦. 상품 마스터 카드 관련 코드를 별로 파일로 빼고, 모든 상품 이미지를 불러오고 자동 순환+dots 구성으로 코드 수정. dot이 작다보니 모바일 환경에서 터치미스가 날 것으로 보여, 디자인 수정.  
   14. 카테고리 페이지 작업  
       1. 페이지네이션을 일단 프론트엔드에서 적용하도록 antd의 Pagenation 코드 추가. 나중에 백엔드에서 적용할지 고민해봐야함.  
       2. 페이지 우상단에 정렬 조건을 걸 수 있게 antd의 Select 코드 추가. 위치나 하이라이트 등 디자인 세부 조정.  
       3. 현재 어느 카테고리의 페이지인지 명시하는 타이틀이 상단에 있는게 좋을거 같아서, 현재 카테고리를 상단 중앙에 텍스트로 출력하는 로직 세팅. 정렬조건 선택기와 같은 라인에 놓고 이런저런 테스트를 해봤는데, 모바일 환경에서는 타이틀과 선택기가 딱붙어서 이상해보이는 문제가 있음. 라인을 2개로 분리도 해보고 다양한 수정을 해봤는데 다 애매했고, 최종적으로 모바일 환경에서는 타이틀은 출력되지 않도록하는걸로 수정.  
       4. 타이틀이 딱 현재 카테고리만 출력하는 상황이라 상위 카테고리가 뭔지 모르게 되는 문제가 있음. 레이아웃 컴포넌트에 이미 짜여진 로직을 끌어와서 ‘상위 카테고리 \> 하위 카테고리’ 형식으로 출력하도록 로직 수정. 하위 카테고리 출력은 잘되는데, 상위 카테고리로 다시 돌아갔을때 갱신이 안되는 문제가 있어서 추가로 수정.  
       5. 레이아웃의 카테고리 출력과 카테고리 페이지 타이틀 출력 코드를 검토하다보니, 2단계 depth까지만 출력하는 로직이라 문제가 있음을 인지. 3단계 이상의 depth도 문제없이 출력할 수 있게 로직 수정.  
   15. 상품 마스터 페이지 작업  
       1. 상품 마스터 페이지 초안 제작. 상품 이미지를 불러오는 로직을 짜다가 문득, 상품 마스터 카드 컴포넌트를 땡겨오되 \<Meta\>만 출력안되게 하면 되겠다는 생각이 들어서 이렇게 세팅. 초안 정상 출력 확인.  
       2. 테스트 중 헤더의 카테고리 항목에 문제가 있음을 확인. 헤더의 카테고리 항목을 거쳐서 상품 마스터 페이지에 들어가면 헤더의 카테고리 항목 하이라이트가 정상 적용되지만, 다른 루트로 바로 상품 마스터 페이지에 들어가면 헤더의 카테고리 항목 하이라이트가 적용되지 않음. 카테고리 페이지의 관련 로직을 별도 컴포넌트로 빼서 공통 적용 가능한지 검토해보았으나, 레이아웃.js에서 categoryPath 변수를 받아야 카테고리 하이라이트가 적용되는 로직인데 상품 마스터 페이지에서는 categoryPath 변수가 자연스럽게 세팅이 안되는 구조라서 공통 적용이 불가능한걸로 판단됨. 따라서 특정 상품 마스터 정보의 카테고리id로 categoryPath 변수를 채울 수 있도록 전용 API를 새로 세팅하고, 상품 마스터 페이지에 연동. 정상 작동 확인.  
   16. 레이아웃 컴포넌트 작업  
       1. 헤더의 카테고리 항목이 하이라이트 적용되면 클릭이 안되는 문제 발견. 이러면 특정 상품 마스터 페이지에서 해당 카테고리 페이지로 넘어갈 수가 없음. 원인을 찾아보니 현재 선택된 카테고리인 경우 early return을 하는 로직이 문제였어서, 해당 로직 수정. 정상 작동 확인.  
   17. 상품 마스터 페이지 작업  
       1. 상품 마스터 페이지 초안 다듬기.’   
       2. 상품 정보’란에 설명만 있는데, productItem 정보에서 사이즈와 색상을 추출하여 출력하도록 코드 추가.   
       3. 할인율 출력이 빨간색인게 마음에 안들어서 파란색으로 수정.  
       4. 항목끼리의 세로 간격이 어색해서 자연스럽도록 수정.  
       5. 사용자가 옵션을 선택하는 ‘사이즈’ 선택기/’컬러’ 선택기/’수량’ 입력창의 시인성이 좋지 않으므로, 같은 라인 왼쪽에 어떤 항목인지 텍스트로 명시하도록 코드 추가. 텍스트끼리 깔끔하게 정렬이 안되는게 마음에 안들어서, 공백 특수문자를 활용해 텍스트들의 왼쪽라인과 오른쪽라인이 일치하게 양쪽정렬되어보이게 처리함.  
       6. ‘텍스트+선택기’ 영역이 모바일 환경에서 텍스트가 두 줄로 짜부라지는 문제 발견. 뷰포트 폭을 테스트하여 두 줄로 짜부라지는 시점을 찾아서 텍스트와 선택기의 비율이 변동되도록 코드 수정.  
       7. 재고 수 이상으로 수량이 입력되지 않도록 되어있는데, 이 방식은 사용자가 재고를 너무 쉽게 알아낼 수 있는 방법이라 마음에 안듦. 따라서 수량 입력 제한을 없애되 재고 수 이상으로 장바구니에 담으려고 할때 재고 수보다 수량이 많다는 경고 메시지가 나오도록 수정.  
       8. 입력 순서가 ‘사이즈 \> 컬러 \> 수량’이라, 컬러 기준으로 재고가 없으면 해당 컬러 텍스트에 ‘(품절)’ 텍스트가 추가되도록 코드 수정. 그리고 특정 사이즈의 모든 컬러가 품절이라면 해당 사이즈 텍스트에도 ‘(품절)’ 텍스트가 추가되도록 코드 수정.  
   18. 카테고리 페이지와 상품 마스터 페이지의 URL 구조 정리  
       1. 이런저런 테스트를 하다보니, 현재 상품 마스터 페이지의 URL이 ‘http://localhost:3000/products/2’ 형식이라 DB 구조가 간접적으로 드러나는 상태라는걸 깨달음. 어떻게 개선하는게 좋을까 고민하다보니, ‘.../카테고리코드/상품코드’ 형식이 정론에 가깝다는 결론에 도달. 문제는 이렇게 세팅하려면 상품 마스터 DB 테이블에 ‘코드’ 칼럼을 추가해야하며, 카테고리 페이지의 URL부터 먼저 정리해야함. 현재 카테고리 페이지의 URL은 ‘[http://localhost:3000/category?categoryId=1](http://localhost:3000/category?categoryId=1)’ 형식이라 마찬가지 문제점을 품고있는 상태. 카테고리 페이지 URL 형식을 먼저 수정하기로 결정.  
       2. 카테고리 페이지의 URL 형식을 ‘.../카테고리코드’로 바꾸기 위해 라우팅 세팅을 수정하고, 레이아웃 헤더의 카테고리 항목 쪽 로직을 수정. 기본적인 기능은 작동하긴하는데, 헤더의 카테고리 항목을 한번 클릭하면 카테고리 페이지에 접속이 바로 안되고 두번째 클릭해야 접속이 되는 문제가 새로 발생함. 원인을 분석하는데 고생하긴했는데, 결과적으로 카테고리 클릭 이벤트 함수 로직에 문제가 있는걸 확인하고 수정하여 해결.  
       3. 상품 마스터 페이지의 URL 형식을 ‘.../카테고리코드/상품마스터코드’로 바꾸기 위해 라우팅 세팅을 수정하고, DB의 상품 마스터 테이블에 code 칼럼을 추가하고, 상품 마스터 정보를 조회하는 로직에 code가 포함되게 수정. 하지만 상품 마스터 카드를 클릭했을때 상품 마스터 페이지 출력 오류 발생. 원인을 추적해보니 수정 전의 로직에서는 상품마스터id를 URL에서 떼온다음 그걸 기준으로 API 조회하는데, 수정 후에는 URL에 상품마스터id가 아니라 상품마스터코드만 들어있어서 오류가 생기는 것이었음. 상품 마스터 페이지에 접속하는 정상적인 루트는 상품 마스터 카드를 클릭하는 것이므로, 상품 마스터 카드를 클릭하면 조회했던 상품마스터코드 정보를 넘겨주는 로직으로 수정해봤는데… 생각했던대로 작동은 하지만, 만약에 상품 마스터 카드를 통하지 않고 URL만 입력해서 접근하는 사용자가 있다면 출력 오류가 생기는게 꽤 치명적이라는 생각이 들었음. 가능하면 상품 마스터 코드로 상품 정보를 조회하는 API를 추가하지 않고 상황을 정리하려고 했는데, 더이상 다른 우회 루트가 없다고 판단. 결국 상품 마스터 코드로 상품 정보를 조회하는 API를 새로 만들고, 상품 마스터 페이지에 상품마스터id로 조회하는 API 로직을 새로만든 API 로직으로 교체. 이제 가능한 모든 상황에서 정상 작동하는걸 확인.  
   19. 상품 마스터 페이지 작업  
       1. 가격 출력 부분에 문제가 있는걸 발견. 할인율 값이 있는 경우에는 원가/할인율/판매가 모두 적절히 출력되어 문제가 없지만, 할인율 값이 없는 경우에는 원가/판매가의 동일한 값이 아무 설명없이 병기되어있어 디자인적으로 문제가 있음. 할인율 값이 없는 경우에는 원가 출력을 하지 않고 판매가만 출력하도록 수정.  
   20. 장바구니 페이지 작업  
       1. 장바구니 관련 로직을 담는 파일과 장바구니 페이지 초안 제작. 대부분 출력은 되지만, 상품 이미지가 제대로 안나오는 문제가 있어서 DB의 첫번째 이미지 URL만 끌어오도록 코드 수정. 이미지 정상 출력 확인.  
       2. 테스트를 하다보니, 장바구니 정보를 단순히 로컬스토리지에 하는 로직이라 로그인 계정과 무관하게 브라우저 기준으로 장바구니 정보가 출력되는 문제를 발견. 이런저런 방안을 검토하다가 최종적으로, 인증 로직에서 계정 이메일을 저장하게 세팅해놨으므로 장바구니 정보를 저장할때 이메일 정보도 같이 저장하게 하여 장바구니 정보를 읽을 때 로그인 이메일과 일치하는 장바구니 정보를 불러오는 로직으로 수정. 같은 브라우저라도 로그인 계정 기준으로 장바구니가 저장되고 불러지는 정상 작동 확인.  
       3. 상품 정보가 들어간 \<Table\>의 ‘수량’ 칼럼이 숫자입력창으로 되어있어 사용자가 재고량 추적이 너무 쉬운 문제가 있어, 수량을 좌우의 \-/+ 버튼으로 수정하는 방식으로 수정하여 재고량 추적이 상대적으로 어렵게 수정.  
       4. 데스크톱 환경에서 상품 정보가 들어간 \<Table\>에 들어가는 내용에비해 폭이 많이 길다보니 여백이 너무 심하게 많은 문제가 있음. 이리저리 고민해보다가 최종적으로는 최상위 박스의 최대폭을 600px으로 제한하여 자연스럽게 수정. 이후 표 내부 정렬도 어색해서 컬럼명과 셀을 가운데 정렬하고 ‘상품 정보’ 컬럼의 셀 텍스트만 왼쪽 정렬하여 디자인 조정.  
       5. 금액 출력 파트에 ‘총 상품 금액’과 ‘결제 예정 금액’만 세팅해놓았는데, ‘총 상품 금액’ 아래줄에 ‘배송비’를 세팅. 총 상품 금액이 5만원 이하면 배송비 3천원이 추가되고, 5만원 이상이면 배송비가 무료로 책정되도록 코드 추가. 배송비 안내문구는 ‘배송비’ 텍스트 오른쪽에 QuestionCircleOutlined 아이콘을 추가하여 마우스 오버하거나 터치하면 팝업 텍스트가 출력되도록 세팅.  
       6. 모바일 환경에서는 가로로 긴 \<Table\> 특성때문에 출력범위보다 오른쪽으로 튀어나가는 문제를 확인. 모바일 환경에서는 \<Table\> 대신 \<Card\>로 출력되도록 코드 수정. 정상 출력 확인.  
   21. 레이아웃 컴포넌트 작업  
       1. 현재 로그아웃 버튼을 누르면 로그인 페이지로 이동하는데, 부자연스러운 작동이라 홈페이지로 이동하도록 로직 수정.  
   22. 장바구니 페이지 작업  
       1. 상품 정보 칼럼의 상품 이미지나 상품 품목 명을 클릭하면 해당 상품 페이지로 이동하는 로직 세팅. 정상 작동 확인.  
   23. 레이아웃 컴포넌트 작업  
       1. 장바구니 수량 출력이 장바구니 수량 로직과 연동되어 있지 않아서, 연동되도록 수정. 정상 작동 확인.  
   24. 마이페이지 작업  
       1. 백엔드에 만들어놓은 API들을 바탕으로 가장 기본적인 형태의 초안 코드 세팅.   
   25. 레이아웃 컴포넌트  작업  
       1. 장바구니 페이지이거나 마이페이지 접속중일때, 레이아웃 헤드에서 해당 페이지의 버튼을 눌렀을때 페이지 새로고침이 안되서 사용자 경험이 나쁜 문제를 발견. 버튼 클릭시 시간정보를 저장하고, 시간정보가 다를때 페이지를 새로 불러오는 로직을 세팅. 마이페이지 버튼은 정상작동하는데, 장바구니 버튼이 새로고침 작동을 안해서 원인 추적. 장바구니 페이지 새로고침 로직이 로컬스토리지의 내용을 불러오기만 하다보니, 시각적으로 티가 안날뿐인게 원인이라고 판단. 로컬스토리지를 불러올때 로딩 스피너가 돌도록 세팅하는 것으로 정상 작동 확인.  
   26. 마이페이지 작업  
       1. 초안은 회원정보만 간단히 출력하는 세팅인데, 더 고도화 시킬 필요가 있음. 일단 대시보드를 메인으로 하고 상세메뉴를 선택할 수 있는 형태로 방향을 잡음. 메뉴 항목을 고민해봤는데 ‘고객센터’, ‘1:1 문의’, ‘찜리스트’ 등은 필수 느낌이 아니라 나중에 필요하면 구현할 예정이고, 일단 필수라고 생각하는 ‘주문관리’, ‘회원정보’를 항목으로 최종 확정. 대시보드, 주문관리, 회원정보를 컴포넌트로 구현하여 사용자가 원하는 메뉴를 누르면 불러오는 로직으로 세팅.  
       2. 세팅된 마이페이지를 출력해서 검토하는데, 이런 구성이라면 구조적으로 잘못되었다는걸 깨달음. 대시보드는 여러 항목을 하나의 화면에 함축적으로 정리해서 보여주는데 의의가 있는데, 회원정보는 대시보드에 함축할 성격의 항목이 아니므로 결국 주문정보 하나의 항목만 남게됨. 어떻게 할까 고민하다 의미없는 대시보드를 없애고, 항목이 2개만 남게되므로 각각 별개의 페이지로 전환하여 헤더의 ‘마이페이지’ 버튼에 마우스 오버(모바일은 터치)시 드롭다운으로 나열하여 사용자가 선택하는 방안으로 결정. 대시보드 컴포넌트 삭제하고 다른 컴포넌트는 페이지로 전환 후 라우팅 세팅 변경.  
   27. 마이페이지 회원관리 페이지 작업  
       1. 회원정보 관리 페이지 수정. 회원 본인 확인을 위한 비밀번호 확인 절차를 먼저 거치도록 세팅. antd의 Descriptions로 회원정보를 출력하고 ‘정보 수정’, ‘비밀번호 변경’, ‘회원 탈퇴’ 버튼들을 아래 세팅하는 구성으로 정리. 각 버튼을 클릭하면 모달이 열리는 로직.  
       2. 회원정보 관리 페이지 디자인 다듬기. 데스크톱 환경에서는 폭이 너무 넓어서 출력되는 폭을 적절한 값으로 고정. 하단 버튼 3개가 폭이 좁은 모바일 환경에서 뷰포트를 뚫고 나가는 경우가 생겨서, 모바일 환경에서는 세로로 정렬되게 수정.  
       3. 정보 수정 모달 세팅. 회원가입 로직을 참고하여 코드 세팅. 페이지가 아니라 모달이다보니 디자인이 애매해진 부분들 수정.  
       4. 비밀번호 변경 모달 세팅. 가로 폭을 좁게 고정하도록 수정하고, 간격이나 위치가 자연스럽도록 디자인 수정.  
       5. 비밀번호 변경 모달 테스트 중 문제 발견. 조건에 안맞게 입력하고 ‘변경’ 버튼을 누르면 아무런 피드백없이 그대로라서 사용자 경험에 안좋음. 그런 상황에서는 안내해주는 메시지가 출력되는 로직 추가.  
   28. 회원가입 페이지 수정  
       1. 체크해보니 비밀번호 변경 모달의 문제가 회원가입 페이지에서 그대로 나오는걸 확인. 역시 조건에 안맞게 입력하고 ‘가입’ 버튼을 누르면 안내해주는 메시지가 출력되는 로직 추가.  
   29. 레이아웃 컴포넌트 수정  
       1. 이런저런 테스트 중 헤더의 마이페이지 버튼을 드롭다운 메뉴가 나오게 수정한 이후 문제발견. 드롭다운 메뉴를 열고 닫는 동작이 마우스 오버와 클릭을 모두 포함하다보니, 데스크탑 환경에서는 정보없는 사용자가 클릭을 하려고 할때 마우스 오버로 열렸다가 클릭시 닫혀버려 사용자 경험이 매우 안좋음. 데스크탑 환경에서는 클릭을 막고 모바일 환경에서는 클릭을 열어서, 양쪽 상황 모두 사용자 경험이 자연스럽도록 수정.  
   30. 마이페이지 회원관리 페이지 작업  
       1. 정보 수정 모달을 통해 회원 정보 수정이 정상 기능하는지 테스트해봤는데, api/user/update API에 400에러와 함께 “접근 권한이 없습니다.”라는 메시지가 출력되는 문제 발생. 백엔드에서 “접근 권한이 없습니다.” 메시지를 내는 코드를 찾아봤더니 JwtAuthenticationFilter.java에 있었음.  
5. 쇼핑몰 스프링 프로젝트 백엔드 작업  
   1. JwtAuthenticationFilter.java 수정  
      1. 문제가 될만한 로직이 있는지 코드를 전면적으로 검토. 엑세스 토큰 만료 시 자동으로 새 토큰을 발급하고 필터체인으로 넘어가는 부분, 만료된 엑세스 토큰을 처리하는 함수에 예외처리가 없는 부분 등의 문제를 발견. 발생 이슈와는 직접적인 연관이 없지만 해결해야하는 부분이라, 코드를 전반적으로 정리하여 문제 부분을 해결. 정리하면서 “접근 권한이 없습니다.” 메시지 부분도 원인을 더 확실하게 구분할 수 있게 수정.  
      2. 이 파일의 코드가 더 깔끔하게 정리되긴 했지만, 이후 발생 이슈를 다시 테스트했을때 여전히 같은 현상이 일어나는걸로보아 이 파일의 문제가 아닌듯함.  
   2. UserService.java 수정  
      1. “접근 권한이 없습니다.” 메시지를 세팅한 다른 코드가 있는지 다시 전면검토해봤더니, UserException.AccessDeniedException()과 일치함을 확인. 회원 정보를 업데이트하는 API 로직 중에 관련 코드를 찾아보니 UserService.java에 있었음. 알고보니 프론트엔드에서 넘어오는 이메일과 토큰에서 추출한 이메일이 일치하는지 검토하는 로직에서, 두 개가 불일치하면 예외를 발생시켜야하는데 일치하면 예외를 발생시키는걸로 잘못세팅된게 원인이었던 것. 수정 후 발생 이슈가 해결된걸 최종 확인.  
6. 쇼핑몰 리액트 프론트엔드 작업  
   1. 마이페이지 회원관리 페이지 작업  
      1. 비밀번호 변경 모달에서 ‘현재 비밀번호’ 입력값과 ‘새 비밀번호’ 입력값이 같을때도 정상 진행되는 문제 발견. 두 값이 같으면 통과하지 못하고 안내 메시지가 출력되도록 수정. 작동 테스트 전에 혹시 백엔드의 API 쪽에 문제가 없는지 겸사겸사 검토하는게 좋겠다고 생각함.  
7. 쇼핑몰 스프링 프로젝트 백엔드 작업  
   1. 회원 관련 API 수정  
      1. 프론트엔드 작업에서 넘어와서 회원 관련 API 코드들 검토. 서비스 단계에서 ‘SecurityContextHolder.getContext().getAuthentication().getName()’를 통해 인증된 사용자 정보를 가져오는데, 컨트롤러에서 인증된 상태인지 확인해서 기본적으로는 문제가 없지만 혹시라도 문제가 생기면 추적하기 곤란하다고 판단. 따라서 ‘SecurityContextHolder에 인증된 정보가 없으면 예외를 발생시키는 코드를 추가하고, 이에 따라 컨트롤러에도 관련 코드 추가.  
8. 쇼핑몰 리액트 프론트엔드 작업  
   1. 마이페이지 회원관리 페이지 작업  
      1. 본인 인증 후 회원정보 관리 페이지에 처음 들어갔을때, API가 불러와지는 잠깐 동안 Descriptions가 빈칸으로 보여서 사용자 경험이 좋지 않음. API가 불러와지는 동안에는 로딩 스피너가 돌도록 세팅.  
      2. 모바일 환경에서 메인 컨테이너 폭이 뷰포트보다 커서 옆으로 삐져나가는 문제 발생. 메인 컨테이너 폭이 고정값인게 원인이라, 뷰포트에 맞게 줄어들 수 있게 수정.  
      3. 회원 탈퇴 모달의 디자인이 더 자연스럽도록 수정. ‘탈퇴하기’ 버튼에 회원탈퇴 로직 연동하여 세팅.   
      4. ‘탈퇴하기’ 버튼의 기능은 작동하는데, 이후 흐름에 문제가 발생. 세팅한대로라면 ‘탈퇴 API 작동 → 로그아웃 처리 → 홈페이지 이동’이 되어야하는데, ‘탈퇴 API 작동 → 로그아웃 처리 → 로그인 페이지 이동’이 되는 상황. 출력되는 메시지도 “회원 탈퇴가 완료되었습니다.”가 나오는건 정상적인데, 연이어 “로그인이 필요한 페이지입니다.”가 나오는건 비정상적임. ”로그인이 필요한 페이지입니다.” 메시지는 PrivateRoute.js에서 로그인이 필요한 페이지에 로그인 없이 접속했을때 나오게 만든걸로 확인됨. 결국 이 현상은 로직에서 로그아웃 처리 후 홈페이지로 이동하기 전에 마이페이지의 로그인 검증 로직에 하이재킹당해서 로그인 페이지로 넘어가는 걸로 분석할 수 있음. 해결을 위해 로그아웃 로직에 탈퇴 로직인지를 구분하는 변수를 추가하고, 탈퇴 로직인 경우 [PrivateRoute.js](http://PrivateRoute.js)에서 로그인 검증 없이 통과시키도록하여 홈페이지 이동까지 로직이 정상적으로 도달하도록 수정함.  
      5. 로직 수정 후 테스트를 해봤는데 뷰포트에 에러가 출력되는 새로운 문제 발생. 콘솔로그를 확인해보니 ‘http://localhost:3000/api/user/find?email=undefined 403 (Forbidden)’ 문제가 출력되고 있었음. api/user/find API는 관련 로직 중 회원관리 페이지에만 사용되고 있는 로직인걸 확인. 아마도 로그아웃 처리 후 useEffect를 통해 api/user/find API가 갱신되면서 생기는 문제로 분석됨. useEffect 로직에 탈퇴 로직인 경우 API 갱신없이 통과시키도록 수정. 이제 ‘탈퇴하기’ 버튼 클릭 후 원하는 흐름으로 작동하는걸 최종 확인.  
9. 쇼핑몰 스프링 프로젝트 백엔드 작업  
   1. 로그인 API 수정  
      1. 프론트엔드 테스트 중, 탈퇴 회원도 로그인 되는 문제 발견. 탈퇴 회원은 로그인이 되지 않도록 로직 수정. 정상 작동 확인.  
10. 쇼핑몰 리액트 프론트엔드 작업  
    1. 마이페이지 회원관리 페이지 작업  
       1. 검토중에 정보 수정 모달을 통해 출력되는 회원 정보 중 ‘주소’ 항목에 문제가 있음을 발견. 주소는 users 테이블에 address 칼럼 하나에 저장되는데, 다음 우편번호 서비스의 입력창은 ‘우편번호/기본주소/상세주소’ 3개 항목으로 구성됨. 그래서 회원가입 로직에서는 3개 항목을 하나로 합쳐서 백엔드로 넘기는 방식을 썼음. 문제는 회원관리 페이지의 정보 수정 모달의 ‘우편번호/기본주소/상세주소’ 3개 항목이 정상 출력되지 않고 ‘기본주소’ 항목에만 전체 주소가 들어가있는 상황임. 이 문제를 해결하려면 크게 두가지 방안이 있을텐데, 하나는 address 칼럼에 손대지 않는 대신 3개 항목을 구분하는 특수문자 같은걸 넣고 3개 항목으로 출력할때 구분자를 기준으로 쪼개서 출력하는거고, 다른 하나는 address 칼럼을 3개 항목에 맞춰 쪼개는 거임. 두 방안의 장단점을 따져봤을때 address 칼럼을 쪼개는게 가장 합리적인 방안이라 이걸로 선택.  
11. 쇼핑몰 스프링 프로젝트 백엔드 작업  
    1. 회원 정보 로직 수정  
       1. users 테이블의 address 칼럼을 삭제하고 postcode, base\_address, detail\_address 칼럼을 새로 추가. 이에 따라 VO, Mapper, Service, Controller, DTO의 관련된 코드들 전면 수정. 이후 백엔드 프로젝트 실행이 안되는 문제가 생겨서 확인해보니, 관리자 정보를 DB에 자동으로 넣는 data.sql 코드의 address 코드가 원인인걸로 밝혀져서 수정. 이후 백엔드 프로젝트 정상 실행 확인.  
12. 쇼핑몰 리액트 프론트엔드 작업  
    1. 회원가입 페이지 수정  
       1. users 테이블의 address 칼럼을 삭제하고 postcode, base\_address, detail\_address 칼럼을 새로 추가한거에 맞춰, 관련 코드 수정. 문제없이 작동하는지 테스트 진행. 몇가지 문제가 발견되어 전부 맞게 수정. 정상 작동 확인.  
    2. 마이페이지 회원관리 페이지 작업  
       1. users 테이블의 address 칼럼을 삭제하고 postcode, base\_address, detail\_address 칼럼을 새로 추가한거에 맞춰, 관련 코드 수정. 정상 작동 확인.  
    3. 마이페이지 주문관리 페이지 작업  
       1. 주문관리 페이지 초안을 출력해보니 수정할 부분이 많음. 일단 기본적인 틀은 관리자 페이지의 주문관리 페이지에서 따오되, 개인 회원용으로 적합하게 일부 로직 수정을 해야함. 관리자 페이지의 주문관리 페이지 표를 일단 따오고, 표의 칼럼을 ‘주문일자 / 주문번호 / 주문금액 / 상품정보 / 주문상태 / 작업’순으로 정리하고 기본나열순서는 주문일자 내림차순으로 세팅. ‘주문상태’ 칼럼은 현재 상태만 출력하도록 수정. 페이지네이션 기본 세팅이 오른쪽 정렬로 어색해서, 적절하게 좌우정렬되도록 수정. ‘상품정보’ 칼럼 외의 칼럼들은 내용이 정상적으로 출력되는 최소한의 폭을 찾아서 고정값으로 세팅하고, ‘상품정보’ 칼럼은 뷰포트 폭에 따라 유동적으로 변하게 하되 내용보다 뷰포트 폭이 좁아지는 순간부터는 좌우 스크롤이 생기게 세팅.   
       2. 표 위의 기간 조회 영역을 오른쪽 정렬로 수정. 기간 조회는 프론트엔드에서 필터링하도록 세팅. 정상작동 확인.  
       3. ‘상세보기’ 버튼을 눌렀을때 상세보기 페이지로 넘어가는게 초안인데, 상세보기 모달이 나오도록 수정. 모달에서 기본 주문 정보는 Descriptions로 출력하고, 주문 상품별 정보는 표로 출력하게 세팅. 각 주문 상품 상태에 따라 회원이 수행할 수 있는 작업의 버튼(‘주문취소’, ‘구매확정’, ‘교환신청’, ‘반품신청’)이 자동으로 ‘작업’ 칼럼에 출력되도록 세팅. 만일 출력할 작업 버튼이 없다면 ‘-’를 출력하도록 세팅. 손대다 꼬여서 좀 고생하긴 했지만, 결과적으로 정상 작동 확인.  
       4. ‘상세보기’ 버튼을 눌러서 모달이 띄워지는 사이에 주문관리 페이지의 표에 스피너가 돌아가서 사용자 경험상 어색한 상태. 해당 동작시 표에 스피너가 돌아가지 않도록 수정. 정상 작동 확인.  
       5. ‘주문취소’, ‘구매확정’, ‘교환신청’, ‘반품신청’ 버튼을 통해 나오는 요청용 모달 세팅. 수량과 이유를 드롭다운으로 선택할 수 있게하고, 이유의 경우 직접 입력하고 싶으면 기타 항목을 선택하면 입력창이 나오는 방식으로 정리. ‘주문취소’의 경우 수량을 수정할 수 없게 고정값으로 세팅. 사유의 드롭다운 항목은 각 상황에서 일반적인 이유들을 고민해서 세팅.   
       6. 전반적으로 API 로직이 백엔드와 잘 맞게 세팅되어있는지 검토해서 수정이나 정리가 필요하면 수행. 백엔드에서 받아야하는 내용들이 잘 들어가는지, 프론트엔드가 백엔드의 에러 메시지를 잘 받는지를 위주로 검토.  
       7. 요청용 모달의 디자인 정리. 모달 폭을 좁게 고정값으로 주고, 수량 드롭다운 폭이 넓으면 수량 텍스트와 드롭다운 아이콘이 너무 떨어져서 어색하니 100px로 폭을 강제하고, 모달 타이틀과 선택 버튼들을 가운데 정렬. 그리고 각 Form.Item 간격을 조정하는데서 애를 많이 먹었는데, 숨겨졌다 나타났다 하는 텍스트 입력창이 이중 Form.Item 구조로 인해 noStyle 속성을 줘야하다보니 디자인이 깔끔하게 안떨어짐. 그래도 이중 Form.Item 구조를 조건부 랜더링으로 우회할 수 있는 방법을 찾아서, 원하는대로 디자인 수정 완료.  
       8. 모달 세팅하고 테스트하다보니, 주문 상태별 사용자 작업 버튼(주문취소, 반품신청 등)이 메인 페이지가 아니라 모달에 있다보니 depth가 한 층 생겨 사용자 경험에 안좋다는걸 깨달음. 따라서 작업 버튼을 모달 표에서 메인 페이지 표로 빼는 작업 진행. 메인 페이지의 표 칼럼을 ‘.../주문상태/작업/상세’로 바꾸고 ‘주문상태 \= 상태 태그’, ‘작업 \= 상태별 작업 버튼’, ‘상세 \= 상세보기 버튼’을 세팅. 상태별 사용자 작업 버튼 로직을 모달에서 메인 페이지의 ‘작업’ 칼럼으로 옮겨옴. 버튼 기능 정상 작동 확인.  
       9. 배송 조회 모달 세팅. antd \<Timeline\> 기반으로 배송정보를 \<Description\>에 넣어 출력하게 만듦. 적절한 모달 폭을 찾아서 고정값으로 세팅하고, 타임라인에 배송종류별로 적절하게 표시될 아이콘을 antd에서 찾아서 세팅하고, 배송 완료 일자 값이 없으면 ‘-’를 출력하도록 세팅. 출력등에 문제가 없는지 확인.  
       10. 모바일 환경에서 주문관리 페이지가 어떻게 출력되는지 확인. 예상대로 뷰포트 가로폭이 줄어들다보니 표에 가로 스크롤이 생김. 가로로 긴 표가 세로로 긴 뷰포트에 들어가있는건 사용자 경험상 좋지 않아서, 수정방안 구상 시작. 단순히 표를 세로로 나열한것과 비슷하게 Descriptions를 활용할까 생각해봤는데, 디자인이 깔끔하게 안나올거 같아서 폐기. 주문 마스터를 Card로 묶고, 주문 품목은 그 안에 div박스로 묶음. 초안을 출력해보니 전체적인 틀은 문제없이 잡혔지만, 사용자가 한눈에 이해하기에 쉬운 디자인으로 많이 다듬어야 함. 주문 마스터의 공통 정보인 ‘주문일자’, ‘주문번호’, ‘결제금액’은 명확히 인지시키기위해 값만 출력하는게 아니라 타이틀과 같이 왼쪽정렬 출력하도록 수정. 각 주문 품목을 담는 div의 경우 ‘품목명’, ‘품목옵션’, ‘주문상태’ 정보들은 타이틀을 안붙여도 충분히 인지하기 쉬워서 값만 왼쪽정렬 출력하고, 각 주문 상태에 따른 작업 버튼은 오른쪽정렬 출력하도록 수정. 주문 상세정보는 카드 맨 아래에 버튼으로 출력하도록 수정. 출력되는거 보고 미세조정 필요한 부분 수정.  
       11. 모바일 환경에서 카드로 출력할때 페이지네이션이 없다보니, 주문 수가 많은 경우 세로 스크롤이 매우 길어질 것이므로 사용자 경험에 안좋을거라는 생각이 듦. List 컴포넌트 하위에 카드가 출력되게 하고, List 속성의 페이지네이션을 활성화하여 페이지네이션 출력하는 방식으로 수정. 페이지네이션은 정상 출력되는데 정렬이 이상해서, ‘건수’ 항목을 왼쪽정렬되게 하고 ‘페이지 선택’ 항목을 가운데정렬되도록 디자인 수정. 정상출력 확인.  
    4. 마이페이지 관련 파일명 수정  
       1. 마이페이지에 속하는 ‘회원정보 관리 페이지’와 ‘주문관리 페이지’의 파일명을 각각 ‘[UserInfoPage.js](http://UserInfoPage.js)’, ‘[OrderManagementPage.js](http://OrderManagementPage.js)’로 만들고 여기까지 왔는데, 이런 파일명으로는 마이페이지에 속한다는 직관성이 떨어지는 문제가 있음. 각각 ‘[MyPageUserInfo.js](http://MyPageUserInfo.js)’, ‘[MyPageOrderManagement.js](http://MyPageOrderManagement.js)’로 수정.  
    5. 마이페이지 회원정보 관리 페이지 작업  
       1. 모바일 환경에서 본인 확인 컴포넌트가 뷰포트 오른쪽을 뚫고 나가는 문제 발견. 최상위 컨테이너의 폭이 400px로 고정되어 있어서 생기는 문제라서, 기본폭을 100%로 수정하고 최대폭을 400px로 제한하여 유동적으로 출력되도록 수정. 정상 출력 확인.  
    6. 공통 모달 스타일 세팅  
       1. 마이페이지 주문정보 관리 페이지 작업할때, 모달이 뷰포트의 환경과 상관없이 안정적으로 출력되도록 세팅한게 안정적으로 작동했음. 이 세팅을 모든 모달에 적용하면 좋을 것 같아 시도. 공통으로 적용시킬 코드를 별도 파일로 옮김. 마이페이지 주문정보 관리 페이지에 해당 파일을 import 시켜서 기존 코드를 대체. 정상 출력 확인.  
       2. 마이페이지 회원정보 관리 페이지의 모달에 공통 스타일 적용. 정상 출력 확인.  
    7. 관리자 상품 관리 페이지 수정  
       1. 공통 모달 스타일을 적용하기 위해 코드를 열었는데, 리액트에 익숙해지기 전에 만든거라 스타일 속성 코드들이 함수로 정리되어 있지 않고 랜더링 리턴 쪽에 깡으로 입력되어 있어서 정리가 필요한 상태임. 일단 모달 외에 기본적인 요소들의 스타일 속성을 함수로 빼는 작업 진행.  
       2. 테스트 중 모바일 환경에서 ‘카테고리 선택’ 드롭다운과 ‘상품명 검색창’이 하나의 라인에 정렬되어야하는데 두줄로 정렬되는 문제 발견. 원인은 모바일 환경이 되면 두 항목의 폭이 뷰포트보다 크게 유지되기 때문이라서, ‘카테고리 선택’ 드롭다운 고정 폭을 줄이고 ‘상품명 검색창’이 모바일 환경일때 폭이 더 줄어들도록 수정. 정상 출력 확인.  
       3. 카테고리 관리 모달의 스타일 속성 재정리 작업. ‘카테고리 관리’ 모달과 그 하위의 ‘카테고리 추가/수정’ 모달의 스타일 속성을 함수로 빼고, 공통 모달 스타일 적용. 출력해보니 카테고리 관리 모달의 경우 트리구조 때문에 생각지 못한 문제가 생겼는데, 모달 위치는 가운데 고정인 상태에서 트리구조를 열거나 닫으면 위아래로 아코디언처럼 높이가 늘었다 줄었다 하는 바람에 모달 상단의 닫기버튼이나 타이틀영역이 계속 같이 움직여서 사용자 경험에 안좋음. 고민하다가 결국 카테고리 관리 모달은 상단에 여백을 고정값으로 줘서 모달 아래 영역만 늘었다 줄었다 하도록 수정. 모달 헤더라인 오른쪽의 ‘카테고리 추가’ 버튼의 크기가 타이틀 텍스트 크기와 같을정도로 커서 보기에 안좋음. 버튼 크기를 줄이고, 모바일 환경에서는 버튼 내 텍스트를 축소하여 ‘추가’만 출력되도록 수정.  
       4. 상품 추가/수정 모달의 스타일 속성 재정리 작업. 모달의 스타일 속성을 함수로 빼고, 공통 모달 스타일 적용. 검토하다보니 모달 폭이 더 작아야 입력창들이 자연스럽게 보일거라 생각해서 모달 폭을 줄임. ‘기본 가격’과 ‘할인율’ 숫자 입력창 오른쪽에 1씩 증감하는 버튼이 존재하는데, 각 항목의 특성상 있는게 더 불편하고 이상한 버튼이라서 삭제시킴. 그리고 ‘기본 가격’과 ‘할인율’ 항목의 단위는 오른쪽에 붙어있는데, 입력창 내용은 왼쪽 정렬되는 중이라 사용자 경험상 안좋은걸 깨달아서 오른쪽 정렬로 수정. ‘할인율’ 항목 아래에 ‘최종 가격’ 항목을 추가하는게 사용자 경험상 더 낫겠다 싶어서 추가. ‘최종 가격’ 입력창은 ‘기본 가격’과 ‘할인율’ 값을 기반으로 자동으로 계산되도록하고 사용자가 건드릴 수 없도록 세팅. 테스트 중에 ‘상품 수정’ 모달을 열었을때 ‘최종 가격’ 입력창에 DB값이 안들어가는 누락을 발견하여, ‘상품 수정’ 모달의 경우 처음 불러올때만 DB값이 들어가도록 세팅. ‘카테고리’ 항목의 캐스케이드를 열어서 카테고리를 선택할때 상위 카테고리에 마우스 오버를 해도 하위 카테고리가 안펼쳐져서 클릭을 해야만 펼쳐지는 문제 확인. 원인을 찾아보니 캐스케이드의 확장트리거가 ‘클릭’으로 지정되어있어서 생기는 문제인데, 이걸 단순히 ‘호버’로만 바꿔보니 커서가 없는 모바일 환경에서 불편해지는 또다른 문제가 발생함. 따라서 데스크톱 환경일때는 ‘호버’로 작동하고, 모바일 환경일때는 ‘클릭’으로 작동하도록 조건을 거는걸로 수정. 정상 작동 확인. 검색입력창에 텍스트를 입력하기만해도 백엔드에서 API가 조회되며 표에 스피너가 돌아가는 이상 동작이 확인됨. 원인을 찾아보니 ‘카테고리 목록 가져오기’ useEffect 코드에 검색 로직이 의존성 추가된게 문제였어서, 의존성 목록에 해당 로직을 삭제. 정상 작동 확인.  
       5. 테스트 중 상품 수정 모달의 ‘카테고리’ 항목 Cascade에 선택된 상품 마스터의 카테고리 구조가 불러와지는게 아니라 카테고리ID가 출력되고 있는 문제를 발견. 추적해보니 상품 마스터 수정 모달 세팅 함수에서 카테고리 구조를 넣는게아니라 카테고리ID를 넣는 코드인게 원인이었음. 카테고리 구조가 정상적으로 불러와지도록 윗줄에 로직을 추가하고 상품 마스터 수정 모달 세팅 함수를 수정. 정상 출력 확인.  
       6. 상품 추가/수정 모달에서 '판매 상태' 항목은 어떤 모달로 열었냐에 따라 출력 유무가 다르도록 세팅했었는데, 재검토하면서 생각이 바뀌어서 수정 방안을 고민. 출력은 항상 하되 추가 모달로 열었을 경우 '비활성'이 기본값으로 나오도록 수정하고, 수정 모달로 열었을 경우에는 지금 로직에서 따로 바뀌는게 없도록 세팅. 정상 출력 확인.  
       7. 상품 품목 관리 모달의 스타일 속성 재정리 작업. 모달의 스타일 속성을 함수로 빼고, 공통 모달 스타일 적용. 표 위의 우측 ‘품목 추가’ 버튼의 크기가 커서 디자인이 이상하여, 버튼 크기를 줄이고 모바일 환경에서도 어색하지 않도록 미세 조정.   
       8. 상품 품목 추가/수정 모달의 스타일 속성 재정리 작업. 모달의 스타일 속성을 함수로 빼고, 공통 모달 스타일 적용. 모달의 고정 폭을 축소.  
    8. 전역 스타일 세팅  
       1. 관리자 상품 관리 페이지의 스타일 수정을 하고 검토하는 과정에서, \<Select\>의 테마색상 하이라이트가 누락되어 미적용된 부분을 확인하고 어떻게 할까 고민 시작. 지금까지는 파일마다 컴포넌트 각각에 하이라이트 스타일을 적용하고 있었는데, 이런 방식으로는 지금처럼 누락된 부분이 생길 수 밖에 없고 관리할 코드가 늘어날수록 누락을 발견하기 힘들 수 밖에 없다는걸 느낌. 그래서 아예 전역 스타일로 설정하는 방향이 올바른 것 같아서, 어떻게 하는건지 알아보고 세팅 시작. 기존의 theme.js에 하이라이트 스타일 코드를 추가하고, 전역 스타일 문자열 생성 함수를 세팅하고 \<Select\> 설정 추가. 그후 App.js에 해당 함수를 추가하여 전역 스타일 세팅 완료. 관리자 상품 관리 페이지의 \<Select\> 스타일 설정 삭제. 정상 출력 확인.   
       2. 테마색상 하이라이트의 전역 스타일이 필요한 다른 컴포넌트가 없는지 검토. \<Cascade\>, \<Table\>의 칼럼 드롭다운 필터를 전역 스타일 세팅. 관리자 상품 관리 페이지의 해당 스타일 설정 삭제. 정상 출력 확인.   
    9. 관리자 상품 관리 페이지 수정  
       1. 상품 품목 추가/수정 모달의 기능 테스트. 추가 기능은 정상 작동하나, 수정 기능은 오류나는걸 확인. 원인을 추적해보니 수정 시에는 API요청시 productItemId 정보를 담아서 넘겨야되는데, 해당 로직이 누락되어있기 때문인걸 확인. 해당 로직 추가하면서 API요청시 백엔드에서 받는 예외 메시지를 확실하게 받아서 처리할 수 있게 수정. 정상 작동 확인.  
       2. API요청 로직 하나 수정하면서 전반적으로 다시 검토해보니, 이 페이지의 로직을 리액트 구조 파악이 지금보다 부족할때 만들었다보니 API요청 로직이 어설픈 부분이 꽤 보임. 전체 API요청 로직을 다시 검토하여 어설픈 부분(특히 백엔드 에러 메시지 받는 코드)을 순차적으로 수정.  
13. 쇼핑몰 스프링 프로젝트 백엔드 작업  
    1. 상품 마스터 관련 API 수정  
       1. 직전 작업을 하면서 상품 마스터 관련 API를 다시 보다보니, 상품 마스터 이미지 업로드 비즈니스 로직과 이미지 조회 비즈니스 로직을 깜박하고 컨트롤러에 세팅한게 매우 거슬려보임. 원칙대로 비즈니스 로직을 서비스로 옮기는 작업 진행. 정리 할 수 있는만큼 정리하고, 기능에 문제없는지 테스트하여 정상작동 확인.  
       2. 이전 단계에서 테스트하면서 문제점을 발견했는데, 이미지가 이미 등록된 상품 마스터 정보를 수정하여 이미지를 삭제 처리해도 DB의 칼럼 데이터만 비워지고 실제 이미지는 백엔드 폴더에 그대로 존재함. 이를 해결하기 위해 상품 마스터 정보 수정 로직에서 이미지 목록에 빠지면 백엔드 폴더에서도 삭제하는 코드 추가. 테스트를 통해 정상 작동 확인.  
14. 쇼핑몰 리액트 프론트엔드 작업  
    1. 관리자 상품 관리 페이지 수정  
       1. 해당 메인 페이지의 표에서 이미지를 백엔드에서 불러와서 출력하는 로직이 이미지 URL을 직접 하드코딩하는 방식인게 거슬려보임. API 엔드포인트를 상수로 관리하고, 이미지 URL을 생성하는 함수를 별도로 만드는 것이 더 좋은 방식이라고 결론내리고 작업 진행. 이미지 URL을 생성하는 유틸리티 함수를 별도 파일로 빼서, 하드코딩 구조를 탈출함. 정상 작동 확인.  
       2. 재고 관리 모달의 스타일 속성 재정리 작업. 모달의 스타일 속성을 함수로 빼고, 공통 모달 스타일 적용. 랜더링 리턴 영역에 재고 관리 모달의 표 컬럼 설정이 들어가 있는게 거슬려서, 별도 함수로 빼서 불러오는 식으로 수정. 정상 작동 확인.  
       3. 재고 관리 모달의 스타일 속성 재정리 작업. 모달의 스타일 속성을 함수로 빼고, 공통 모달 스타일 적용. 랜더링 리턴 영역에 재고 관리 모달의 표 컬럼 설정이 들어가 있는게 거슬려서, 별도 함수로 빼서 불러오는 식으로 수정. 정상 작동 확인.  
       4. 재고 이력 모달의 스타일 속성 재정리 작업. 모달의 스타일 속성을 함수로 빼고, 공통 모달 스타일 적용. 랜더링 리턴 영역에 재고 관리 모달의 표 컬럼 설정이 들어가 있는게 거슬려서, 별도 함수로 빼서 불러오는 식으로 수정. 변경 전 상태 칼럼의 값이 null이라면 ‘입고’ 태그가 출력되도록 로직 추가. 정상 작동 확인.  
    2. 관리자 주문 관리 페이지 작업  
       1. 관리자 상품 관리 페이지에서 진행했던 API로직 정리를 따라서, 해당 페이지의 API로직 정리 진행. 로직을 더 깔끔하게 다듬고, 백엔드 에러 메시지를 제대로 받도록 하고, 리팩토링이 필요한 부분에 리팩토리 작업. 정상 작동 확인.  
       2. 해당 페이지의 스타일 속성 재정리 작업. 스타일 속성을 함수로 빼고, 전역 스타일에 편입시킬 부분은 편입시킴. 랜더링 리턴에 들어있는 비즈니스 로직을 별도 함수로 빼서 불러오는걸로 정리.   
       3. 주문 상세정보 모달의 스타일 속성 재정리 작업. 모달의 스타일 속성을 함수로 빼고, 공통 모달 스타일 적용. 랜더링 리턴에 들어있는 비즈니스 로직을 별도 함수로 빼서 불러오는걸로 정리. 2단 함수 구조로 되어있는 부분을 분리.   
       4. 주문 상세 정보 모달의 스타일 속성이 잘 정리됐는지 확인하는 과정에서, 표의 ‘상태’ 칼럼과 ‘배송 이력’ 칼럼의 내용 출력 세팅이 이상하다는걸 인지. ‘상태’ 칼럼은 초안 세팅할때 주문 품목 상태변경 이력을 단순히 세로로 줄줄히 출력하는 로직을 세팅 후, 더미데이터가 없어서 출력 확인을 못했었음. 기왕 이번에 코드 정리하는 김에 더미데이터를 넣고 출력을 확인해봤는데, 단순 나열 출력으로는 시간의 흐름에 따른 내용 파악이 힘들다는걸 깨달음. 그래서 ‘배송 이력’ 칼럼값과 마찬가지로 Timeline을 적용하도록 로직 수정. 문제는 Timeline 출력은 내용이 많아지면 세로로 길어져서, 표의 셀에 들어가는 양식으로는 아주 이상해지는 것이었음. 어떻게할까 고민하다가 ‘상태’ 칼럼은 단순히 현재 상태를 Tag로 출력하고, ‘배송 이력’ 칼럼은 ‘상세 보기’ 칼럼으로 교체하고 ‘배송 이력’ 버튼과 ‘상태 이력’ 버튼을 출력시키도록 수정. 그리고 ‘배송 이력’ 버튼과 ‘상태 이력’ 버튼은 각각 해당 내용의 모달이 나오도록 하고, 일단 각각의 모달을 대충 만들어 세팅. 정리가 다끝나면 모달을 제대로 세팅할 예정.  
       5. 이번에 모달 2개를 추가하면서 모달이 4개가 된데다 depth도 3단계까지 늘어버리는 바람에, 전체적으로 코드를 깔끔하게 정리할 필요성이 생겨버림. 특히 모달 랜더링 코드를 기존에 하던대로 랜더링 리턴 영역에 추가하자니, 랜더링 리턴 영역이 너무 길어져버려서 유지보수/관리가 힘들어짐. 이론적으로는 모달 코드를 각각 파일로 분리해서 땡겨오는 방식이 정석이긴한데, 메인 페이지와 모달들이 사용하는 함수가 거미줄처럼 엮여있다보니 여러 파일로 찢는 과정도 만만치않은데다 오히려 유지보수/관리가 힘들어지는 측면이 생겨서 선택하고 싶지 않음. 일단 지금처럼 한 파일에서 관리하되, 코드가 1000줄이 넘어가는만큼 엄청 긴것도 맞으니 비슷한 성격의 함수끼리 최대한 묶어서 최대한 유지보수/관리에 용이한 방향으로 결정. 문제는 함수 순서를 생각없이 바꾸다보면 의존성이 꼬여서 엉망이 되므로, 안꼬이게 고민을 잘 해야함. 그리고 비슷한 성격의 함수를 단순히 가까이 붙이기만 하는걸로는 부족함이 느껴져서 어떻게 할지 알아보다보니, 주석을 ‘//\#region …’와 ‘//\#endregion …’으로 감싸면 코드를 접을때 묶을 수 있는걸 알게되어 이걸 적용하기로 결정. 최종적으로 의존성 안꼬이게 함수 순서를 조정하면서 주석으로 그룹핑 작업 진행.  
       6. 주문 상세 정보 모달과 배송정보 입력 모달도 랜더링 리턴 밖의 함수로 옮김.  
       7. 주문 상세 정보 모달 표의 ‘상세보기’ 칼럼에 ‘배송 이력’ 버튼이 상시 출력되고 있는데, 배송전 시점의 상태들일때는 출력되면 안됨. 배송전 시점의 상태들일때는 ‘배송 ‘이력’ 버튼이 출력되지 않도록 수정. 정상 작동 확인.  
       8. 배송 이력 모달의 디자인 정리. 모달 폭을 타임라인 폭에 타이트하게 좁힘. 타임라인 항목끼리의 간격을 위해 하단 패딩이 기본값으로 들어가 있는거 때문에 마지막 항목 아래에 애매한 공백이 거슬려서, 전역 스타일에 타임라인 마지막 항목의 하단 패딩을 없애게 세팅.  
       9. 이런저런 테스트 중, 모달을 함수로 뺀 이후 ‘주문 상세 정보’ 모달이 한번에 열리는게 아니라 짧은시간동안 열렸다가 꺼졌다가 열리는 깜박임 현상 발견. 백엔드 터미널을 같이 보니 모달이 처음에 열린 후에 API 연동이 진행되고, 연동이 끝나면 모달이 꺼졌다가 다시 열리고 있었음. 원인을 추적해보니 모달의 API 코드쪽에 모달을 열고 닫는 로직이 꼬여있어서, 로직을 정리하는걸로 해결.  
       10. ‘주문 상세 정보’ 모달의 ‘배송이력’ 버튼을 통해서 ‘배송 이력’ 모달을 열때, ‘주문 상세 정보’ 모달이 깜박이는 현상을 추가로 발견. 이 문제는 주문 상세 정보 모달의 상태 관리 쪽 이슈인듯 한데, 해결하기 위해서 좀 건드려봤는데 너무 많은 부분의 코드를 건드려야하는데다 함수 순서까지 꼬여서 골치아파짐. 모달 깜박임 이슈가 모달을 함수로 뺀 다음부터 계속 발생하고 있는데, 하나를 해결하려고 할 때마다 들어가는 품이 너무 많아서 장점보다 단점이 많아짐. 결국 모달을 다시 랜더링 리턴 영역으로 돌려놓기로 결정.  
       11. 함수로 뺀 모달들을 다시 랜더링 리턴 영역으로 돌려놓음. 돌려놓고 오작동하는 부분 테스트해서 정상 작동하도록 수정.  
       12. 메인 페이지의 ‘상세보기’ 버튼을 통해 ‘주문 상세 정보’ 모달을 여는 로직이, 현재 버튼 클릭 후 API가 전부 불려와진 다음 모달이 열리는 방식이다보니 이 딜레이가 사용자 경험상 별로 안좋음. 버튼을 클릭하면 모달이 바로 열리되, API를 불러오는 동안은 스피너가 돌도록 수정. 정상 작동 확인.  
       13. 상태 변경 이력 모달 수정. 타임라인으로 내용을 출력하는게 초안이었는데, DB의 정보들이 충분히 담기지도 않을 뿐더러 세로로 길어지기만해서 부적절하다고 생각됨. 타임라인 세팅을 테이블 세팅으로 바꾸고, DB 테이블의 값을 조금만 정리해서 출력하는 방식으로 수정. 다른건 다 정상 출력되는데, ‘요청 수량’ 칼럼만 값이 출력이 안되는 문제 발생. 원인을 추적해보니 orderProducts 테이블과 orderProductHistoris 테이블에 칼럼명이 동일한 request\_quantity 칼럼이 존재해서, 매퍼에서 매핑할때 한쪽이 덮어씌워져서 값이 날라가기 때문이었음. 해결 방안은 몇가지 방향이 있었는데, 그중 최소한의 수정으로 해결될거라 생각한 orderProductHistoris 테이블의 해당 칼럼명을 request\_quantity\_record로 수정하는 방안으로 결정. 수정 이후 관련된 코드를 전부 수정. 문제가 해결된걸 확인.  
    3. 관리자 상품 관리 페이지 작업  
       1. 관리자 주문 관리 페이지 작업을 하면서 함수들을 그룹화하는걸 규격화했으므로, 직전에 작업한 관리자 상품 관리 페이지도 함수 그룹화 정리작업 진행.  
    4. 관리자 회원 관리 페이지 작업  
       1. 이번에 규격화된 방식대로 해당 페이지의 API로직 정리 진행. 로직을 더 깔끔하게 다듬고, 백엔드 에러 메시지를 제대로 받도록 수정. 정상 작동 확인.  
       2. 해당 페이지의 스타일 속성 재정리 작업. 스타일 속성을 함수로 빼서 정리.  
       3. 상세보기 모달의 스타일 속성 재정리 작업. 모달의 스타일 속성을 함수로 빼고, 공통 모달 스타일 적용. 여백이나 정렬이 자연스럽도록 수정. 상태 활성화/비활성화 버튼의 hover 세팅을 추가하여 자연스럽게 수정.  
       4. 메인 페이지의 ‘상세보기’ 버튼을 통해 ‘회원 상세 정보’ 모달을 여는 로직이, 현재 버튼 클릭 후 API가 전부 불려와진 다음 모달이 열리는 방식이다보니 이 딜레이가 사용자 경험상 별로 안좋음. 버튼을 클릭하면 모달이 바로 열리되, API를 불러오는 동안은 스피너가 돌도록 수정. 정상 작동 확인.  
       5. 이메일 검색창과 검색 버튼의 배치가 애매해서 수정. 둘 다 오른쪽 정렬하면서 검색창과 버튼을 딱 붙이고, 검색창 폭을 데스크톱 환경에서는 250px으로 고정하고 모바일 환경에서는 100%로 세팅. 정상 출력 확인.  
       6. 규격화한대로 함수 그룹화 정리작업 진행.  
    5. 관리자 리뷰 관리 페이지 작업  
       1. 해당 페이지의 스타일 속성 재정리 작업. 스타일 속성을 함수로 빼서 정리.  
       2. 상세보기 모달의 스타일 속성 재정리 작업. 모달의 스타일 속성을 함수로 빼고, 공통 모달 스타일 적용. 여백이나 정렬이 자연스럽도록 수정.  
       3. 메인페이지의 표 출력 로직을 랜더링 리턴 밖으로 빼고, 더 효율적인 코드로 수정. 정상 출력 확인.  
       4. 규격화한대로 함수 그룹화 정리작업 진행.  
15. 쇼핑몰 스프링 프로젝트 백엔드 작업  
    1. 결제 관련 API 수정  
       1. 관리자 결제 관리 페이지 프론트엔드 코드를 정리하려고 백엔드 코드를 보니, 결제 관련 API는 초안만 러프하게 잡아놓고 아직 손대지 않았다는걸 인지함. 프론트엔드 코드를 정리하기 위해서는 백엔드 코드가 먼저 정리되어야 하니, 결제 관련 API 수정 작업 진행.  
       2. 결제 관련 API들을 검토해보니 주로 서비스단계에서 검증 로직이나 예외 처리 로직등이 부족하여 전반적으로 엉성한 상황. 서비스단계의 처음부터 끝까지 모든 메서드를 검토하여 부족한 로직을 보강하고, 코드를 리팩토링하여 개선 및 최적화. 서비스단계에서 수정한 메서드에 연동되는 컨트롤러단계의 코드를 전부 수정.  
       3. 이번에 서비스 단계의 메서드가 많이 추가되면서 체계적인 정리의 필요성이 느껴져, 모든 메서드를 재배치하여 그룹화 작업 진행.  
16. 쇼핑몰 리액트 프론트엔드 작업  
    1. 관리자 리뷰 관리 페이지 작업  
       1. 이번에 규격화된 방식대로 해당 페이지의 API로직 정리 진행. 로직을 더 깔끔하게 다듬고, 백엔드 에러 메시지를 제대로 받도록 수정. 정상 작동 확인.  
       2. 모바일 환경에서 검색 영역의 일부 항목이 잘리는 문제 발견. 데스크탑 환경의 배치는 그대로 유지하고, 모바일 환경에서는 폭을 넘어가는 항목이 생기면 줄바꿈이 되도록 수정하여 해결.  
       3. 규격화한대로 함수 그룹화 정리작업 진행.  
    2. 관리자 주문 관리 페이지 작업  
       1. 관리자 리뷰 관리 페이지의 검색영역 항목 구성과 해당 페이지의 검색영역 항목 구성이 동일하여, 모바일 환경에서 동일 문제가 발생하는지 확인해보니 동일 문제 존재 확인. 관리자 리뷰 관리 페이지에서 해결한 방법을 동일하게 적용하여 해결.  
    3. 장바구니 페이지 작업  
       1. 이번에 규격화된 방식대로 해당 페이지의 API로직 정리 진행. 로직을 더 깔끔하게 다듬고, 백엔드 에러 메시지를 제대로 받도록 수정. 정상 작동 확인.  
       2. 코드를 검토해보니 칼럼 정의에 복잡한 렌더링 로직과 이벤트 핸들러가 직접 포함되어 있어 코드가 복잡한 상황. 리팩토링을 통해 코드 정리.  
       3. 규격화한대로 함수 그룹화 정리작업 진행.  
    4. 카테고리 페이지 작업  
       1. 이번에 규격화된 방식대로 해당 페이지의 API로직 정리 진행. 로직을 더 깔끔하게 다듬고, 백엔드 에러 메시지를 제대로 받도록 수정. 정상 작동 확인.  
       2. 규격화한대로 함수 그룹화 정리작업 진행.  
       3. 출력되는 페이지를 보니, 헤더 영역에 현재 중앙의 '카테고리 타이틀'과 우측에 '정렬 드롭다운'만 존재하는 상황. 비어있는 왼쪽에 해당 카테고리의 상품 마스터 개수를 출력하는게 좋겠다는 생각이 들어서, 해당 코드 추가. 정상 출력 확인.  
    5. AuthContext 작업  
       1. 비밀번호 재설정 페이지의 API 로직을 최적화하려고 코드를 보니, 인증 관련 로직을 담당하는 AuthContext를 먼저 정리해야해서 작업에 들어감.  
       2. 회원가입 처리 API 로직, 로그인 API 로직을 규격화 한대로 정리 진행. 로직을 더 깔끔하게 다듬고, 백엔드 에러 메시지를 제대로 받도록 수정. 정상 작동 확인.  
       3. 로그아웃 API 로직을 규격화 한대로 정리 진행. 작동 테스트를 했을때 기본 기능은 작동하는데, 홈페이지로 강제 이동하기 직전에 레이아웃 헤더가 비로그인 상태 메뉴로 먼저 바뀌는게 사용자에게 보이는 문제와 레이아웃 코드에서 설정한 로그아웃 성공 메세지가 출력되지 않는 문제를 발견. 첫번째 문제는 인증정보 초기화가 홈페이지 강제이동보다 먼저 작동하면서 생기는걸로 보이는데, 어차피 레이아웃의 로그아웃 로직에 홈페이지 강제이동이 포함되어 있어 중복이기도 함. 일단 홈페이지 강제이동은 레이아웃에서 관리하도록 일원화하고 조정하는걸로 결정. 두번째 문제도 레이아웃 코드쪽에서 꼬인걸로 추측되어 레이아웃 작업으로 잠깐 넘어감.  
    6. Layout 컴포넌트 작업  
       1. AuthContext의 두번째 문제는 handleLogout 함수의 로직 순서를 조정하는걸로 해결됨. 하지만 홈페이지 강제이동과 함께 헤더의 카테고리 네비게이션 초기화를 세팅한게 작동하지 않는 새로운 문제 발생. navigate 옵션에 replace: true를 추가하여 브라우저의 히스토리 스택에서 현재 페이지를 대체하는걸로 그 문제는 해결했으나, 이제는 홈페이지 영역이 두 번에 걸쳐 로딩되는 또다른 문제가 발생. 상태 초기화가 두 번 일어나는 로직 구조가 원인이라 상태 초기화가 한 번만 일어나도록 순서를 조정하는걸로 그 문제도 해결.  
       2. AuthContext의 첫번째 문제는 두번째 문제를 해결하면서 같이 해결됨.  
    7. AuthContext 작업  
       1. 회원가입 처리 API 로직, 로그인 API 로직을 규격화 한대로 정리 진행.  
    8. 비밀번호 재설정 페이지 작업  
       1. 이번에 규격화된 방식대로 해당 페이지의 API로직 정리 진행. 로직을 더 깔끔하게 다듬고, AuthContext의 에러 메시지를 제대로 받도록 수정. 정상 작동 확인.  
    9. 홈페이지 작업  
       1. 이번에 규격화된 방식대로 해당 페이지의 API로직 정리 진행. 로직을 더 깔끔하게 다듬고, 백엔드 에러 메시지를 제대로 받도록 수정. 리팩토링이 필요한 부분이 있어서 수정. 정상 작동 확인.  
    10. 로그인 페이지 작업  
        1. 이번에 규격화된 방식대로 해당 페이지의 API로직 정리 진행. 로직을 더 깔끔하게 다듬고, AuthContext의 에러 메시지를 제대로 받도록 수정. 관리자 계정으로 일반 로그인 시도시 관리자 로그인 페이지로 넘어가는 로직 추가. 정상 작동 확인.  
        2. 추가로 테스트하면서 문제가 발견됐는데, 관리자 계정으로 일반 로그인 시도시 관리자 로그인 페이지로 넘어가는건 문제없으나 이후 홈페이지에 접속하면 인증 정보가 유지되어 장바구니나 마이페이지 버튼이 활성화됨. 관리자 로그인 페이지로 넘어가기 전에 인증정보를 초기화하는 로직 추가. 정상 작동 확인.  
    11. 마이페이지 주문 관리 페이지 작업  
        1. 이번에 규격화된 방식대로 해당 페이지의 API로직 정리 진행. 로직을 더 깔끔하게 다듬고, AuthContext의 에러 메시지를 제대로 받도록 수정. 현재 확인할 수 있는 API로직들은 정상 작동 확인.  
        2. 해당 페이지의 스타일 속성 재정리 작업. 기존에 일부 정리된 부분도 있었지만, 부족한 부분이 많아서 해당 부분들의 스타일 속성을 함수로 빼서 정리.  
        3. 모바일 환경에서 Table이 아닌 Card로 출력하는 로직을 랜더링 리턴 영역에서 빼서 함수로 분리. 정상 작동 확인.  
        4. 메인 Table의 ‘상품정보’ 칼럼, ‘주문상태’ 칼럼, ‘작업’ 칼럼, ‘상세’ 칼럼의 랜더링 코드를 빼서 함수로 분리. 특정 상태에서 ‘작업’ 칼럼의 버튼이 여러개 출력될때 왼쪽 정렬되는 문제 발견. 해당 상황일때 가운데 정렬되도록 코드 추가. 정상 작동 확인.  
        5. 배송 정보 모달의 Timeline의 items 설정 로직도 함수로 분리. 정상 작동 확인.  
        6. 규격화한대로 함수 그룹화 정리작업 진행.  
    12. 마이페이지 회원정보 관리 페이지 작업  
        1. 이번에 규격화된 방식대로 해당 페이지의 API로직 정리 진행. 로직을 더 깔끔하게 다듬고, AuthContext의 에러 메시지를 제대로 받도록 수정. 현재 확인할 수 있는 API로직들은 정상 작동 확인.  
        2. 테스트 중 정보 수정 모달의 연락처 입력란의 조건 필터가 ‘-’를 포함해야한다고 세팅되어있는데, 전에 숫자만 DB에 저장하기로 방향을 수정한게 반영이 안되있는 상황. 조건 필터에 숫자만 입력하도록 수정.  
        3. 테스트 중 비밀번호 변경 모달의 ‘새 비밀번호’ 입력창에 조건 필터가 부족하게 있는걸 확인하여 수정.  
        4. 규격화한대로 함수 그룹화 정리작업 진행.  
    13. 상품 마스터 페이지 작업  
        1. useEffect 안에 API 요청 함수가 여러개 들어있는 등 리팩토링 필요한 부분이 존재. 리팩토링하여 더 깔끔하게 정리.  
        2. 이번에 규격화된 방식대로 해당 페이지의 API로직 정리 진행. 로직을 더 깔끔하게 다듬고, AuthContext의 에러 메시지를 제대로 받도록 수정. 정상 작동 확인.  
    14. 로그인 페이지 & 레이아웃 컴포넌트 작업  
        1. 수정 후 테스트 중, '특정 페이지에서 로그인 페이지 접속\>로그인 페이지를 통해 로그인\>무조건 홈페이지 이동'으로 작동하는걸 발견. 원래 로그인 후에는 로그인 페이지에 접속했었던 페이지로 돌아가야 사용자 경험에 더 적절한데, 지금 작동은 문제가 있음. 해결을 위해 레이아웃의 로그인 버튼을 눌렀을때 현재 url 정보를 state로 저장하는 코드를 추가하고, 로그인 페이지의 로그인 성공 로직에서 state에 저장된 url 정보가 있다면 불러오는 코드를 추가. 테스트해보니 로그인 전의 페이지로 돌아가는 기능 자체는 작동하지만, 진입 전에 전달받아야할 정보가 필요한 카테고리 페이지의 경우 로그인 페이지를 거쳐서 돌아오게되면 내용이 정상출력되지 않는 문제가 발생. 해결을 위해 레이아웃의 로그인 버튼을 눌렀을때 카테고리 정보를 state로 저장하는 코드를 추가하고, 로그인 페이지의 로그인 성공 로직에서 state에 저장된 카테고리 정보가 있다면 불러오는 코드를 추가. 정상 작동 확인.  
    15. 레이아웃 컴포넌트 작업  
        1. 테스트 중, 카테고리 페이지에서 로그아웃하면 강제로 홈페이지로 이동하고 상품 마스터 페이지에서 로그아웃하면 페이지가 유지되는 상황 발견. 페이지가 다르더라도 레이아웃의 로그아웃 로직이 수행되는건 같음에도 불구하고, 다른 동작이 일어나는건 사용자 경험에 문제가 있음. 원인을 분석해보니 로그아웃 로직에 state를 초기화하면서 홈페이지로 강제이동시키는데, state 정보로 랜더링을 하는 카테고리 페이지는 홈페이지로 강제 이동하게되고 반면 URL 파라미터로 랜더링을 하는 상품 마스터 페이지는 영향을 안받아 정상 랜더링을 유지하는 차이 때문이었음. 고민해본 결과 사용자 경험상 로그아웃시 페이지가 유지되는게 더 낫다는 결론이 나와서, 로그아웃 로직에 state 초기화 로직을 삭제하고 현재 페이지에 머물도록 수정. 정상 작동 확인.  
    16. 상품 마스터 페이지 작업  
        1. 전역 스타일 설정과 겹치는 스타일 코드 삭제.  
        2. 랜더링 리턴 영역에 포함된 비즈니스 로직들을 함수(const getSizeOptionStatus, const getColorOptionStatus, const handleCartButtonClick)로 빼냄. 정상 작동 확인.  
    17. 장바구니 로직 수정  
        1. 상품 마스터 페이지 수정 후 테스트 중, 장바구니 담기 기능에 문제를 발견. 장바구니에 특정 상품을 처음 담을 때는 문제없는데, 장바구니에 존재하는 상품을 담을때 설정한 수량의 두 배가 담기는 상황. 분석해보니 로직 흐름이 ‘장바구니 추가 버튼 클릭\>상태변경 함수1\>상태변경 함수2’이다보니 의존성 체인에 걸려서 버튼을 한번만 클릭해도 두번 시행되는 결과가 나오는 걸로 추정됨. 검토해보니 딱히 재사용되는 로직이 아닌데도 함수가 분리되어 있다고 생각하여, 상태변경 함수 둘을 하나로 합치는 작업 진행. 거기에 더해서 CartContext에서 불러오는 addToCart 함수에 원본 객체를 참조하여 갱신하는 부적절한 로직이 있어서 모든 객체가 새로 생성되도록 로직을 수정하고, addToCart 함수내에 setCartItems 함수가 들어있는 중첩구조라서 중첩이 풀어지도록 수정하고, 장바구니 추가 버튼 클릭 로직에 현재 장바구니 수량까지 고려하여 재고수량 이상의 추가를 막는 로직이 빠져있어서 추가. 정상 작동 확인.  
        2. 장바구니에 들어있는 상품의 수량을 조절하는 버튼을 눌렀을때, 상품 이미지가 재로딩되며 깜박이는 부자연스러운 현상 발견. 모바일 환경 랜더링의 경우 \<Card\>로 출력되어 cartItems 변수에 useMemo 세팅을 하는걸로 해결했으나, 데스크톱 환경 랜더링의 경우 \<Table\>로 출력되어 같은 방안으로 해결되지 않고 다른 다양한 시도들도 적용이 안되어 포기.  
    18. 상품 마스터 페이지 작업  
        1. 규격화한대로 함수 그룹화 정리작업 진행.  
    19. 회원가입 페이지 작업  
        1. 랜더링 리턴 영역에 포함된 비즈니스 로직을 함수(const validateConfirmPassword)로 빼냄. 정상 작동 확인.  
        2. 스타일 함수들만 그룹화  
    20. 비밀번호 재설정 페이지 작업  
        1. 랜더링 리턴 영역에 포함된 비즈니스 로직을 함수(const validateConfirmPassword)로 빼냄. 정상 작동 확인.  
        2. 스타일 함수들만 그룹화  
    21. 상품 마스터 카드 컴포넌트 작업  
        1. 전에 이미지 영역을 세팅할때 이미지들을 넘길 수 있도록 작은 dot을 하단에 출력시켰는데, 아무리봐도 데스크톱 환경에서는 허용되는 방식이라고 쳐도 모바일 환경에서는 가시성이나 직관성이 떨어진다고 판단. 좌하단과 우하단에 화살표 아이콘을 배치하는 방식으로 수정해봤으나 마음에 안들어서, 중앙 왼쪽과 중앙 오른쪽에 화살표 아이콘을 배치하는 방식으로 재수정. 괜찮아보여서 클릭했을때 이미지가 넘어가는 로직을 세팅. 정상 작동 확인.  
        2. 전에 이미지들이 순서대로 출력되게 세팅했었는데, 아무 애니메이션이 없이 단순히 깜박이며 교체되는 중. 슬라이딩 애니메이션을 적용시키는게 자연스럽다고 생각하여, \<img\> 태그의 속성을 건드리며 수정 시도. 이런저런 방식을 적용해봤지만 깔끔하게 안되서 고민하다가, ant의 Carousel이 있다는걸 떠올림. 간단히 테스트해보니 내가 원하는 애니메이션을 구현할 수 있는게 확인되어, ant의 Carousel을 도입하여 수정. 정상 작동 확인.  
    22. 주문 페이지 작업  
        1. 장바구니에서 주문 버튼에서 넘어갈 주문 페이지가 필요. 초안 작업 시작.  
    23. PaymentContext 작업  
        1. 주문 페이지 작업을 하다보니, 결제 관련 상태와 메서드들을 한 곳에서 관리하는 파일이 필요함을 느낌. 일단 러프하게 초안을 만들고 App.js에서 Provider를 추가.  
    24. App.js 작업  
        1. PaymentProvider를 추가하는 김에 코드에 문제가 없나 전반적으로 검토. 중첩된 라우팅이나 반복되는 래핑이 있어서 비효율적인 상태임. 중첩된 라우팅은 풀어내서 depth를 한단계 낮추고, 반복되는 래핑은 공통 라우트로 묶어서 코드 중복 이슈 해소. 반복되는 래핑을 공통 라우트로 묶게되면서 상위 라우트가 자식 라우트를 렌더링 하는 코드를 수정해야하는걸로 확인됨. 기존 상위 라우트 리턴에 {children}으로 세팅한 부분을 \<Outlet /\> 컴포넌트 세팅으로 수정. 정상 작동 확인  
    25. PaymentContext 작업  
        1. 초안을 검토하며 로직 추가 및 보완. 상수들은 파일로 별도로 분리. 포트원 SDK 초기화 및 환경변수 검증용 useEffect 세팅. 결제 준비 함수, 가상계좌 발급 함수, 결제 요청 함수, 결제 검증 함수, 결제 취소 함수, 결제 이력 조회 함수들, 관리자용 결제 이력 검색 함수, 유효성 검사 함수, 에러 처리 함수 최적화.  
        2. 여기서 사용할 포트원 가맹점 식별코드를 환경변수로 세팅.  
    26. 주문 페이지 작업  
        1. PaymentContext를 기반으로 초안 수정. 결제 관련 로직 모듈화, 가상계좌 지원 추가, 에러 처리 강화, UX 개선 등 진행.   
    27. imageUtils 작업  
        1. 테스트를 위해 주문 페이지를 출력해보는데, 상품 이미지를 세팅하는 코드가 여러 파일에서 비슷한 방식으로 별도 존재한다는걸 깨달음. 코드 중복 개선 및 유지보수 용이화를 위해 별도로 분리하기위해 검토하다보니, 전에 같은 목적으로 만든 imageUtils.js를 제대로 활용 못하고 있었다는걸 알게됨. imageUtils가 관리자 상품 관리 페이지에서만 불려가고, 다른 페이지에는 안불려가고 있던 상황. imageUtils의 코드를 전면 재검토하여 다양한 파일에서 불려가도 문제없도록 개선 작업 진행(기본 이미지 상수 추가, null 대신 기본 이미지 반환, 모든 이미지 URL을 반환하는 옵션 추가, JSDoc 문서화 추가). 상품 마스터 카드 컴포넌트, 장바구니 페이지, 주문 페이지에서 상품 이미지를 불러올때 호출하도록 수정. 정상 작동확인.  
17. 쇼핑몰 스프링 프로젝트 백엔드 작업  
    1. DB orders 테이블 수정  
       1. 주문페이지를 출력해서 검토해봤는데, 배송주소에 대한 세팅을 어떻게하는게 좋을지 결정해야함. 현재 orders 테이블에는 배송주소 관련하여 recipient\_address 칼럼 하나만 세팅되어있음. 회원정보의 주소도 원래 칼럼 하나였는데, 수정시 다음 주소찾기 양식에 맞춰 다시 불러올 경우가 생기니 칼럼을 3개(우편번호/기본주소/상세주소)로 쪼깨는 수정을 했었음. 하지만 배송주소는 결제대기 상태일때만 다시 수정한다고 봐야하는데, 대부분의 경우 결제창을 지나면 결제대기가 생략된 상태가 될거라고 봐야해서 다시 불러올 일이 거의 없을걸로 생각됨. 이쪽 이슈는 신경안써도 된다고 치면 결국 핵심은 포트원 API 규격이라고 봄. 찾아보니 포트원 API 규격상 주소 정보는 ‘우편번호’와 ‘주소’ 항목으로 구성되어있다고하여 여기에 맞추기로 결정.  
       2. 포트원 API 규격에 맞춰 orders 테이블의 recipient\_address 칼럼 윗줄에 recipient\_postcode 칼럼 추가. 새로운 칼럼 추가에 따른 VO, Mapper, DTO, Service의 관련 코드 추가.  
18. 쇼핑몰 리액트 프론트엔드 작업  
    1. 주문 페이지 작업  
       1. DB orders 테이블에 우편번호 칼럼을 추가했으니, 주문 페이지의 로직 중 정보를 포장하는 코드에 우편번호 항목 추가.  
       2. 배송주소 입력창 배치가 이상해서, 자연스럽도록 수정.  
       3. 배송정보 섹션의 입력란에 기본값으로 회원정보를 넣는게 사용자 경험에 좋기 때문에, 사용자 정보를 조회한 다음 입력란에 기본값으로 넣는 로직 추가. 정상 작동 확인.  
       4. 출력되는 항목들을 검토중 현재 결제수단을 선택하는 섹션을 보다가, 문득 결제버튼을 누르면 나오는 포트원 결제창에서 결제수단을 선택하는 방식이라면 결제수단 선택 섹션이 의미가 없겠다는 생각이 듦. 포트원 결제창에 대해 확인해보니, 프론트엔드에서 결제수단 정보를 넘긴 후 해당 결제수단의 포트원 결제창이 뜨는 방식도 있고 포트원 통합결제창에서 결제수단을 사용자가 고르는 방식이 있다고 함. 나는 포트원 통합결제창을 연동하기로 결정. 따라서 결제수단 선택 섹션과 그 관련 로직이 필요없어졌으므로, 해당 코드들을 삭제.  
    2. PaymentContext 작업  
       1. 포트원 통합결제창을 연동하기로 했으니, PaymentContext의 결제수단 관련 코드들도 필요없어졌음. 해당 코드들 삭제.  
    3. 주문 페이지 작업  
       1. 결제 버튼을 눌렀을때 포트원 결제창이 뜨는지 테스트 해봤는데, 결제창은 열리지 않고 포트원 SDK가 초기화되지 않았다는 콘솔 로그가 확인됨. 원인을 찾다보니 public/index.html에 포트원 SDK 스크립트가 포함되어 있어야한다고 하여, \<body\> 마지막에 V2 스크립트 추가. 그래도 문제가 해결되지 않았고, 이런 경우 체크해 볼 모든 요소들(포트원 SDK 스크립트 세팅, 포트원 관련 환경변수 세팅, 결제 요청 로직의 PG 설정)을 모두 검토해봐도 방법을 모르겠음.  
       2. 이정도로 문제가 해결되지 않으면 원점에서부터 다시 짚어가야 된다고 생각하여, 포트원 사이트에 접속하여 단서가 있는지 체크. ‘연동 정보’ 메뉴에 들어가서 예전에 개설했던 테스트 채널 등 단서가 될만한걸 찾다보니, 서서히 뭐가 문제인지 보이기 시작했음. 지금까지 내가 찾고 시도했던 방식이 V2 쪽인줄 알았는데 알고보니 V1 쪽의 방식이었다는걸 깨달음. 예전 작업 기록을 찾아보니 포트원에서 더 추천하는 방식이 V2라서 V2로 구현하기로 마음먹었었는데, 지금 시점에 자료를 추가로 찾아보니 초보 개발자가 구현하기에는 V1이 더 적절하다고 함. 어떻게 할지 고민하다가 일단 V1 구현으로 선회하고, 백엔드 쪽의 V2 세팅은 나중에 수정하기로 결정.  
       3. V1 구현으로 방향이 확실히 잡혔으니, 그에 맞춰 수정 진행. public/index.html의 스크립트를 V1으로 변경하고, 환경변수에 V1 해당 코드로 수정하고, 테스트 채널로 열어둔 토스페이먼츠로 pg 항목 세팅을 변경. 드디어 결제버튼을 누르면 토스페이먼츠의 결제창이 뜨게하는데 성공.  
       4. 결제를 진행하지 않고 결제창을 닫았을때 출력되는 메시지가 가공되지 않은 포트원의 메시지라 문제가 있다고 생각하여, 적절하게 가공된 메시지가 출력되도록 수정.  
       5. 포트원 결제창에서 연동되는 기능 구현은, 다른 작업 이후로 홀딩.  
19. 쇼핑몰 리액트 프론트엔드 작업  
    1. 관리자 대시보드 페이지 작업  
       1. 대시보드 통계 중 ‘주문 수’와 ‘매출’ 항목에 실제 서비스와 가깝게 하고 싶어서 이번달 기준으로 출력하도록 세팅했었는데, 실제 주문자가 없는 포트폴리오 서비스다보니 나중에는 항목에 0만 출력되는 문제가 예상됨. 따라서 이번달 기준으로 출력하는 세팅을 전체 기준으로 출력하도록 수정.  
       2. 비교적 프로젝트 초반에 세팅한 페이지라 수정 및 정리가 많이 필요하다고 판단하여 전면적으로 수정 작업 시작.  
       3. 랜더링 리턴 영역의 스타일 설정을 분리하고, 전역 스타일과 겹치는 코드 삭제. 모바일 환경에서 디자인이 애매한 부분들 수정(최상위 컨테이너의 패딩 영역 확보, 헤더 우측 버튼 크기 축소, 통계 항목 카드 간격 최적화, 뷰포트 아래로 넘치면 스크롤 활성화, 푸터 높이 정상화). 데스크탑 환경에서도 디자인이 이상한 부분들 수정(\<ContentContainer\> 하단의 의미불상의 빈공간 삭제, 통계 카드 행 영역의 폭이 상위 영역보다 넓은 현상 해결  
       4. fetchDashboardData 함수 내부에 함수들이 들어가있는 중첩 구조라서 문제가 있음. 내부의 함수들을 밖으로 적절히 분리하여 리팩토링(fetchTotalUsers, fetchOrders, fetchPayments, fetchTotalReviews, formatOrderData, calculateTotalRevenue).   
       5. fetchOrders의 경우 전체 주문 리스트를 API로 조회한 후 프론트엔드에서 카운팅하는 로직과 최근 주문 리스트를 API로 조회하는 로직이 같이 있어서, 각각의 API를 별도의 함수로 추가 분리(fetchTotalOrders, fetchRecentOrders).  
20. 쇼핑몰 스프링 프로젝트 백엔드 작업  
    1. 총 주문 수 조회 전용 API 작업  
       1. 앞서 언급된 fetchTotalOrders로 전체 주문 리스트를 API로 조회한 후 프론트엔드에서 총 주문 수를 카운팅하는 방식인데, 더 리소스를 줄이는 방안이 있다고 판단. 따라서 SQL 쿼리에서 총 주문수를 카운팅 해서 토스하는 ‘총 주문수 조회 전용 API’를 별도로 제작.  
    2. 총 매출액 조회 전용 API 작업  
       1. 앞서 언급된 fetchPayments로 전체 결제 리스트를 API로 조회한 후 프론트엔드에서 결제완료 상태만 필터링하고 총 매출액을 계산하는 방식인데, 더 리소스를 줄이는 방안이 있다고 판단. 따라서 SQL 쿼리에서 총 매출액을 계산해서 토스하는 ‘총 매출액 조회 전용 API’를 별도로 제작.  
21. 쇼핑몰 리액트 프론트엔드 작업  
    1. 관리자 대시보드 페이지 작업  
       1. fetchTotalOrders 로직을, 앞서 제작한 ‘총 주문수 조회 전용 API’로 대체.   
       2. fetchPayments 로직을 삭제하고, 앞서 제작한 ‘총 매출액 조회 전용 API’로 fetchTotalRevenue 함수를 새로 제작.  
       3. 함수들 재배치 및 그룹화.  
    2. 관리자 레이아웃 컴포넌트 작업  
       1. 랜더링 리턴 영역의 스타일 설정을 밖으로 빼내는 작업 진행. 모바일 환경에서 어색하게 출력되는 드로어 타이틀 높이 수정.  
       2. 권한검증 useEffect 로직을 리팩토링. 함수들 재배치 및 그룹화.  
    3. 레이아웃 컴포넌트 작업  
       1. 중첩구조의 함수들을 리팩토링 작업 진행. 모바일 화면 크기 체크 useEffect 내부에서 const checkMobile 분리. 카테고리 경로 조회 useEffect 내부에서 const fetchTopCategories, const fetchSubCategories 분리. 카테고리 정보 업데이트 useEffect 내부에서 const updateCategoryInfo 분리.  
       2. 최근 규격화한대로 API 로직 최적화(const fetchTopCategories, const fetchSubCategories, const handleCategoryClick). 특히 초반 작업물이다보니 API 처리 중 예외 발생시 error state에 메시지를 저장하여 뷰포트에 출력하는 방식이 현재 규격화된 방식과 맞지 않아, App의 message로 오류 메시지를 출력하도록 수정하는 작업도 진행.  
       3. 최근 규격화한대로 함수 그룹화와 재정렬 진행.  
22. 쇼핑몰 스프링 프로젝트 백엔드 작업  
    1. 결제 관련 API 로직 작업  
       1. 전에 결제 관련 API 로직을 초안을 러프하게 제작한 후 자세한 검토는 보류했다가, 얼마전 관리자 대시보드 페이지 작업을 하다가 훑어보게 됐는데 서비스 단계 코드가 좀 이상해보여서 전면 재검토를 결정.  
       2. 서비스 단계 함수들에 try-catch 구조가 있는건 다시보니 어색해보여서 추가로 확인해보니, 컨트롤러 단계에 이미 try-catch 구조가 있다면 서비스 단계의 try-catch 구조는 특별한 경우가 아니면 불필요한게 맞음. 전면 수정을 결정.  
       3. 서비스 단계의 public PaymentInfoDTO createPaymentInfo 함수와 연결된 함수들에 있는 try-catch 구조 해제. 그리고 이와 연동되는 컨트롤러의 public ResponseEntity\<?\> preparePayment 함수의 catch 커버리지가 누락된 부분을 보강하고 코드 정리.  
       4. 서비스 단계의 public PaymentDataDTO verifyPayment 함수와 연결된 함수들에 있는 try-catch 구조 해제하고, 재사용성이 없지만 분리된 함수를 흡수시킴. 그리고 이와 연동되는 컨트롤러의 public ResponseEntity\<?\> verifyPayment 함수의 catch 커버리지가 누락된 부분을 보강하고 코드 정리.  
       5. 서비스 단계의 public PaymentDataDTO cancelPayment 함수와 연결된 함수들에 있는 try-catch 구조 해제하고, 재사용성이 없지만 분리된 함수를 흡수시킴. 그리고 이와 연동되는 컨트롤러의 public ResponseEntity\<?\> cancelPayment 함수의 catch 커버리지가 누락된 부분을 보강하고 코드 정리.  
       6. 서비스 단계의 public PaymentDataDTO cancelPayment 함수와 연결된 함수들에 있는 try-catch 구조 해제하고, 재사용성이 없지만 분리된 함수를 흡수시킴. 그리고 이와 연동되는 컨트롤러의 public ResponseEntity\<?\> cancelPayment 함수의 catch 커버리지가 누락된 부분을 보강하고 코드 정리.  
       7. 서비스 단계의 public VirtualAccountDTO requestVirtualAccount 함수와 연결된 함수들에 있는 try-catch 구조 해제하고, 재사용성이 없지만 분리된 함수를 흡수시킴. 그리고 이와 연동되는 컨트롤러의 public ResponseEntity\<?\> requestVirtualAccount 함수의 catch 커버리지가 누락된 부분을 보강하고 코드 정리.  
       8. 서비스 단계의 public void processWebhook 함수와 연결된 함수들에 있는 try-catch 구조 해제하고, 재사용성이 없지만 분리된 함수를 흡수시킴. 그리고 이와 연동되는 컨트롤러의 ResponseEntity\<?\> handleWebhook 함수의 catch 커버리지가 누락된 부분을 보강하고 코드 정리.  
       9. 서비스 단계의 public PaymentHistory getPaymentHistoryByImpUid 함수와 연결된 함수들에 있는 try-catch 구조 해제하고, 재사용성이 없지만 분리된 함수를 흡수시킴. 그리고 이와 연동되는 컨트롤러의 public ResponseEntity\<?\> getPaymentHistoryByImpUid 함수의 catch 커버리지가 누락된 부분을 보강하고 코드 정리.  
       10. 서비스 단계의 public PaymentHistory getPaymentHistoryByMerchantUid 함수와 연결된 함수들에 있는 try-catch 구조 해제하고, 재사용성이 없지만 분리된 함수를 흡수시킴. 그리고 이와 연동되는 컨트롤러의 public ResponseEntity\<?\> getPaymentHistoryByMerchantUid 함수의 catch 커버리지가 누락된 부분을 보강하고 코드 정리.  
       11. 서비스 단계의 public PaymentHistory getPaymentHistoryByOrderId 함수와 연결된 함수들에 있는 try-catch 구조 해제하고, 재사용성이 없지만 분리된 함수를 흡수시킴. 그리고 이와 연동되는 컨트롤러의 public ResponseEntity\<?\> getPaymentHistoryByOrderId 함수의 catch 커버리지가 누락된 부분을 보강하고 코드 정리.  
       12. 서비스 단계의 public PaymentHistorySearchResultDTO searchPaymentHistory 함수와 연결된 함수들에 있는 try-catch 구조 해제. 그리고 이와 연동되는 컨트롤러의 public ResponseEntity\<?\> searchPaymentHistory 함수의 catch 커버리지가 누락된 부분을 보강하고 코드 정리.  
       13. 서비스 단계의 public int getTotalRevenue 함수가 int가 아닌 BigDecimal을 받도록 하류(DAO, Mapper)의 로직을 수정하여 public BigDecimal getTotalRevenue로 수정. 컨트롤러 단계의 public ResponseEntity\<?\> getTotalRevenue 함수도 맞춰서 수정하고, catch 커버리지가 누락된 부분을 보강하고 코드 정리.  
       14. 핵심 API 함수들의 수정 이후, 서비스 단계의 함수들을 전면 검토하여 수정이 필요한 부분 수정.  
       15. 모든 해당 서비스 단계 함수들의 예외 처리 로직에 DB 기록 코드 추가.  
       16. 모든 해당 컨트롤러 단계 함수들의 비설정 예외 처리시에도 DB에 기록 코드 추가.  
23. 쇼핑몰 리액트 프론트엔드 작업  
    1. 상품 마스터 페이지 작업  
       1. ‘상품 리뷰’ 항목이 누락되어 추가하는 작업 진행. 리뷰 조회 API를 연동하는 함수를 만들고,‘상품 정보’ 항목 아래에 \<Title\> \+ \<Card\> \+ \<List\> 구성으로 세팅하여 리뷰를 출력하는 초안 세팅.   
       2. 세팅한 초안이 출력은 되는데 디자인을 어떻게 잡아야할지 고민해야 하는 상황. 로직들을 검토하면서 디자인을 고민하다보니, DB reviews 테이블 칼럼 중 productId이 잘못 세팅된걸 깨달음. 왜냐하면 회원이 주문하는 기본 단위가 상품 품목(productItem)인데 상품 마스터(product)의 ID를 칼럼으로 세팅했기 때문에, 현재 세팅으로는 리뷰한 상품 품목의 정보를 출력하기 힘들어지게 됨. 결국 칼럼 수정이 필요한 상황.  
24. 쇼핑몰 스프링 프로젝트 백엔드 작업  
    1. DB reviews 테이블 수정 & 관련 로직들 수정  
       1. productId 칼럼을 productItemId 칼럼으로 수정.  
       2. productId 칼럼이 로직에 포함되어 있던 VO, Mapper, Service, DTO의 코드들을 수정.  
25. 쇼핑몰 리액트 프론트엔드 작업  
    1. 상품 마스터 페이지 작업  
       1. 백엔드 수정에 맞춰서 리뷰 조회 API 로직을 수정해야하는데, 단순히 productId을 productItemId로 변경하는걸로는 문제가 있는 상황. 왜냐하면 상품 마스터 하나에 상품 품목 여러개가 포함되어 있으므로, 상품 마스터 페이지의 리뷰 조회를 하려면 API 요청시 여러 상품 품목을 백엔드로 넘겨서 처리하도록 백엔드 로직을 뜯어고쳐야 하기 때문. 일단 API 요청시 해당 상품 품목들을 리스트로 넘기면, 매퍼에서 리스트를 풀어서 조회하는 방식으로 수정을 결정.  
26. 쇼핑몰 스프링 프로젝트 백엔드 작업  
    1. 리뷰 조회 API 로직 수정  
       1. 프론트엔드에서 상품 품목을 넘겨야하니까 DTO에 상품 품목 리스트 항목을 추가하고, 매퍼에서는 해당 리스트를 풀어서 하나씩 조회하는 조건 추가.  
       2. 수정 후 API 요청에 500에러가 출력되는 문제가 생기긴 했지만, 원인을 추적하여 하나씩 해결하여 결과적으로 200응답 출력 확인.  
27. 쇼핑몰 리액트 프론트엔드 작업  
    1. 관리자 리뷰 관리 페이지 작업  
       1. 리뷰 조회 API 로직을 전반적으로 건드렸다보니, 해당 API를 사용하는 다른 페이지인 관리자 리뷰 관리 페이지에 문제가 생겼는지 체크. 메인 테이블 칼럼인 상품 마스터 ID와 회원 이메일 쪽 출력에 문제가 생겨서, 원인을 추적해서 차차 해결. 문제들을 해결 후 가만히 생각해보니, 해당 페이지를 작업할때만해도 상품 마스터 ID 밖에없었지만 그 후 상품 마스터 코드를 추가했다는게 떠오름. 상품 마스터의 구별을 위해 상품 마스터 코드를 추가한 것이므로, 메인 테이블의 상품 마스터 ID 칼럼을 상품 마스터 코드로 변경하고 관련 로직도 코드에 맞춰 전부 변경. 정상 작동 확인.  
    2. 상품 마스터 페이지 작업  
       1. 리뷰 조회 API 로직을 새로 정비했으니, 다시 상품 마스터 페이지의 ‘상품 리뷰’ 항목 작업으로 복귀.  
       2. 리뷰 조회 API로 불러온 정보들 중 회원이름, 주문 품목 옵션(사이즈/컬러), 평점, 리뷰내용을 \<Card\>에 출력시킬 항목으로 최종 결정. \<Card.Meta\>를 사용하여 항목들을 데스크톱 환경과 모바일 환경 모두 자연스러운 디자인으로 출력될 때까지 수정을 반복.   
       3. 전체 리뷰 요약 카드의 내용이 데스크톱 환경에서는 정상적으로 한 줄로 출력되지만, 모바일 환경에서는 내용 크기가 그대로인데 폭이 줄어들다보니 두 줄로 비정상 출력되는 문제 확인. 모바일 환경에서는 자동으로 내용 크기와 간격이 조절되어 한 줄 출력이 망가지지 않게 수정. 정상 출력 확인.  
       4. 페이지 로딩시 스피너가 출력될때, 푸터 영역이 세팅한 것보다 비정상적으로 많은 높이를 차지하는 문제가 있음. 로딩 컨테이너 스타일 설정을 조정하여 정상출력되도록 수정.  
28. 쇼핑몰 스프링 프로젝트 백엔드 작업  
    1. 리뷰 관련 API 로직 수정  
       1. 상품 마스터 페이지에 리뷰들이 정상 출력되는지 더미 데이터로 확인했으나, 아직 주문 회원이 리뷰를 등록하는 루트를 프론트엔드에 세팅을 아직 안했다는 사실을 깨달음. 프론트엔드에 리뷰 등록 루트를 세팅하기 전에, 리뷰 등록 API에 문제가 없는지 검토 진행. 리뷰 등록 API의 서비스 단계에 검증 로직이 부족하다고 판단.   
       2. 주문 한번 하고 리뷰를 여러번 쓰는것을 막기 위한 ‘해당 주문 품목으로 이미 작성된 리뷰 존재 여부 검증’ 로직을 추가해야하는데, reviews 테이블에 주문 품목 정보를 담는 칼럼이 없는 상황. reviews 테이블에 order\_product\_id 칼럼을 추가하고 이에 맞춰 VO, Mapper, DTO에 칼럼 정보 추가. 그 후에  ‘해당 주문 품목으로 이미 작성된 리뷰 존재 여부 검증’ 쿼리를 리뷰 Mapper에 세팅하고, 리뷰 등록 API의 서비스 단계에 연동.  
       3. ‘해당 주문 품목에 유저ID와 구매확정 상태의 검증’ 로직 추가를 위해, 해당 쿼리를 주문 Mapper에 세팅하고 리뷰 등록 API 서비스 단계에 연동.  
       4. 리뷰 등록/수정/삭제를 마이페이지 주문 관리 페이지에서 ‘구매확정’ 상태인 주문 품목에 한해서만 접근할 수 있도록 구상 중인데, 그러려면 마이페이지 주문 관리 페이지에서 해당 회원의 리뷰 정보를 API로 불러와야 해서 ‘리뷰 조회(회원ID 기준) API’를 추가로 세팅.  
29. 쇼핑몰 리액트 프론트엔드 작업  
    1. 마이페이지 주문관리 페이지 작업  
       1. 새로만든 ‘리뷰 조회(회원ID 기준) API’를 연동하여 해당 회원의 리뷰 정보를 가져오고, 주문 품목의 상태에 따라 ‘작업’ 칼럼에 리뷰 관련 버튼이 출력되도록 세팅. 주문 품목이 ‘구매확정’ 상태가 아니면 아무 버튼도 안나오고, ‘구매확정’ 상태이면서 리뷰가 없으면 ‘리뷰작성’ 버튼을 출력시키고, ‘구매확정’ 상태이면서 삭제되지 않은 리뷰가 있으면 ‘리뷰수정’ 버튼을 출력시키고, ‘구매확정’ 상태이면서 삭제된 리뷰가 있으면 ‘리뷰 삭제됨’ 버튼(불활성)을 출력시키는 로직.  
       2. 새로 만든 버튼을 눌렀을때 작동시킬 리뷰 작성/수정 모달을 추가. 스타일 세팅하고 리뷰 작성 API, 리뷰 수정 API, 리뷰 삭제 API 로직 연동시킴. 리뷰 수정 테스트를 해봤는데 오류가 남. 추적해보니 주문 정보를 API로 받아온 뒤 flatMap으로 평탄화시키는 함수에서 부정확하게 세팅된 부분이 있어서 수정하고, DB의 더미데이터가 잘못 세팅된 부분이 있어서 수정. 의심되는 부분들을 수정하고나서 리뷰 수정 기능이 정상작동하지만, 코드를 검토하다보니 Optimistic Lock 로직에 필요한 version 항목이 프론트엔드에서 세팅되지 않았는데 정상작동하는건 문제가 있다는걸 발견.  
30. 쇼핑몰 스프링 프로젝트 백엔드 작업  
    1. 리뷰 관련 API 로직 수정  
       1. 프론트엔드에서 version 항목을 안넣어도 왜 Optimistic Lock을 통과하는지 추적해보니, 서비스 단계에서 자동으로 최신 version 정보를 넣는 잘못된 로직이 포함된게 원인이었음. version 정보는 프론트엔드에서 받아오도록 수정은 했는데, 문제는 다른 API들에 세팅한 Optimistic Lock 로직도 비슷하게 만들었었어서 전수 검토하여 수정해야 하는 상황.  
    2. Optimistic Lock를 포함한 API 로직들 수정  
       1. API 서비스 단계를 전부 검토하여 Optimistic Lock인데 version을 프론트엔드에서 받아 넣지 않으면 수정.  
       2. 검토하는 중 UserService의 비밀번호 재설정 토큰 업데이트 로직에도 낙관적 잠금을 세팅했던걸 분석하다보니, 이 로직은 프론트엔드에서 먼저 version 정보를 받을 수가 없는 구조라는걸 깨달음. 따라서 비밀번호 재설정 토큰 업데이트 로직의 낙관적 잠금 세팅을 해제함.  
31. 쇼핑몰 리액트 프론트엔드 작업  
    1. 비밀번호 재설정 페이지 작업  
       1. 낙관적 잠금 세팅을 해제하면서 검토하다보니, API 로직에서 백엔드가 넘겨주는 메시지를 제대로 받고 있지 않은 세팅이라 깔끔하게 수정.  
    2. 인증 로직 작업  
       1. 관리자 계정으로 로그인 한 후, 홈페이지에 접속하면 로그인이 풀리지 않고 일반 회원 로그인과 동일하게 유지되는 문제 확인. 관리자 로그인 시 일반 페이지에 접근할 때 자동으로 로그아웃되도록 AuthProvider 컴포넌트와 AuthContext의 로직 수정. 정상 작동 확인.  
       2. 일반 회원과 관리자 모두, 로그인 후에도 로그인 페이지나 회원가입 페이지에 접근할 수 있는 문제 발견. PrivateRoute 컴포넌트를 새로 만들어서 일반 회원이나 관리자의 부적절한 접속을 제한하는 로직을 세팅 후, App.js에 적용.  
       3. 마이페이지 주문관리 페이지 작업하면서 보면, 분명 로그인 상태에서 새로고침을 했는데 로그아웃되어 로그인 페이지로 리다이렉트 된 직후 홈페이지로 연속 리다이렉트 되는 문제가 있음. 추적해보니 AuthContext의 checkAuthStatus 함수에서 토큰 검증과 상태 설정을 하는 동안 loading 상태가 true가 되는데, 이 시점에 PrivateRoute와 PublicRoute가 loading 상태를 고려하지 않고 바로 리다이렉트 판단을 하는 것이 원인이었음. 따라서 PrivateRoute와 PublicRoute 컴포넌트에서 loading 상태를 체크하도록 수정. 정상 작동 확인.  
    3. 마이페이지 주문 관리 페이지 작업  
       1. ‘리뷰작성/리뷰수정/리뷰 삭제됨’ 버튼과 모달을 테스트. 버튼별 출력 조건이 꼬여서 조건에 안맞는 버튼과 모달이 출력되거나, 수정이나 삭제 후에도 최신화가 적용 안되는 문제 발생. 제대로 출력되는 로직을 찾을때까지 수정을 계속하여 최종적으로 문제 해결. 수정 내용을 입력하고 모달이 자동으로 닫히기 직전 짧은 시간동안 입력 항목들이 초기화되는 모습이 보이는 문제가 있어서, 모달이 먼저 닫히고 항목 초기화는 나중으로 미는 수정으로 해결. 마이페이지 주문 관리페이지가 열리거나 새로고침될때, 메인영역의 표에 바로 로딩 스피너가 돌지 않고 데이터가 없을때의 기본 폼인 'no data' 출력이 잠깐 나온 후에야 로딩 스피너가 도는 문제가 있어서, Table 컴포넌트의 locale 속성을 수정하는 것으로 해결.  
       2. 모바일 환경에서 어떻게 출력되는지 확인. 모바일 환경에서 출력되는 카드에 리뷰 관련 버튼 추가 작업을 안한게 보여서, 데스크톱 환경 메인 표의 ‘작업’ 칼럼에 추가한 로직을 모바일 카드에도 추가. 부자연스러운 디자인 요소들은 스타일 설정을 건드려서 정리.   
    4. 레이아웃 컴포넌트 작업  
       1. 마이페이지 주문 관리 페이지에서 데스크톱 환경이나 모바일 환경 모두 첫 진입시 로딩될때 레이아웃의 푸터가 비정상적으로 공간을 많이 차지하는 문제가 있어서, 추적해보니 레이아웃 스타일 설정 문제였음. MainContent 컴포넌트의 min-height 세팅을 제거하여, 컨텐츠의 양에 따라 자연스럽게 레이아웃이 조정되고 푸터가 항상 컨텐츠 바로 아래에 위치하도록 수정. 정상 출력 확인.  
    5. ResponsiveContext.js 세팅  
       1. 데스크탑 환경과 모바일 환경을 오가며 이런저런 테스트를 하면서, 어떤 페이지는 실시간으로 랜더링 출력 전환이 되고 어떤 페이지는 실시간으로 안되는 등 통일성이 없다는걸 깨달음. 최종적으로 대부분의 페이지에 적용되어야하는 로직이긴해서, Context API 방식을 통해 일관된 반응형 기준을 전역에서 관리하기로 결정.   
       2. ResponsiveContext.js을 만들어 768px 폭을 기준으로 반응형 로직을 세팅하고, App.js에 추가.  
    6. 인증에 따른 페이지 접근 설정 작업  
       1. 앞서 PrivateRoute와 PublicRoute을 추가하는 작업을 한 후, 관리자 로그인 페이지를 통해 로그인 시 대시보드로 이동하자마자 '관리자 계정은 일반 페이지에 접근할 수 없습니다.' 메시지가 뜨면서 관리자 로그인 페이지로 강제 이동하는 문제 발견. 추적해보니 PublicRoute.js 로직과 App.js 라우팅 세팅에 문제가 있고, AuthContext.js의 URL 기준으로 접근을 통제하는 기존 로직도 충돌을 일으키는 원인 중 하나였음. 수정해야하는김에 PrivateRoute와 PublicRoute만으로 3가지 경우의 수를 커버하는게 마음에 안들어서, 3가지 경우의 수만큼 다시 세팅(UserOnlyRoute, AdminOnlyRoute, GuestOnlyRoute). AuthContext.js에서는 충돌하는 로직을 삭제하고, AdminLayout.js의 권한 검증은 중복되니 삭제하고, 변경된 Route에 맞춰 App.js 라우팅 세팅 수정. 문제가 생기는 부분은 재차 수정 작업. 정상 작동 확인.  
    7. 레이아웃 작업  
       1. 관리자 로그인 시 일반 페이지에 접속하면, 레이아웃 우상단의 메뉴 아이템이 다르게 출력되도록 세팅해야함. 관리자 로그인 시 ‘대시보드’ 버튼과 ‘로그아웃’ 버튼이 출력되도록 로직 추가. 정상 출력 확인.  
       2. 전역 스타일 설정을 레이아웃에서 제대로 끌어쓰지 못하고 있다는걸 인지. 전역 스타일 설정 중 끌어올 수 있는건 끌어오고, 중복되는 부분 정리.  
    8. 검색 결과 출력 페이지 작업  
       1. 레이아웃 작업 중 검색 기능 연동이 안되어있는걸 확인. 예전에 연동할 백엔드 쪽 세팅을 다 해놨었는데, 출력할 페이지 세팅 때문에 나중으로 미뤘었음. 어차피 레이아웃 헤더의 카테고리 항목을 클릭했을때 해당 카테고리의 상품 리스트를 출력하는 CategoryPage.js를 만들어놨었는데, 이 페이지가 검색 기능을 통해 상품 리스트를 출력하는 목적에 부합하여 조금만 수정하면 되는 상황이라 작업 시작.  
       2. CategoryPage.js를 ProductListPage.js로 파일명을 변경. 카테고리 항목으로 상품을 조회하는 API는 검색어로도 조회할 수 있게 예전에 세팅해뒀기 때문에, 상품 목록 조회 로직에 검색어 키워드를 백엔드로 넘길 수 있는 로직 추가. 각 상황에 따라 페이지 타이틀 출력이 다르게 되도록 조건 로직 추가. 정상 작동 확인.  
       3. 검색어로 상품 조회를 했을 경우, 레이아웃 헤더의 카테고리 항목이 초기화 되어야 사용자 경험상 자연스러움. 따라서 Layout.js의 검색 이벤트 로직에 카테고리 관련 정보를 초기화하는 로직 추가. 정상 작동 확인.  
    9. ResponsiveContext.js 세팅  
       1. 해당 반응형 로직을 필요한 페이지에 일괄적으로 적용하고, 중복되는 기존 로직이 있는 페이지는 기존 로직을 삭제하는 작업 시작. AdminDashboard, CartPage, MyPageOrderManagement, OrderPage, AdminLayout, Layout 작업 완료.  
    10. 주문/결제 페이지 작업  
        1. 모바일 환경에서 컨텐츠들의 폭이 안맞춰져서 뷰포트를 뚫고 나가는 문제가 있음. 최상위 컨테이너의 폭이 뷰포트에 맞춰지도록 수정하는걸로 뚫고 나가는 문제는 해결되었으나, 주문 상품 표가 애매하게 좌우 스크롤이 생기는 상황. 컨테이너들의 좌우 여백을 더 좁히는걸로 어느정도 해결.  
        2. 데스크탑 환경에서는 ‘결제하기’ 버튼으로 포트원 팝업이 정상적으로 뜨는데, 모바일 환경에서는 작동을 안하고 “PaymentError: 결제 창 호출에 실패하였습니다. 리디렉션 방식으로 결제창을 호출하려면 리디렉션 URL은 필수 입력입니다.” 오류 로그가 출력되는 상황. 확인해보니 모바일 환경에서는 리디렉션 방식으로 결제가 처리되어 리디렉션 세팅을 해줘야한다고 함. PaymentContext에서 모바일 환경일 경우 paymentData.m\_redirect\_url이 마이페이지 주문관리 페이지로 설정되도록 코드 추가. 모바일 환경에서는 결제 팝업창이 아니라 결제 페이지로 정상적으로 넘어가는걸 확인.  
        3. 이제 모바일 환경에서 결제 페이지로 넘어가는 지는데, 결제 성공만 고려하여 세팅한 리디렉션 때문에 결제를 취소해도 마이페이지 주문관리 페이지로 이동하는 문제가 있음. 결제 취소 시에는 주문/결제 페이지로 돌아가는 것이 사용자 경험에 더 좋다고 생각함. 포트원 규격에 맞춰서 일단 아무것도 랜더링되지 않는 결제 완료 페이지를 임시로 만들어서 리디렉션으로 설정하고, 포트원에서 보내는 결제 성공/실패 파라미터를 받아 성공 시 주문 관리 페이지로 이동시키고 실패/취소 시 주문 페이지로 돌아가는 로직 세팅. 아무 랜더링 없는 페이지가 중간에 걸리긴 하지만, 일단 정상 작동 확인.  
        4. 모바일 환경에서 '주문하기' 버튼을 누르면 포트원 결제 페이지로 넘어가기 직전에 message.error('결제 처리 중 오류가 발생했습니다. 잠시 후 다시 시도해주세요.');가 출력되는 문제가 있음. 아마 포트원과 연동하는 const handleOrder가 결제 팝업창을 띄우는 로직에 한정되어있어서 결제 페이지로 넘어가버리는 모바일 환경에서는 catch (error) 영역으로 넘어가기 떄문에 생기는 문제로 추정됨. catch (error) 영역에 모바일 환경이면 에러 메시지를 출력시키지 않는 로직 추가. 정상 작동 확인.  
        5. 모바일 환경에서 결제를 취소하면 주문/결제 페이지로 리다이렉션되는 도중에 '\[PAY\_PROCESS\_CANCELED\] 사용자가 결제를 취소하였습니다' 메시지가 출력되는데, 이건 개발자에게 노출되는걸 전제로 포트원에서 전달하는 메시지라고 생각해서 사용자 경험에 좋지 않다고 생각함. OrderCompletePage의 메시지 출력 세팅을 수정하여 사용자 친화적인 텍스트를 하드코딩. 정상 작동 확인.  
        6. 규격대로 함수 그룹화 및 순서 정리.  
    11. API 로직 최적화  
        1. 이전에 API 로직을 더 엄밀하게 규격화 했었는데, 최근에 백엔드 컨트롤러 코드와 비교하면서 다시 보다보니 굳이 필요없는 코드까지 포함되어있는걸 알게됨. try 영역에서 API 요청으로 백엔드에서 응답을 받으면 ‘if (response.status \=== 200\) { } else { }’로 처리하게 되면 200응답일때는 if 영역에서 다루고 400에러나 500에러면 else 영역으로 넘어갈거라 생각했었는데, 다시 확실하게 알아보니 try 영역에서 400에러나 500에러가 나오면 바로 catch 영역으로 넘어가는거였음. 따라서 try 영역의 ‘if (response.status \=== 200\) { } else { }’는 기능적으로 크게 의미가 없어서 if-else를 벗겨내는게 코드 낭비가 없는 상황. 따라서 프론트엔드 파일을 전수 검토하여 해당 if-else를 벗겨내고, 하는김에 백엔드에서 예외상황에 메시지가 전달되지 않을경우 출력할 하드코딩 텍스트도 최적화 진행. Layout, AdminLogin, AdminOrders, AdminPayments, AdminProducts, AdminReviews, AdminUsers, CartPage, HomePage, LoginPage, MyPageOrderManagement, MyPageUserInfoManagement, OrderPage, ProductDetail, RegisterPage, ResetPasswordPage, AuthContext, PaymentContext 검토하여 최적화 완료.  
        2. API를 호출할때 다른 페이지에서는 AuthContext의 authRequest를 가져와서 쓰는데, 극초반에 작업한 관리자 대시보드 페이지는 authRequest가 아니라 자체적으로 const handleApiResponse을 선언해서 쓰고있는 이상한 상황. 다른 페이지와 동일한 API 로직을 쓰도록 수정.  
32. 쇼핑몰 스프링 프로젝트 백엔드 작업  
    1. API 컨트롤러 작업  
       1. 백엔드 API 컨트롤러 단계들의 코드가 예외처리 등의 코드가 어설프게 세팅 되어있어서(특히 초기 작업 본) 정리 필요. UserController, ProductController, OrderController, ReviewController, PaymentController를 싹 검토하여 코드 정리 완료.  
33. 쇼핑몰 리액트 프론트엔드 작업  
    1. 관리자 주문 관리 페이지 작업  
       1. 해당 페이지에서 주문 품목 상태에 따른 관리자가 수행할 기능의 버튼들이 출력되는건 세팅되어있는데, 각 버튼마다 필요한 API 연동이 안되어있는 상황. 백엔드에 이미 API 세팅은 되어 있으므로 프론트엔드와 연동시키기만 하면 됨.   
       2. 각 상황별 버튼들이 백엔드에 세팅된 API와 연동될 수 있게, API 로직 수정. 연동해야할 API가 여러개라 특히 API url과 백엔드에 DTO로 넘겨야할 정보 패킹에 유의하여 작업.   
    2. 마이페이지 주문관리 페이지 작업  
       1. 해당 페이지에서 주문 품목 상태에 따른 회원이 수행할 기능의 버튼들에 API가 연동은 되어있는데, 이상하거나 보강해야할 부분이 있는지 검토. 백엔드에 DTO로 넘겨야할 정보 패킹에 문제가 있어서 수정.  
    3. 홈페이지 작업  
       1. 상단에 이벤트 배너를 출력하는 세팅을 맞췄었는데, 이벤트 구상하고 배너 이미지 제작할거 생각하면 약간 포트폴리오 본질에서 벗어나는 느낌이 드는 중. 그래서 이벤트 배너 코드를 밀어버리고, 포트폴리오 쇼핑몰임을 명시하는 배너 코드를 세팅. 배너 배경색은 테마에 어울리게 모노톤으로 하되, 너무 단조롭지 않으면서 시선을 끌기위해 그라데이션을 줌. 포트폴리오 목적의 쇼핑몰 데모라는 내용과. 실제 결제 및 배송 불가하다는 내용과, 연락처 이메일을 명시. 모바일 환경에서 디자인이 애매해져서 스타일 속성 조정.  
    4. 상품 마스터 카드 컴포넌트 작업  
       1. 기성 쇼핑몰 이미지를 끌어다 쓸 생각이므로, 시각적으로 명시되는 요소를 추가할 필요가 있다고 생각. 상품 이미지 위에 CSS로 “DEMO” 워터마크를 출력하도록 세팅하되, 상품 이미지가 없는 경우에는 워터마크가 출력되지 않도록 함.  
    5. robots.txt 수정  
       1. 포트폴리오용 데모 사이트라고 명시하는 내용을 추가.  
34. 깃허브에 포트폴리오 업로드 작업  
    1. 예전에 백엔드 프로젝트는 깃허브 업로드 테스트를 통해 레포지토리에 올라갔었는데, 현재는 프론트엔드 프로젝트가 추가된 상황. 기존 백엔드 프로젝트 레포지토리에 상위 폴더를 만들고 프론트엔드 프로젝트를 백엔드 프로젝트와 함께 차상위 폴더에 정리할 수 있는지 알아봤는데 그렇게는 안되는걸로 나옴. 따라서 ‘기존 백엔드 레포지토리는 건들지 않고 프론트엔드 레포지토리를 별도로 생성’하는 방안과 ‘기존 백엔드 레포지토리를 밀어버리고 프론트엔드와 백엔드가 모두 들어간 새로운 레포지토리를 생성’하는 방안 중 하나를 골라야 함. 작업 중인 프론트엔드와 백엔드는 하나의 포트폴리오의 프로젝트들이므로 후자가 더 낫겠다고 판단함.  
    2. 방향을 정하고 방법을 조사하다보니, 레포지토리에 로컬 폴더를 연동하는 방식이 생각보다 매우 경직되어있다는걸 알게 됨. 기본적으로 로컬 폴더 하나와 레포지토리 하나가 1:1 대응하는 방식이라, 다른 루트의 로컬 폴더 두 개를 하나의 레포지토리와 연동시키는건 불가능한 구조임. 현재 백엔드 프로젝트 폴더와 프론트엔드 프로젝트 폴더는 동일한 상위 폴더에 묶여있긴한데, 문제는 그 상위 폴더엔 다른 폴더들도 존재하기 때문에 상위 폴더를 그대로 레포지토리에 올리면 포트폴리오와 관계없는 폴더들도 올라가는 상황. 그래도 같이 있는 다른 폴더들은 연습용 프로젝트들이라서 앞으로 깃허브에 올라갈 일은 없고, .gitignore 설정을 통해 포트폴리오 폴더들만 필터링해서 업로드가 가능하다는걸 알게되어 그렇게 진행할 예정.  
    3. 일단 예전에 만든 백엔드 프로젝트만 올라간 레포지토리를 삭제. 포트폴리오 통합 레포지토리를 새로 만들고, 상위 폴더를 원격 저장소로 연결.  
    4. 상위 폴더에 .gitignore를 만들어 어떻게 필터링할지 구상. 일단 상위 폴더에서 업로드할 폴더&파일만 지정(백엔드 프로젝트 폴더, 프론트 프로젝트 폴더, .gitignore 파일, README.md 파일). 그리고 백엔드 프로젝트 폴더와 프론트 프로젝트 폴더 내에서 업로드하지 않을 폴더나 파일을 지정(빌드 설정, IDE 설정, 환경변수 등). 이 과정에서 백엔드 프로젝트의 data.sql 파일(관리자 계정 등록 기능을 안만들거라서 프로젝트가 실행될때 DB에 관리자 계정 정보를 강제 업로드하는 코드였으나, 지금 다시 생각해보니 이미 서버의 DB는 HeidiSQL 등으로 별도 조작이 가능하므로 필요없는 코드로 판단.)을 삭제하고, application.properties에 관련 코드도 삭제.  
    5. application.properties 코드를 검토하다보니, MariaDB 계정 정보가 하드코딩 되어있어서 깃허브에 업로드되지 않는 파일이라 하더라도 보안처리는 해야한다고 생각함. MariaDB 계정 정보를 환경변수로 전환.  
35. AWS 서버 MariaDB 작업  
    1. MariaDB 계정이 과외 수업으로 진행할때 만들었다보니, 비밀번호가 너무 엉성하게 세팅되어있는 상황. 비밀번호를 수정하는 방법을 조사하다보니, 일반적으로 DB 계정은 개발 환경 접속용과 운영 환경 접속용 등 목적에 따라 나눠서 사용하는게 권장된다는걸 알게 됨. 따라서 엉성하게 만든 비밀번호도 수정하고, 운영 환경 접속용 계정을 추가로 만들기로 결정.  
    2. AWS 서버 SSH를 통해 MariaDB 접속. 개발환경 접속용 계정의 비밀번호 수정. 운영환경 접속용 계정 새로 생성하고 권한 부여.  
36. DB 교통정리  
    1. 지금까지 백엔드 프로젝트와 프론트엔드 프로젝트는 로컬에서 개발하고, AWS 서버에 올린 DB를 백엔드와 연동하여 테스트 중이었음. 나중에 어차피 AWS 서버에 포트폴리오 프로젝트들 올려서 라이브 데모 돌릴 예정이었어서 자연스럽게 AWS 서버 DB를 연동하고 있던건데, 깃허브 레포지토리와 AWS 서버에 백엔드와 프론트엔드 프로젝트를 올리기 전에 머리속으로 시뮬레이션을 돌려봤을때 문제가 있음을 인지함. 왜냐하면 AWS 서버에 라이브 데모가 돌아가기 시작한 후에도 미완성 버전이라 구현할 부분이 남았으므로, 로컬 개발과 로컬 테스트를 해보고 AWS 서버에 업데이트를 이어나가야하는데… 로컬 개발 환경과 운영 환경 모두 하나의 DB를 쓰면 로컬 테스트하면서 생기는 DB의 변화가 운영 환경과 충돌할경우 라이브 데모에 오류를 발생시킬 것이기 때문. 이런 예상되는 문제를 방지하기 위해서 알아보고 고민해본 결과, 로컬에 개발 테스트용 DB(dev)와 스테이징용 DB(staging)와 운영 DB 백업용 DB(copy)를 추가하기로 결정. 이렇게하면 로컬 테스트가 필요한 시점에 ‘운영 DB를 스테이징용 DB에 복사 \> 개발 테스트용 DB의 스키마를 스테이징용 DB에 적용 \> 스테이징용 DB를 개발 테스트용 DB에 복사’하여 운영 DB의 내용으로 테스트가 가능하며, 업데이트가 필요한 시점에는 ‘운영 DB를 백업용 DB에 복사 \> 개발 테스트용 DB의 스키마를 운영 DB에 적용(백엔드와 프론트엔드도 업데이트) \> 문제가 생기면 백업용 DB로 롤백’하면 됨.  
    2. 로컬 MariaDB에 'portfolio\_shopping\_mall\_dev', 'portfolio\_shopping\_mall\_staging', 'portfolio\_shopping\_mall\_prod\_copy' DB를 추가. AWS 서버의 DB(스키마+데이터)를 .SQL로 내보내기하고 새로만든 DB들에 복사함.  
    3. 로컬 MariaDB 계정을 예전에 강의들을때 만들었다보니 아주 낮은 보안수준의 비밀번호로 세팅했다는게 기억남. 생각난김에 로컬 MariaDB 계정 비밀번호를 높은 보안수준의 비밀번호로 변경.  
37. 쇼핑몰 스프링 프로젝트 백엔드 작업  
    1. application.properties 작업  
       1. application-dev.properties (개발용), application-staging.properties (스테이징용), application-prod.properties (운영용) 파일을 새로 생성하고, application.properties에 세팅되어있던 DB 연동 코드를 환경별로 분리.  
       2. Run 패널에서 각 환경을 선택하여 실행할 수 있도록 launch.json 파일을 수정. 정상 작동 확인.  
    2. 전화번호 암호화 로직 작업  
       1. 얼마전에 보안관련 이슈를 체크하다가 알게된건데, 전화번호는 개인식별정보(PII)로 분류되는 데이터로서 보안처리가 반드시 필요한 정보임. 현재 내 포트폴리오 DB에는 이런 내용을 모를때 세팅한거라 전화번호가 평문으로 저장되어있음. 따라서 전화번호를 암호화하는 로직 도입을 결정.  
       2. 알아보니 전화번호 암호화는 AES로 대표되는 양방향 암호화를 하는게 일반적이라고 하여, AES-256 방식으로 결정. 전화번호 암호화 유틸리티 클래스를 생성하여 암호화 로직과 복호화 로직을 세팅하고, application.properties에 암호화 키 설정.   
       3. 다음으로 암호화 키를 환경변수로 세팅해야하는데, 정확히 32바이트를 맞춰야한다고 해서 곤란해짐. 좀 더 편의성이 있는 방안을 찾다가, 키 유도 함수인 PBKDF2를 통해 키를 관리하면 개발자가 32바이트라는 제약에서 벗어나서 자유롭게 세팅할 수 있다는걸 알아냄. PBKDF2 \+ AES 방식으로 수정하여 다시 세팅.  
       4. UserService의 로직 중에 전화번호를 DB에 저장하고 꺼내는 부분에 전화번호 암호화 유틸리티 적용. 수정 로직이 제대로 작동하는지 테스트해보니 오류가 발생. 백엔드 로그를 확인해보니 DB에 저장할 수 있는 길이보다 긴 값을 저장하려해서 생기는 오류라는걸 확인. DB를 확인해보니 전화번호 칼럼 자료형이 VARCHAR인게 원인이라, TEXT로 변경. 정상 작동 확인.  
       5. 전화번호를 DB에 저장하고 꺼내는 로직이 있는 OrderService, PaymentService도 코드 수정.  
    3. JWT 관련 환경변수 세팅  
       1. 환경변수 설정을 이것저것 하다보니 JWT 상수를 환경변수로 세팅해야한다고 체크해놨던 것을 확인. 하드코딩되어있던 JWT 시크릿키와 만료시간을 환경변수로 옮기고, 보안성이 낮은 시크릿키를 보안성이 더 높도록 수정. 세팅을 변경하면서 JWT 상수를 불러다쓰는 JwtSupport에 오류가 생겨, 오류가 생기지 않도록 정리.  
38. 쇼핑몰 리액트 프론트엔드 작업  
    1. 로그아웃 로직 수정  
       1. JWT 상수를 환경변수로 돌린 후, 로그아웃을 해도 레이아웃 우상단 메뉴에 로그인 시 메뉴가 유지되는 문제 발견. 새로고침을 해도 로그인 시 메뉴가 유지되는걸보면 로그아웃을 해도 인증정보가 초기화되지 않는 걸로 추정됨. 검토해보니 AuthContext의 const logout 로직에서 로그아웃 API 호출 직후 early return되어 아래줄에 있는 ‘토큰&상태 초기화’ 로직이 작동하지 않아서 생기는 문제로 추정. 로그아웃 API 호출 직후 return 로직을 삭제하여 API 결과와 상관없이 아래줄로 로직이 넘어가도록 수정.  
       2. AuthContext의 const logout 로직을 수정하고 해결이 된건지 검토하면서 자세히 보니, 로그아웃 API는 호출 성공/실패 유무에 관계없이 토큰&인증 정보가 초기화되어야하는 기능인데도 관성적으로 try-catch 구조로 만들어놓은건 문제가 있다는걸 인지함. 따라서 try-catch 구조를 벗겨내고 API 호출결과에 상관없이 토큰&인증 정보를 초기화하도록 수정. 그리고 const logout를 await logout()으로 불러내는 레이아웃 컴포넌트와 관리자 레이아웃 컴포넌트의 로그아웃 로직에 try-catch 구조를 벗겨내고 API 호출결과에 상관없이 로그아웃 성공 메시지를 내도록 수정.  
       3. AuthContext의 const logout이 받을 수 있는 파라미터로 skipApiCall과 isWithdraw가 세팅되어있는데, await logout()으로 불러다쓰는 장소에서 어떤 파라미터를 세팅하는건지 시각적으로 명료하게 구분할 수 있도록 수정(await logout(true, true); → await logout({ skipApiCall: true, isWithdraw: true, reason: 'withdraw' });).  
    2. 마이페이지 그룹 작업  
       1. 해당 페이지들에서 로그아웃했을때 'email'을 읽을 수 없다거나 객체가 없다는 런타임 오류가 나오는 문제 발견. 아무래도 로그아웃 후 즉시 컴포넌트가 리렌더링되면서 발생하는 타이밍 이슈로 추정됨. email 정보는 user에 담겨있고 로그아웃하여 초기화된 user의 정보를 읽으려고 하면서 생기는 문제이니, useCallback 세팅된 함수들에 user가 null이면 early return시키는 로직 추가. 정상 작동 확인.  
    3. 관리자 페이지 그룹 작업  
       1. 마이페이지 그룹과 비슷한 문제가 발생할 가능성이 높은 관리자 페이지 그룹은 어떤지 확인. 예상대로 로그아웃했을때 객체가 없다는 런타임 오류가 나오는 문제가 그대로 발생중. 이전 작업과 동일하게 useCallback 세팅된 함수들에 user가 null이면 early return시키는 로직 추가. 정상 작동 확인.  
39. 깃허브에 포트폴리오 업로드 작업  
    1. 급하게 해결해야할 부분들이 정리된걸로 보여, 다시 깃허브 업로드 작업으로 돌아옴.   
    2. 테스트하면서 저장된 상품 이미지는 깃허브나 서버에 올라갈 필요가 없으니 .gitignore에 상품 이미지는 예외시키는 내용 추가.   
    3. 깃허브 업로드 전에 업로드 세팅 다시 확인하여 업로드 예외 폴더나 파일이 잘 적용되었는지 체크.  
    4. 커밋 후 푸쉬. 레포지토리에 정상 업로드 확인.  
40.   
41. 쇼핑몰 리액트 프론트엔드 작업  
    1. 관리자 대시보드 페이지 작업  
       1. 대시보드 통계 중 ‘주문 수’와 ‘매출’ 항목에 실제 서비스와 가깝게 하고 싶어서 이번달 기준으로 출력하도록 세팅했었는데, 실제 주문자가 없는 포트폴리오 서비스다보니 나중에는 항목에 0만 출력되는 문제가 예상됨. 따라서 이번달 기준으로 출력하는 세팅을 전체 기준으로 출력하도록 수정.  
       2. 비교적 프로젝트 초반에 세팅한 페이지라 수정 및 정리가 많이 필요하다고 판단하여 전면적으로 수정 작업 시작.  
       3. 랜더링 리턴 영역의 스타일 설정을 분리하고, 전역 스타일과 겹치는 코드 삭제. 모바일 환경에서 디자인이 애매한 부분들 수정(최상위 컨테이너의 패딩 영역 확보, 헤더 우측 버튼 크기 축소, 통계 항목 카드 간격 최적화, 뷰포트 아래로 넘치면 스크롤 활성화, 푸터 높이 정상화). 데스크탑 환경에서도 디자인이 이상한 부분들 수정(\<ContentContainer\> 하단의 의미불상의 빈공간 삭제, 통계 카드 행 영역의 폭이 상위 영역보다 넓은 현상 해결  
       4. fetchDashboardData 함수 내부에 함수들이 들어가있는 중첩 구조라서 문제가 있음. 내부의 함수들을 밖으로 적절히 분리하여 리팩토링(fetchTotalUsers, fetchOrders, fetchPayments, fetchTotalReviews, formatOrderData, calculateTotalRevenue).   
       5. fetchOrders의 경우 전체 주문 리스트를 API로 조회한 후 프론트엔드에서 카운팅하는 로직과 최근 주문 리스트를 API로 조회하는 로직이 같이 있어서, 각각의 API를 별도의 함수로 추가 분리(fetchTotalOrders, fetchRecentOrders).  
42. 쇼핑몰 스프링 프로젝트 백엔드 작업  
    1. 총 주문 수 조회 전용 API 작업  
       1. 앞서 언급된 fetchTotalOrders로 전체 주문 리스트를 API로 조회한 후 프론트엔드에서 총 주문 수를 카운팅하는 방식인데, 더 리소스를 줄이는 방안이 있다고 판단. 따라서 SQL 쿼리에서 총 주문수를 카운팅 해서 토스하는 ‘총 주문수 조회 전용 API’를 별도로 제작.  
    2. 총 매출액 조회 전용 API 작업  
       1. 앞서 언급된 fetchPayments로 전체 결제 리스트를 API로 조회한 후 프론트엔드에서 결제완료 상태만 필터링하고 총 매출액을 계산하는 방식인데, 더 리소스를 줄이는 방안이 있다고 판단. 따라서 SQL 쿼리에서 총 매출액을 계산해서 토스하는 ‘총 매출액 조회 전용 API’를 별도로 제작.  
43. 쇼핑몰 리액트 프론트엔드 작업  
    1. 관리자 대시보드 페이지 작업  
       1. fetchTotalOrders 로직을, 앞서 제작한 ‘총 주문수 조회 전용 API’로 대체.   
       2. fetchPayments 로직을 삭제하고, 앞서 제작한 ‘총 매출액 조회 전용 API’로 fetchTotalRevenue 함수를 새로 제작.  
       3. 함수들 재배치 및 그룹화.  
    2. 관리자 레이아웃 컴포넌트 작업  
       1. 랜더링 리턴 영역의 스타일 설정을 밖으로 빼내는 작업 진행. 모바일 환경에서 어색하게 출력되는 드로어 타이틀 높이 수정.  
       2. 권한검증 useEffect 로직을 리팩토링. 함수들 재배치 및 그룹화.  
    3. 레이아웃 컴포넌트 작업  
       1. 중첩구조의 함수들을 리팩토링 작업 진행. 모바일 화면 크기 체크 useEffect 내부에서 const checkMobile 분리. 카테고리 경로 조회 useEffect 내부에서 const fetchTopCategories, const fetchSubCategories 분리. 카테고리 정보 업데이트 useEffect 내부에서 const updateCategoryInfo 분리.  
       2. 최근 규격화한대로 API 로직 최적화(const fetchTopCategories, const fetchSubCategories, const handleCategoryClick). 특히 초반 작업물이다보니 API 처리 중 예외 발생시 error state에 메시지를 저장하여 뷰포트에 출력하는 방식이 현재 규격화된 방식과 맞지 않아, App의 message로 오류 메시지를 출력하도록 수정하는 작업도 진행.  
       3. 최근 규격화한대로 함수 그룹화와 재정렬 진행.  
44. 쇼핑몰 스프링 프로젝트 백엔드 작업  
    1. 결제 관련 API 로직 작업  
       1. 전에 결제 관련 API 로직을 초안을 러프하게 제작한 후 자세한 검토는 보류했다가, 얼마전 관리자 대시보드 페이지 작업을 하다가 훑어보게 됐는데 서비스 단계 코드가 좀 이상해보여서 전면 재검토를 결정.  
       2. 서비스 단계 함수들에 try-catch 구조가 있는건 다시보니 어색해보여서 추가로 확인해보니, 컨트롤러 단계에 이미 try-catch 구조가 있다면 서비스 단계의 try-catch 구조는 특별한 경우가 아니면 불필요한게 맞음. 전면 수정을 결정.  
       3. 서비스 단계의 public PaymentInfoDTO createPaymentInfo 함수와 연결된 함수들에 있는 try-catch 구조 해제. 그리고 이와 연동되는 컨트롤러의 public ResponseEntity\<?\> preparePayment 함수의 catch 커버리지가 누락된 부분을 보강하고 코드 정리.  
       4. 서비스 단계의 public PaymentDataDTO verifyPayment 함수와 연결된 함수들에 있는 try-catch 구조 해제하고, 재사용성이 없지만 분리된 함수를 흡수시킴. 그리고 이와 연동되는 컨트롤러의 public ResponseEntity\<?\> verifyPayment 함수의 catch 커버리지가 누락된 부분을 보강하고 코드 정리.  
       5. 서비스 단계의 public PaymentDataDTO cancelPayment 함수와 연결된 함수들에 있는 try-catch 구조 해제하고, 재사용성이 없지만 분리된 함수를 흡수시킴. 그리고 이와 연동되는 컨트롤러의 public ResponseEntity\<?\> cancelPayment 함수의 catch 커버리지가 누락된 부분을 보강하고 코드 정리.  
       6. 서비스 단계의 public PaymentDataDTO cancelPayment 함수와 연결된 함수들에 있는 try-catch 구조 해제하고, 재사용성이 없지만 분리된 함수를 흡수시킴. 그리고 이와 연동되는 컨트롤러의 public ResponseEntity\<?\> cancelPayment 함수의 catch 커버리지가 누락된 부분을 보강하고 코드 정리.  
       7. 서비스 단계의 public VirtualAccountDTO requestVirtualAccount 함수와 연결된 함수들에 있는 try-catch 구조 해제하고, 재사용성이 없지만 분리된 함수를 흡수시킴. 그리고 이와 연동되는 컨트롤러의 public ResponseEntity\<?\> requestVirtualAccount 함수의 catch 커버리지가 누락된 부분을 보강하고 코드 정리.  
       8. 서비스 단계의 public void processWebhook 함수와 연결된 함수들에 있는 try-catch 구조 해제하고, 재사용성이 없지만 분리된 함수를 흡수시킴. 그리고 이와 연동되는 컨트롤러의 ResponseEntity\<?\> handleWebhook 함수의 catch 커버리지가 누락된 부분을 보강하고 코드 정리.  
       9. 서비스 단계의 public PaymentHistory getPaymentHistoryByImpUid 함수와 연결된 함수들에 있는 try-catch 구조 해제하고, 재사용성이 없지만 분리된 함수를 흡수시킴. 그리고 이와 연동되는 컨트롤러의 public ResponseEntity\<?\> getPaymentHistoryByImpUid 함수의 catch 커버리지가 누락된 부분을 보강하고 코드 정리.  
       10. 서비스 단계의 public PaymentHistory getPaymentHistoryByMerchantUid 함수와 연결된 함수들에 있는 try-catch 구조 해제하고, 재사용성이 없지만 분리된 함수를 흡수시킴. 그리고 이와 연동되는 컨트롤러의 public ResponseEntity\<?\> getPaymentHistoryByMerchantUid 함수의 catch 커버리지가 누락된 부분을 보강하고 코드 정리.  
       11. 서비스 단계의 public PaymentHistory getPaymentHistoryByOrderId 함수와 연결된 함수들에 있는 try-catch 구조 해제하고, 재사용성이 없지만 분리된 함수를 흡수시킴. 그리고 이와 연동되는 컨트롤러의 public ResponseEntity\<?\> getPaymentHistoryByOrderId 함수의 catch 커버리지가 누락된 부분을 보강하고 코드 정리.  
       12. 서비스 단계의 public PaymentHistorySearchResultDTO searchPaymentHistory 함수와 연결된 함수들에 있는 try-catch 구조 해제. 그리고 이와 연동되는 컨트롤러의 public ResponseEntity\<?\> searchPaymentHistory 함수의 catch 커버리지가 누락된 부분을 보강하고 코드 정리.  
       13. 서비스 단계의 public int getTotalRevenue 함수가 int가 아닌 BigDecimal을 받도록 하류(DAO, Mapper)의 로직을 수정하여 public BigDecimal getTotalRevenue로 수정. 컨트롤러 단계의 public ResponseEntity\<?\> getTotalRevenue 함수도 맞춰서 수정하고, catch 커버리지가 누락된 부분을 보강하고 코드 정리.  
       14. 핵심 API 함수들의 수정 이후, 서비스 단계의 함수들을 전면 검토하여 수정이 필요한 부분 수정.  
       15. 모든 해당 서비스 단계 함수들의 예외 처리 로직에 DB 기록 코드 추가.  
       16. 모든 해당 컨트롤러 단계 함수들의 비설정 예외 처리시에도 DB에 기록 코드 추가.  
45. 쇼핑몰 리액트 프론트엔드 작업  
    1. 상품 마스터 페이지 작업  
       1. ‘상품 리뷰’ 항목이 누락되어 추가하는 작업 진행. 리뷰 조회 API를 연동하는 함수를 만들고,‘상품 정보’ 항목 아래에 \<Title\> \+ \<Card\> \+ \<List\> 구성으로 세팅하여 리뷰를 출력하는 초안 세팅.   
       2. 세팅한 초안이 출력은 되는데 디자인을 어떻게 잡아야할지 고민해야 하는 상황. 로직들을 검토하면서 디자인을 고민하다보니, DB reviews 테이블 칼럼 중 productId이 잘못 세팅된걸 깨달음. 왜냐하면 회원이 주문하는 기본 단위가 상품 품목(productItem)인데 상품 마스터(product)의 ID를 칼럼으로 세팅했기 때문에, 현재 세팅으로는 리뷰한 상품 품목의 정보를 출력하기 힘들어지게 됨. 결국 칼럼 수정이 필요한 상황.  
46. 쇼핑몰 스프링 프로젝트 백엔드 작업  
    1. DB reviews 테이블 수정 & 관련 로직들 수정  
       1. productId 칼럼을 productItemId 칼럼으로 수정.  
       2. productId 칼럼이 로직에 포함되어 있던 VO, Mapper, Service, DTO의 코드들을 수정.  
47. 쇼핑몰 리액트 프론트엔드 작업  
    1. 상품 마스터 페이지 작업  
       1. 백엔드 수정에 맞춰서 리뷰 조회 API 로직을 수정해야하는데, 단순히 productId을 productItemId로 변경하는걸로는 문제가 있는 상황. 왜냐하면 상품 마스터 하나에 상품 품목 여러개가 포함되어 있으므로, 상품 마스터 페이지의 리뷰 조회를 하려면 API 요청시 여러 상품 품목을 백엔드로 넘겨서 처리하도록 백엔드 로직을 뜯어고쳐야 하기 때문. 일단 API 요청시 해당 상품 품목들을 리스트로 넘기면, 매퍼에서 리스트를 풀어서 조회하는 방식으로 수정을 결정.  
48. 쇼핑몰 스프링 프로젝트 백엔드 작업  
    1. 리뷰 조회 API 로직 수정  
       1. 프론트엔드에서 상품 품목을 넘겨야하니까 DTO에 상품 품목 리스트 항목을 추가하고, 매퍼에서는 해당 리스트를 풀어서 하나씩 조회하는 조건 추가.  
       2. 수정 후 API 요청에 500에러가 출력되는 문제가 생기긴 했지만, 원인을 추적하여 하나씩 해결하여 결과적으로 200응답 출력 확인.  
49. 쇼핑몰 리액트 프론트엔드 작업  
    1. 관리자 리뷰 관리 페이지 작업  
       1. 리뷰 조회 API 로직을 전반적으로 건드렸다보니, 해당 API를 사용하는 다른 페이지인 관리자 리뷰 관리 페이지에 문제가 생겼는지 체크. 메인 테이블 칼럼인 상품 마스터 ID와 회원 이메일 쪽 출력에 문제가 생겨서, 원인을 추적해서 차차 해결. 문제들을 해결 후 가만히 생각해보니, 해당 페이지를 작업할때만해도 상품 마스터 ID 밖에없었지만 그 후 상품 마스터 코드를 추가했다는게 떠오름. 상품 마스터의 구별을 위해 상품 마스터 코드를 추가한 것이므로, 메인 테이블의 상품 마스터 ID 칼럼을 상품 마스터 코드로 변경하고 관련 로직도 코드에 맞춰 전부 변경. 정상 작동 확인.  
    2. 상품 마스터 페이지 작업  
       1. 리뷰 조회 API 로직을 새로 정비했으니, 다시 상품 마스터 페이지의 ‘상품 리뷰’ 항목 작업으로 복귀.  
       2. 리뷰 조회 API로 불러온 정보들 중 회원이름, 주문 품목 옵션(사이즈/컬러), 평점, 리뷰내용을 \<Card\>에 출력시킬 항목으로 최종 결정. \<Card.Meta\>를 사용하여 항목들을 데스크톱 환경과 모바일 환경 모두 자연스러운 디자인으로 출력될 때까지 수정을 반복.   
       3. 전체 리뷰 요약 카드의 내용이 데스크톱 환경에서는 정상적으로 한 줄로 출력되지만, 모바일 환경에서는 내용 크기가 그대로인데 폭이 줄어들다보니 두 줄로 비정상 출력되는 문제 확인. 모바일 환경에서는 자동으로 내용 크기와 간격이 조절되어 한 줄 출력이 망가지지 않게 수정. 정상 출력 확인.  
       4. 페이지 로딩시 스피너가 출력될때, 푸터 영역이 세팅한 것보다 비정상적으로 많은 높이를 차지하는 문제가 있음. 로딩 컨테이너 스타일 설정을 조정하여 정상출력되도록 수정.  
50. 쇼핑몰 스프링 프로젝트 백엔드 작업  
    1. 리뷰 관련 API 로직 수정  
       1. 상품 마스터 페이지에 리뷰들이 정상 출력되는지 더미 데이터로 확인했으나, 아직 주문 회원이 리뷰를 등록하는 루트를 프론트엔드에 세팅을 아직 안했다는 사실을 깨달음. 프론트엔드에 리뷰 등록 루트를 세팅하기 전에, 리뷰 등록 API에 문제가 없는지 검토 진행. 리뷰 등록 API의 서비스 단계에 검증 로직이 부족하다고 판단.   
       2. 주문 한번 하고 리뷰를 여러번 쓰는것을 막기 위한 ‘해당 주문 품목으로 이미 작성된 리뷰 존재 여부 검증’ 로직을 추가해야하는데, reviews 테이블에 주문 품목 정보를 담는 칼럼이 없는 상황. reviews 테이블에 order\_product\_id 칼럼을 추가하고 이에 맞춰 VO, Mapper, DTO에 칼럼 정보 추가. 그 후에  ‘해당 주문 품목으로 이미 작성된 리뷰 존재 여부 검증’ 쿼리를 리뷰 Mapper에 세팅하고, 리뷰 등록 API의 서비스 단계에 연동.  
       3. ‘해당 주문 품목에 유저ID와 구매확정 상태의 검증’ 로직 추가를 위해, 해당 쿼리를 주문 Mapper에 세팅하고 리뷰 등록 API 서비스 단계에 연동.  
       4. 리뷰 등록/수정/삭제를 마이페이지 주문 관리 페이지에서 ‘구매확정’ 상태인 주문 품목에 한해서만 접근할 수 있도록 구상 중인데, 그러려면 마이페이지 주문 관리 페이지에서 해당 회원의 리뷰 정보를 API로 불러와야 해서 ‘리뷰 조회(회원ID 기준) API’를 추가로 세팅.  
51. 쇼핑몰 리액트 프론트엔드 작업  
    1. 마이페이지 주문관리 페이지 작업  
       1. 새로만든 ‘리뷰 조회(회원ID 기준) API’를 연동하여 해당 회원의 리뷰 정보를 가져오고, 주문 품목의 상태에 따라 ‘작업’ 칼럼에 리뷰 관련 버튼이 출력되도록 세팅. 주문 품목이 ‘구매확정’ 상태가 아니면 아무 버튼도 안나오고, ‘구매확정’ 상태이면서 리뷰가 없으면 ‘리뷰작성’ 버튼을 출력시키고, ‘구매확정’ 상태이면서 삭제되지 않은 리뷰가 있으면 ‘리뷰수정’ 버튼을 출력시키고, ‘구매확정’ 상태이면서 삭제된 리뷰가 있으면 ‘리뷰 삭제됨’ 버튼(불활성)을 출력시키는 로직.  
       2. 새로 만든 버튼을 눌렀을때 작동시킬 리뷰 작성/수정 모달을 추가. 스타일 세팅하고 리뷰 작성 API, 리뷰 수정 API, 리뷰 삭제 API 로직 연동시킴. 리뷰 수정 테스트를 해봤는데 오류가 남. 추적해보니 주문 정보를 API로 받아온 뒤 flatMap으로 평탄화시키는 함수에서 부정확하게 세팅된 부분이 있어서 수정하고, DB의 더미데이터가 잘못 세팅된 부분이 있어서 수정. 의심되는 부분들을 수정하고나서 리뷰 수정 기능이 정상작동하지만, 코드를 검토하다보니 Optimistic Lock 로직에 필요한 version 항목이 프론트엔드에서 세팅되지 않았는데 정상작동하는건 문제가 있다는걸 발견.  
52. 쇼핑몰 스프링 프로젝트 백엔드 작업  
    1. 리뷰 관련 API 로직 수정  
       1. 프론트엔드에서 version 항목을 안넣어도 왜 Optimistic Lock을 통과하는지 추적해보니, 서비스 단계에서 자동으로 최신 version 정보를 넣는 잘못된 로직이 포함된게 원인이었음. version 정보는 프론트엔드에서 받아오도록 수정은 했는데, 문제는 다른 API들에 세팅한 Optimistic Lock 로직도 비슷하게 만들었었어서 전수 검토하여 수정해야 하는 상황.  
    2. Optimistic Lock를 포함한 API 로직들 수정  
       1. API 서비스 단계를 전부 검토하여 Optimistic Lock인데 version을 프론트엔드에서 받아 넣지 않으면 수정.  
       2. 검토하는 중 UserService의 비밀번호 재설정 토큰 업데이트 로직에도 낙관적 잠금을 세팅했던걸 분석하다보니, 이 로직은 프론트엔드에서 먼저 version 정보를 받을 수가 없는 구조라는걸 깨달음. 따라서 비밀번호 재설정 토큰 업데이트 로직의 낙관적 잠금 세팅을 해제함.  
53. 쇼핑몰 리액트 프론트엔드 작업  
    1. 비밀번호 재설정 페이지 작업  
       1. 낙관적 잠금 세팅을 해제하면서 검토하다보니, API 로직에서 백엔드가 넘겨주는 메시지를 제대로 받고 있지 않은 세팅이라 깔끔하게 수정.  
    2. 인증 로직 작업  
       1. 관리자 계정으로 로그인 한 후, 홈페이지에 접속하면 로그인이 풀리지 않고 일반 회원 로그인과 동일하게 유지되는 문제 확인. 관리자 로그인 시 일반 페이지에 접근할 때 자동으로 로그아웃되도록 AuthProvider 컴포넌트와 AuthContext의 로직 수정. 정상 작동 확인.  
       2. 일반 회원과 관리자 모두, 로그인 후에도 로그인 페이지나 회원가입 페이지에 접근할 수 있는 문제 발견. PrivateRoute 컴포넌트를 새로 만들어서 일반 회원이나 관리자의 부적절한 접속을 제한하는 로직을 세팅 후, App.js에 적용.  
       3. 마이페이지 주문관리 페이지 작업하면서 보면, 분명 로그인 상태에서 새로고침을 했는데 로그아웃되어 로그인 페이지로 리다이렉트 된 직후 홈페이지로 연속 리다이렉트 되는 문제가 있음. 추적해보니 AuthContext의 checkAuthStatus 함수에서 토큰 검증과 상태 설정을 하는 동안 loading 상태가 true가 되는데, 이 시점에 PrivateRoute와 PublicRoute가 loading 상태를 고려하지 않고 바로 리다이렉트 판단을 하는 것이 원인이었음. 따라서 PrivateRoute와 PublicRoute 컴포넌트에서 loading 상태를 체크하도록 수정. 정상 작동 확인.  
    3. 마이페이지 주문 관리 페이지 작업  
       1. ‘리뷰작성/리뷰수정/리뷰 삭제됨’ 버튼과 모달을 테스트. 버튼별 출력 조건이 꼬여서 조건에 안맞는 버튼과 모달이 출력되거나, 수정이나 삭제 후에도 최신화가 적용 안되는 문제 발생. 제대로 출력되는 로직을 찾을때까지 수정을 계속하여 최종적으로 문제 해결. 수정 내용을 입력하고 모달이 자동으로 닫히기 직전 짧은 시간동안 입력 항목들이 초기화되는 모습이 보이는 문제가 있어서, 모달이 먼저 닫히고 항목 초기화는 나중으로 미는 수정으로 해결. 마이페이지 주문 관리페이지가 열리거나 새로고침될때, 메인영역의 표에 바로 로딩 스피너가 돌지 않고 데이터가 없을때의 기본 폼인 'no data' 출력이 잠깐 나온 후에야 로딩 스피너가 도는 문제가 있어서, Table 컴포넌트의 locale 속성을 수정하는 것으로 해결.  
       2. 모바일 환경에서 어떻게 출력되는지 확인. 모바일 환경에서 출력되는 카드에 리뷰 관련 버튼 추가 작업을 안한게 보여서, 데스크톱 환경 메인 표의 ‘작업’ 칼럼에 추가한 로직을 모바일 카드에도 추가. 부자연스러운 디자인 요소들은 스타일 설정을 건드려서 정리.   
    4. 레이아웃 컴포넌트 작업  
       1. 마이페이지 주문 관리 페이지에서 데스크톱 환경이나 모바일 환경 모두 첫 진입시 로딩될때 레이아웃의 푸터가 비정상적으로 공간을 많이 차지하는 문제가 있어서, 추적해보니 레이아웃 스타일 설정 문제였음. MainContent 컴포넌트의 min-height 세팅을 제거하여, 컨텐츠의 양에 따라 자연스럽게 레이아웃이 조정되고 푸터가 항상 컨텐츠 바로 아래에 위치하도록 수정. 정상 출력 확인.  
    5. ResponsiveContext.js 세팅  
       1. 데스크탑 환경과 모바일 환경을 오가며 이런저런 테스트를 하면서, 어떤 페이지는 실시간으로 랜더링 출력 전환이 되고 어떤 페이지는 실시간으로 안되는 등 통일성이 없다는걸 깨달음. 최종적으로 대부분의 페이지에 적용되어야하는 로직이긴해서, Context API 방식을 통해 일관된 반응형 기준을 전역에서 관리하기로 결정.   
       2. ResponsiveContext.js을 만들어 768px 폭을 기준으로 반응형 로직을 세팅하고, App.js에 추가.  
    6. 인증에 따른 페이지 접근 설정 작업  
       1. 앞서 PrivateRoute와 PublicRoute을 추가하는 작업을 한 후, 관리자 로그인 페이지를 통해 로그인 시 대시보드로 이동하자마자 '관리자 계정은 일반 페이지에 접근할 수 없습니다.' 메시지가 뜨면서 관리자 로그인 페이지로 강제 이동하는 문제 발견. 추적해보니 PublicRoute.js 로직과 App.js 라우팅 세팅에 문제가 있고, AuthContext.js의 URL 기준으로 접근을 통제하는 기존 로직도 충돌을 일으키는 원인 중 하나였음. 수정해야하는김에 PrivateRoute와 PublicRoute만으로 3가지 경우의 수를 커버하는게 마음에 안들어서, 3가지 경우의 수만큼 다시 세팅(UserOnlyRoute, AdminOnlyRoute, GuestOnlyRoute). AuthContext.js에서는 충돌하는 로직을 삭제하고, AdminLayout.js의 권한 검증은 중복되니 삭제하고, 변경된 Route에 맞춰 App.js 라우팅 세팅 수정. 문제가 생기는 부분은 재차 수정 작업. 정상 작동 확인.  
    7. 레이아웃 작업  
       1. 관리자 로그인 시 일반 페이지에 접속하면, 레이아웃 우상단의 메뉴 아이템이 다르게 출력되도록 세팅해야함. 관리자 로그인 시 ‘대시보드’ 버튼과 ‘로그아웃’ 버튼이 출력되도록 로직 추가. 정상 출력 확인.  
       2. 전역 스타일 설정을 레이아웃에서 제대로 끌어쓰지 못하고 있다는걸 인지. 전역 스타일 설정 중 끌어올 수 있는건 끌어오고, 중복되는 부분 정리.  
    8. 검색 결과 출력 페이지 작업  
       1. 레이아웃 작업 중 검색 기능 연동이 안되어있는걸 확인. 예전에 연동할 백엔드 쪽 세팅을 다 해놨었는데, 출력할 페이지 세팅 때문에 나중으로 미뤘었음. 어차피 레이아웃 헤더의 카테고리 항목을 클릭했을때 해당 카테고리의 상품 리스트를 출력하는 CategoryPage.js를 만들어놨었는데, 이 페이지가 검색 기능을 통해 상품 리스트를 출력하는 목적에 부합하여 조금만 수정하면 되는 상황이라 작업 시작.  
       2. CategoryPage.js를 ProductListPage.js로 파일명을 변경. 카테고리 항목으로 상품을 조회하는 API는 검색어로도 조회할 수 있게 예전에 세팅해뒀기 때문에, 상품 목록 조회 로직에 검색어 키워드를 백엔드로 넘길 수 있는 로직 추가. 각 상황에 따라 페이지 타이틀 출력이 다르게 되도록 조건 로직 추가. 정상 작동 확인.  
       3. 검색어로 상품 조회를 했을 경우, 레이아웃 헤더의 카테고리 항목이 초기화 되어야 사용자 경험상 자연스러움. 따라서 Layout.js의 검색 이벤트 로직에 카테고리 관련 정보를 초기화하는 로직 추가. 정상 작동 확인.  
    9. ResponsiveContext.js 세팅  
       1. 해당 반응형 로직을 필요한 페이지에 일괄적으로 적용하고, 중복되는 기존 로직이 있는 페이지는 기존 로직을 삭제하는 작업 시작. AdminDashboard, CartPage, MyPageOrderManagement, OrderPage, AdminLayout, Layout 작업 완료.  
    10. 주문/결제 페이지 작업  
        1. 모바일 환경에서 컨텐츠들의 폭이 안맞춰져서 뷰포트를 뚫고 나가는 문제가 있음. 최상위 컨테이너의 폭이 뷰포트에 맞춰지도록 수정하는걸로 뚫고 나가는 문제는 해결되었으나, 주문 상품 표가 애매하게 좌우 스크롤이 생기는 상황. 컨테이너들의 좌우 여백을 더 좁히는걸로 어느정도 해결.  
        2. 데스크탑 환경에서는 ‘결제하기’ 버튼으로 포트원 팝업이 정상적으로 뜨는데, 모바일 환경에서는 작동을 안하고 “PaymentError: 결제 창 호출에 실패하였습니다. 리디렉션 방식으로 결제창을 호출하려면 리디렉션 URL은 필수 입력입니다.” 오류 로그가 출력되는 상황. 확인해보니 모바일 환경에서는 리디렉션 방식으로 결제가 처리되어 리디렉션 세팅을 해줘야한다고 함. PaymentContext에서 모바일 환경일 경우 paymentData.m\_redirect\_url이 마이페이지 주문관리 페이지로 설정되도록 코드 추가. 모바일 환경에서는 결제 팝업창이 아니라 결제 페이지로 정상적으로 넘어가는걸 확인.  
        3. 이제 모바일 환경에서 결제 페이지로 넘어가는 지는데, 결제 성공만 고려하여 세팅한 리디렉션 때문에 결제를 취소해도 마이페이지 주문관리 페이지로 이동하는 문제가 있음. 결제 취소 시에는 주문/결제 페이지로 돌아가는 것이 사용자 경험에 더 좋다고 생각함. 포트원 규격에 맞춰서 일단 아무것도 랜더링되지 않는 결제 완료 페이지를 임시로 만들어서 리디렉션으로 설정하고, 포트원에서 보내는 결제 성공/실패 파라미터를 받아 성공 시 주문 관리 페이지로 이동시키고 실패/취소 시 주문 페이지로 돌아가는 로직 세팅. 아무 랜더링 없는 페이지가 중간에 걸리긴 하지만, 일단 정상 작동 확인.  
        4. 모바일 환경에서 '주문하기' 버튼을 누르면 포트원 결제 페이지로 넘어가기 직전에 message.error('결제 처리 중 오류가 발생했습니다. 잠시 후 다시 시도해주세요.');가 출력되는 문제가 있음. 아마 포트원과 연동하는 const handleOrder가 결제 팝업창을 띄우는 로직에 한정되어있어서 결제 페이지로 넘어가버리는 모바일 환경에서는 catch (error) 영역으로 넘어가기 떄문에 생기는 문제로 추정됨. catch (error) 영역에 모바일 환경이면 에러 메시지를 출력시키지 않는 로직 추가. 정상 작동 확인.  
        5. 모바일 환경에서 결제를 취소하면 주문/결제 페이지로 리다이렉션되는 도중에 '\[PAY\_PROCESS\_CANCELED\] 사용자가 결제를 취소하였습니다' 메시지가 출력되는데, 이건 개발자에게 노출되는걸 전제로 포트원에서 전달하는 메시지라고 생각해서 사용자 경험에 좋지 않다고 생각함. OrderCompletePage의 메시지 출력 세팅을 수정하여 사용자 친화적인 텍스트를 하드코딩. 정상 작동 확인.  
        6. 규격대로 함수 그룹화 및 순서 정리.  
    11. API 로직 최적화  
        1. 이전에 API 로직을 더 엄밀하게 규격화 했었는데, 최근에 백엔드 컨트롤러 코드와 비교하면서 다시 보다보니 굳이 필요없는 코드까지 포함되어있는걸 알게됨. try 영역에서 API 요청으로 백엔드에서 응답을 받으면 ‘if (response.status \=== 200\) { } else { }’로 처리하게 되면 200응답일때는 if 영역에서 다루고 400에러나 500에러면 else 영역으로 넘어갈거라 생각했었는데, 다시 확실하게 알아보니 try 영역에서 400에러나 500에러가 나오면 바로 catch 영역으로 넘어가는거였음. 따라서 try 영역의 ‘if (response.status \=== 200\) { } else { }’는 기능적으로 크게 의미가 없어서 if-else를 벗겨내는게 코드 낭비가 없는 상황. 따라서 프론트엔드 파일을 전수 검토하여 해당 if-else를 벗겨내고, 하는김에 백엔드에서 예외상황에 메시지가 전달되지 않을경우 출력할 하드코딩 텍스트도 최적화 진행. Layout, AdminLogin, AdminOrders, AdminPayments, AdminProducts, AdminReviews, AdminUsers, CartPage, HomePage, LoginPage, MyPageOrderManagement, MyPageUserInfoManagement, OrderPage, ProductDetail, RegisterPage, ResetPasswordPage, AuthContext, PaymentContext 검토하여 최적화 완료.  
        2. API를 호출할때 다른 페이지에서는 AuthContext의 authRequest를 가져와서 쓰는데, 극초반에 작업한 관리자 대시보드 페이지는 authRequest가 아니라 자체적으로 const handleApiResponse을 선언해서 쓰고있는 이상한 상황. 다른 페이지와 동일한 API 로직을 쓰도록 수정.  
54. 쇼핑몰 스프링 프로젝트 백엔드 작업  
    1. API 컨트롤러 작업  
       1. 백엔드 API 컨트롤러 단계들의 코드가 예외처리 등의 코드가 어설프게 세팅 되어있어서(특히 초기 작업 본) 정리 필요. UserController, ProductController, OrderController, ReviewController, PaymentController를 싹 검토하여 코드 정리 완료.  
55. 쇼핑몰 리액트 프론트엔드 작업  
    1. 관리자 주문 관리 페이지 작업  
       1. 해당 페이지에서 주문 품목 상태에 따른 관리자가 수행할 기능의 버튼들이 출력되는건 세팅되어있는데, 각 버튼마다 필요한 API 연동이 안되어있는 상황. 백엔드에 이미 API 세팅은 되어 있으므로 프론트엔드와 연동시키기만 하면 됨.   
       2. 각 상황별 버튼들이 백엔드에 세팅된 API와 연동될 수 있게, API 로직 수정. 연동해야할 API가 여러개라 특히 API url과 백엔드에 DTO로 넘겨야할 정보 패킹에 유의하여 작업.   
    2. 마이페이지 주문관리 페이지 작업  
       1. 해당 페이지에서 주문 품목 상태에 따른 회원이 수행할 기능의 버튼들에 API가 연동은 되어있는데, 이상하거나 보강해야할 부분이 있는지 검토. 백엔드에 DTO로 넘겨야할 정보 패킹에 문제가 있어서 수정.  
    3. 홈페이지 작업  
       1. 상단에 이벤트 배너를 출력하는 세팅을 맞췄었는데, 이벤트 구상하고 배너 이미지 제작할거 생각하면 약간 포트폴리오 본질에서 벗어나는 느낌이 드는 중. 그래서 이벤트 배너 코드를 밀어버리고, 포트폴리오 쇼핑몰임을 명시하는 배너 코드를 세팅. 배너 배경색은 테마에 어울리게 모노톤으로 하되, 너무 단조롭지 않으면서 시선을 끌기위해 그라데이션을 줌. 포트폴리오 목적의 쇼핑몰 데모라는 내용과. 실제 결제 및 배송 불가하다는 내용과, 연락처 이메일을 명시. 모바일 환경에서 디자인이 애매해져서 스타일 속성 조정.  
    4. 상품 마스터 카드 컴포넌트 작업  
       1. 기성 쇼핑몰 이미지를 끌어다 쓸 생각이므로, 시각적으로 명시되는 요소를 추가할 필요가 있다고 생각. 상품 이미지 위에 CSS로 “DEMO” 워터마크를 출력하도록 세팅하되, 상품 이미지가 없는 경우에는 워터마크가 출력되지 않도록 함.  
    5. robots.txt 수정  
       1. 포트폴리오용 데모 사이트라고 명시하는 내용을 추가.  
56. 깃허브에 포트폴리오 업로드 작업  
    1. 예전에 백엔드 프로젝트는 깃허브 업로드 테스트를 통해 레포지토리에 올라갔었는데, 현재는 프론트엔드 프로젝트가 추가된 상황. 기존 백엔드 프로젝트 레포지토리에 상위 폴더를 만들고 프론트엔드 프로젝트를 백엔드 프로젝트와 함께 차상위 폴더에 정리할 수 있는지 알아봤는데 그렇게는 안되는걸로 나옴. 따라서 ‘기존 백엔드 레포지토리는 건들지 않고 프론트엔드 레포지토리를 별도로 생성’하는 방안과 ‘기존 백엔드 레포지토리를 밀어버리고 프론트엔드와 백엔드가 모두 들어간 새로운 레포지토리를 생성’하는 방안 중 하나를 골라야 함. 작업 중인 프론트엔드와 백엔드는 하나의 포트폴리오의 프로젝트들이므로 후자가 더 낫겠다고 판단함.  
    2. 방향을 정하고 방법을 조사하다보니, 레포지토리에 로컬 폴더를 연동하는 방식이 생각보다 매우 경직되어있다는걸 알게 됨. 기본적으로 로컬 폴더 하나와 레포지토리 하나가 1:1 대응하는 방식이라, 다른 루트의 로컬 폴더 두 개를 하나의 레포지토리와 연동시키는건 불가능한 구조임. 현재 백엔드 프로젝트 폴더와 프론트엔드 프로젝트 폴더는 동일한 상위 폴더에 묶여있긴한데, 문제는 그 상위 폴더엔 다른 폴더들도 존재하기 때문에 상위 폴더를 그대로 레포지토리에 올리면 포트폴리오와 관계없는 폴더들도 올라가는 상황. 그래도 같이 있는 다른 폴더들은 연습용 프로젝트들이라서 앞으로 깃허브에 올라갈 일은 없고, .gitignore 설정을 통해 포트폴리오 폴더들만 필터링해서 업로드가 가능하다는걸 알게되어 그렇게 진행할 예정.  
    3. 일단 예전에 만든 백엔드 프로젝트만 올라간 레포지토리를 삭제. 포트폴리오 통합 레포지토리를 새로 만들고, 상위 폴더를 원격 저장소로 연결.  
    4. 상위 폴더에 .gitignore를 만들어 어떻게 필터링할지 구상. 일단 상위 폴더에서 업로드할 폴더&파일만 지정(백엔드 프로젝트 폴더, 프론트 프로젝트 폴더, .gitignore 파일, README.md 파일). 그리고 백엔드 프로젝트 폴더와 프론트 프로젝트 폴더 내에서 업로드하지 않을 폴더나 파일을 지정(빌드 설정, IDE 설정, 환경변수 등). 이 과정에서 백엔드 프로젝트의 data.sql 파일(관리자 계정 등록 기능을 안만들거라서 프로젝트가 실행될때 DB에 관리자 계정 정보를 강제 업로드하는 코드였으나, 지금 다시 생각해보니 이미 서버의 DB는 HeidiSQL 등으로 별도 조작이 가능하므로 필요없는 코드로 판단.)을 삭제하고, application.properties에 관련 코드도 삭제.  
    5. application.properties 코드를 검토하다보니, MariaDB 계정 정보가 하드코딩 되어있어서 깃허브에 업로드되지 않는 파일이라 하더라도 보안처리는 해야한다고 생각함. MariaDB 계정 정보를 환경변수로 전환.  
57. AWS 서버 MariaDB 작업  
    1. MariaDB 계정이 과외 수업으로 진행할때 만들었다보니, 비밀번호가 너무 엉성하게 세팅되어있는 상황. 비밀번호를 수정하는 방법을 조사하다보니, 일반적으로 DB 계정은 개발 환경 접속용과 운영 환경 접속용 등 목적에 따라 나눠서 사용하는게 권장된다는걸 알게 됨. 따라서 엉성하게 만든 비밀번호도 수정하고, 운영 환경 접속용 계정을 추가로 만들기로 결정.  
    2. AWS 서버 SSH를 통해 MariaDB 접속. 개발환경 접속용 계정의 비밀번호 수정. 운영환경 접속용 계정 새로 생성하고 권한 부여.  
58. DB 교통정리  
    1. 지금까지 백엔드 프로젝트와 프론트엔드 프로젝트는 로컬에서 개발하고, AWS 서버에 올린 DB를 백엔드와 연동하여 테스트 중이었음. 나중에 어차피 AWS 서버에 포트폴리오 프로젝트들 올려서 라이브 데모 돌릴 예정이었어서 자연스럽게 AWS 서버 DB를 연동하고 있던건데, 깃허브 레포지토리와 AWS 서버에 백엔드와 프론트엔드 프로젝트를 올리기 전에 머리속으로 시뮬레이션을 돌려봤을때 문제가 있음을 인지함. 왜냐하면 AWS 서버에 라이브 데모가 돌아가기 시작한 후에도 미완성 버전이라 구현할 부분이 남았으므로, 로컬 개발과 로컬 테스트를 해보고 AWS 서버에 업데이트를 이어나가야하는데… 로컬 개발 환경과 운영 환경 모두 하나의 DB를 쓰면 로컬 테스트하면서 생기는 DB의 변화가 운영 환경과 충돌할경우 라이브 데모에 오류를 발생시킬 것이기 때문. 이런 예상되는 문제를 방지하기 위해서 알아보고 고민해본 결과, 로컬에 개발 테스트용 DB(dev)와 스테이징용 DB(staging)와 운영 DB 백업용 DB(copy)를 추가하기로 결정. 이렇게하면 로컬 테스트가 필요한 시점에 ‘운영 DB를 스테이징용 DB에 복사 \> 개발 테스트용 DB의 스키마를 스테이징용 DB에 적용 \> 스테이징용 DB를 개발 테스트용 DB에 복사’하여 운영 DB의 내용으로 테스트가 가능하며, 업데이트가 필요한 시점에는 ‘운영 DB를 백업용 DB에 복사 \> 개발 테스트용 DB의 스키마를 운영 DB에 적용(백엔드와 프론트엔드도 업데이트) \> 문제가 생기면 백업용 DB로 롤백’하면 됨.  
    2. 로컬 MariaDB에 'portfolio\_shopping\_mall\_dev', 'portfolio\_shopping\_mall\_staging', 'portfolio\_shopping\_mall\_prod\_copy' DB를 추가. AWS 서버의 DB(스키마+데이터)를 .SQL로 내보내기하고 새로만든 DB들에 복사함.  
    3. 로컬 MariaDB 계정을 예전에 강의들을때 만들었다보니 아주 낮은 보안수준의 비밀번호로 세팅했다는게 기억남. 생각난김에 로컬 MariaDB 계정 비밀번호를 높은 보안수준의 비밀번호로 변경.  
59. 쇼핑몰 스프링 프로젝트 백엔드 작업  
    1. application.properties 작업  
       1. application-dev.properties (개발용), application-staging.properties (스테이징용), application-prod.properties (운영용) 파일을 새로 생성하고, application.properties에 세팅되어있던 DB 연동 코드를 환경별로 분리.  
       2. Run 패널에서 각 환경을 선택하여 실행할 수 있도록 launch.json 파일을 수정. 정상 작동 확인.  
    2. 전화번호 암호화 로직 작업  
       1. 얼마전에 보안관련 이슈를 체크하다가 알게된건데, 전화번호는 개인식별정보(PII)로 분류되는 데이터로서 보안처리가 반드시 필요한 정보임. 현재 내 포트폴리오 DB에는 이런 내용을 모를때 세팅한거라 전화번호가 평문으로 저장되어있음. 따라서 전화번호를 암호화하는 로직 도입을 결정.  
       2. 알아보니 전화번호 암호화는 AES로 대표되는 양방향 암호화를 하는게 일반적이라고 하여, AES-256 방식으로 결정. 전화번호 암호화 유틸리티 클래스를 생성하여 암호화 로직과 복호화 로직을 세팅하고, application.properties에 암호화 키 설정.   
       3. 다음으로 암호화 키를 환경변수로 세팅해야하는데, 정확히 32바이트를 맞춰야한다고 해서 곤란해짐. 좀 더 편의성이 있는 방안을 찾다가, 키 유도 함수인 PBKDF2를 통해 키를 관리하면 개발자가 32바이트라는 제약에서 벗어나서 자유롭게 세팅할 수 있다는걸 알아냄. PBKDF2 \+ AES 방식으로 수정하여 다시 세팅.  
       4. UserService의 로직 중에 전화번호를 DB에 저장하고 꺼내는 부분에 전화번호 암호화 유틸리티 적용. 수정 로직이 제대로 작동하는지 테스트해보니 오류가 발생. 백엔드 로그를 확인해보니 DB에 저장할 수 있는 길이보다 긴 값을 저장하려해서 생기는 오류라는걸 확인. DB를 확인해보니 전화번호 칼럼 자료형이 VARCHAR인게 원인이라, TEXT로 변경. 정상 작동 확인.  
       5. 전화번호를 DB에 저장하고 꺼내는 로직이 있는 OrderService, PaymentService도 코드 수정.  
    3. JWT 관련 환경변수 세팅  
       1. 환경변수 설정을 이것저것 하다보니 JWT 상수를 환경변수로 세팅해야한다고 체크해놨던 것을 확인. 하드코딩되어있던 JWT 시크릿키와 만료시간을 환경변수로 옮기고, 보안성이 낮은 시크릿키를 보안성이 더 높도록 수정. 세팅을 변경하면서 JWT 상수를 불러다쓰는 JwtSupport에 오류가 생겨, 오류가 생기지 않도록 정리.  
60. 쇼핑몰 리액트 프론트엔드 작업  
    1. 로그아웃 로직 수정  
       1. JWT 상수를 환경변수로 돌린 후, 로그아웃을 해도 레이아웃 우상단 메뉴에 로그인 시 메뉴가 유지되는 문제 발견. 새로고침을 해도 로그인 시 메뉴가 유지되는걸보면 로그아웃을 해도 인증정보가 초기화되지 않는 걸로 추정됨. 검토해보니 AuthContext의 const logout 로직에서 로그아웃 API 호출 직후 early return되어 아래줄에 있는 ‘토큰&상태 초기화’ 로직이 작동하지 않아서 생기는 문제로 추정. 로그아웃 API 호출 직후 return 로직을 삭제하여 API 결과와 상관없이 아래줄로 로직이 넘어가도록 수정.  
       2. AuthContext의 const logout 로직을 수정하고 해결이 된건지 검토하면서 자세히 보니, 로그아웃 API는 호출 성공/실패 유무에 관계없이 토큰&인증 정보가 초기화되어야하는 기능인데도 관성적으로 try-catch 구조로 만들어놓은건 문제가 있다는걸 인지함. 따라서 try-catch 구조를 벗겨내고 API 호출결과에 상관없이 토큰&인증 정보를 초기화하도록 수정. 그리고 const logout를 await logout()으로 불러내는 레이아웃 컴포넌트와 관리자 레이아웃 컴포넌트의 로그아웃 로직에 try-catch 구조를 벗겨내고 API 호출결과에 상관없이 로그아웃 성공 메시지를 내도록 수정.  
       3. AuthContext의 const logout이 받을 수 있는 파라미터로 skipApiCall과 isWithdraw가 세팅되어있는데, await logout()으로 불러다쓰는 장소에서 어떤 파라미터를 세팅하는건지 시각적으로 명료하게 구분할 수 있도록 수정(await logout(true, true); → await logout({ skipApiCall: true, isWithdraw: true, reason: 'withdraw' });).  
    2. 마이페이지 그룹 작업  
       1. 해당 페이지들에서 로그아웃했을때 'email'을 읽을 수 없다거나 객체가 없다는 런타임 오류가 나오는 문제 발견. 아무래도 로그아웃 후 즉시 컴포넌트가 리렌더링되면서 발생하는 타이밍 이슈로 추정됨. email 정보는 user에 담겨있고 로그아웃하여 초기화된 user의 정보를 읽으려고 하면서 생기는 문제이니, useCallback 세팅된 함수들에 user가 null이면 early return시키는 로직 추가. 정상 작동 확인.  
    3. 관리자 페이지 그룹 작업  
       1. 마이페이지 그룹과 비슷한 문제가 발생할 가능성이 높은 관리자 페이지 그룹은 어떤지 확인. 예상대로 로그아웃했을때 객체가 없다는 런타임 오류가 나오는 문제가 그대로 발생중. 이전 작업과 동일하게 useCallback 세팅된 함수들에 user가 null이면 early return시키는 로직 추가. 정상 작동 확인.  
61. 깃허브에 포트폴리오 업로드 작업  
    1. 급하게 해결해야할 부분들이 정리된걸로 보여, 다시 깃허브 업로드 작업으로 돌아옴.   
    2. 테스트하면서 저장된 상품 이미지는 깃허브나 서버에 올라갈 필요가 없으니 .gitignore에 상품 이미지는 예외시키는 내용 추가.   
    3. 깃허브 업로드 전에 업로드 세팅 다시 확인하여 업로드 예외 폴더나 파일이 잘 적용되었는지 체크.  
    4. 커밋 후 푸쉬. 레포지토리에 정상 업로드 확인.  
    5. README.md 작업 시작